
NTI embedded project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000024c  00800100  000035f6  0000368a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000035f6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006bf  0080034c  0080034c  000038d6  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000038d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003934  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000740  00000000  00000000  00003970  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000866a  00000000  00000000  000040b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000027bb  00000000  00000000  0000c71a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004a34  00000000  00000000  0000eed5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001448  00000000  00000000  0001390c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000020ed  00000000  00000000  00014d54  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006624  00000000  00000000  00016e41  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006a0  00000000  00000000  0001d465  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	0c 94 0f 08 	jmp	0x101e	; 0x101e <__vector_1>
       8:	0c 94 3a 08 	jmp	0x1074	; 0x1074 <__vector_2>
       c:	0c 94 65 08 	jmp	0x10ca	; 0x10ca <__vector_3>
      10:	0c 94 90 08 	jmp	0x1120	; 0x1120 <__vector_4>
      14:	59 c0       	rjmp	.+178    	; 0xc8 <__bad_interrupt>
      16:	00 00       	nop
      18:	57 c0       	rjmp	.+174    	; 0xc8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	55 c0       	rjmp	.+170    	; 0xc8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	53 c0       	rjmp	.+166    	; 0xc8 <__bad_interrupt>
      22:	00 00       	nop
      24:	51 c0       	rjmp	.+162    	; 0xc8 <__bad_interrupt>
      26:	00 00       	nop
      28:	4f c0       	rjmp	.+158    	; 0xc8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4d c0       	rjmp	.+154    	; 0xc8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 81 0f 	jmp	0x1f02	; 0x1f02 <__vector_12>
      34:	49 c0       	rjmp	.+146    	; 0xc8 <__bad_interrupt>
      36:	00 00       	nop
      38:	47 c0       	rjmp	.+142    	; 0xc8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	45 c0       	rjmp	.+138    	; 0xc8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 47 09 	jmp	0x128e	; 0x128e <__vector_16>
      44:	41 c0       	rjmp	.+130    	; 0xc8 <__bad_interrupt>
      46:	00 00       	nop
      48:	0c 94 25 0b 	jmp	0x164a	; 0x164a <__vector_18>
      4c:	3d c0       	rjmp	.+122    	; 0xc8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3b c0       	rjmp	.+118    	; 0xc8 <__bad_interrupt>
      52:	00 00       	nop
      54:	39 c0       	rjmp	.+114    	; 0xc8 <__bad_interrupt>
      56:	00 00       	nop
      58:	37 c0       	rjmp	.+110    	; 0xc8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	35 c0       	rjmp	.+106    	; 0xc8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	33 c0       	rjmp	.+102    	; 0xc8 <__bad_interrupt>
      62:	00 00       	nop
      64:	31 c0       	rjmp	.+98     	; 0xc8 <__bad_interrupt>
      66:	00 00       	nop
      68:	2f c0       	rjmp	.+94     	; 0xc8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2d c0       	rjmp	.+90     	; 0xc8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2b c0       	rjmp	.+86     	; 0xc8 <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 26 0a 	jmp	0x144c	; 0x144c <__vector_29>
      78:	0c 94 50 0b 	jmp	0x16a0	; 0x16a0 <__vector_30>
      7c:	25 c0       	rjmp	.+74     	; 0xc8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	23 c0       	rjmp	.+70     	; 0xc8 <__bad_interrupt>
      82:	00 00       	nop
      84:	21 c0       	rjmp	.+66     	; 0xc8 <__bad_interrupt>
      86:	00 00       	nop
      88:	1f c0       	rjmp	.+62     	; 0xc8 <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	13 e0       	ldi	r17, 0x03	; 3
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e6 ef       	ldi	r30, 0xF6	; 246
      a0:	f5 e3       	ldi	r31, 0x35	; 53
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ac 34       	cpi	r26, 0x4C	; 76
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	2a e0       	ldi	r18, 0x0A	; 10
      b4:	ac e4       	ldi	r26, 0x4C	; 76
      b6:	b3 e0       	ldi	r27, 0x03	; 3
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	ab 30       	cpi	r26, 0x0B	; 11
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	31 d0       	rcall	.+98     	; 0x126 <main>
      c4:	0c 94 f9 1a 	jmp	0x35f2	; 0x35f2 <_exit>

000000c8 <__bad_interrupt>:
      c8:	9b cf       	rjmp	.-202    	; 0x0 <__vectors>

000000ca <DHT_Monitor>:
}
		/* DHT11 function to be called 
				during interrupt   */
void DHT_Monitor(void)
{
	if(system_up == 1)
      ca:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
      ce:	81 30       	cpi	r24, 0x01	; 1
      d0:	89 f4       	brne	.+34     	; 0xf4 <DHT_Monitor+0x2a>
	{
		Start_Signal();
      d2:	36 d5       	rcall	.+2668   	; 0xb40 <Start_Signal>
		Response_Signal();
      d4:	46 d5       	rcall	.+2700   	; 0xb62 <Response_Signal>
		I_H				=	Receive_data();
      d6:	4d d5       	rcall	.+2714   	; 0xb72 <Receive_data>
      d8:	80 93 50 03 	sts	0x0350, r24	; 0x800350 <I_H>
		D_H				=	Receive_data();
      dc:	4a d5       	rcall	.+2708   	; 0xb72 <Receive_data>
      de:	80 93 4f 03 	sts	0x034F, r24	; 0x80034f <D_H>
		I_Temp			=	Receive_data();
      e2:	47 d5       	rcall	.+2702   	; 0xb72 <Receive_data>
      e4:	80 93 4e 03 	sts	0x034E, r24	; 0x80034e <I_Temp>
		D_Temp			=	Receive_data();
      e8:	44 d5       	rcall	.+2696   	; 0xb72 <Receive_data>
      ea:	80 93 4d 03 	sts	0x034D, r24	; 0x80034d <D_Temp>
      ee:	41 d5       	rcall	.+2690   	; 0xb72 <Receive_data>
		CheckSum		=	Receive_data();
      f0:	80 93 4c 03 	sts	0x034C, r24	; 0x80034c <__data_end>
      f4:	08 95       	ret

000000f6 <System_Init>:
      f6:	80 e0       	ldi	r24, 0x00	; 0
      f8:	0e 94 cf 08 	call	0x119e	; 0x119e <Timer0_Init>
}
	/* Initialize needed prephirals*/
void System_Init(void)
{
	Timer0_Init(MODE_NORMAL);
	LDR_Init();
      fc:	4c d6       	rcall	.+3224   	; 0xd96 <LDR_Init>
	MQTT_Init();
      fe:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <MQTT_Init>
	ADC_INIT();
	Fan_Init();
     102:	79 d7       	rcall	.+3826   	; 0xff6 <ADC_INIT>
	Soil_Moisture_Init();
     104:	6e d5       	rcall	.+2780   	; 0xbe2 <Fan_Init>
	Water_Pump_Init();
     106:	66 d6       	rcall	.+3276   	; 0xdd4 <Soil_Moisture_Init>
	LCD_Init();
     108:	88 d6       	rcall	.+3344   	; 0xe1a <Water_Pump_Init>
     10a:	f1 d5       	rcall	.+3042   	; 0xcee <LCD_Init>
	Dim_LED_Init();
     10c:	78 d5       	rcall	.+2800   	; 0xbfe <Dim_LED_Init>
     10e:	81 e0       	ldi	r24, 0x01	; 1
	Wifi_Init(Station);
     110:	87 d6       	rcall	.+3342   	; 0xe20 <Wifi_Init>
     112:	40 e1       	ldi	r20, 0x10	; 16
     114:	57 e2       	ldi	r21, 0x27	; 39
	Timer0_SetNotification(DHT_Monitor,10000);
     116:	60 e0       	ldi	r22, 0x00	; 0
     118:	70 e0       	ldi	r23, 0x00	; 0
     11a:	85 e6       	ldi	r24, 0x65	; 101
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	0e 94 13 09 	call	0x1226	; 0x1226 <Timer0_SetNotification>
     122:	78 94       	sei
     124:	08 95       	ret

00000126 <main>:
	sei();
     126:	e7 df       	rcall	.-50     	; 0xf6 <System_Init>
     128:	43 e0       	ldi	r20, 0x03	; 3
{
	/* Replace with your application code */

	System_Init();
	/* create OS Services */
	vSemaphoreCreateBinary(bsConnect,1);
     12a:	60 e0       	ldi	r22, 0x00	; 0
     12c:	81 e0       	ldi	r24, 0x01	; 1
     12e:	0e 94 69 10 	call	0x20d2	; 0x20d2 <xQueueGenericCreate>
     132:	90 93 ff 09 	sts	0x09FF, r25	; 0x8009ff <bsConnect+0x1>
     136:	80 93 fe 09 	sts	0x09FE, r24	; 0x8009fe <bsConnect>
     13a:	00 97       	sbiw	r24, 0x00	; 0
     13c:	39 f0       	breq	.+14     	; 0x14c <main+0x26>
     13e:	20 e0       	ldi	r18, 0x00	; 0
     140:	40 e0       	ldi	r20, 0x00	; 0
     142:	50 e0       	ldi	r21, 0x00	; 0
     144:	60 e0       	ldi	r22, 0x00	; 0
     146:	70 e0       	ldi	r23, 0x00	; 0
     148:	0e 94 93 10 	call	0x2126	; 0x2126 <xQueueGenericSend>
	mqControl = xQueueCreate(2,30);  // length = 2  * (30 bytes)
     14c:	40 e0       	ldi	r20, 0x00	; 0
     14e:	6e e1       	ldi	r22, 0x1E	; 30
     150:	82 e0       	ldi	r24, 0x02	; 2
     152:	0e 94 69 10 	call	0x20d2	; 0x20d2 <xQueueGenericCreate>
     156:	90 93 f9 09 	sts	0x09F9, r25	; 0x8009f9 <mqControl+0x1>
     15a:	80 93 f8 09 	sts	0x09F8, r24	; 0x8009f8 <mqControl>
	//DHTreadings = xQueueCreate(10,1);
	egMQTT = xEventGroupCreate();
     15e:	0e 94 6f 0c 	call	0x18de	; 0x18de <xEventGroupCreate>
     162:	90 93 fb 09 	sts	0x09FB, r25	; 0x8009fb <egMQTT+0x1>
     166:	80 93 fa 09 	sts	0x09FA, r24	; 0x8009fa <egMQTT>
	
	/* create tasks */
	
	xTaskCreate(T_Self_Control,"T_Self_Control",150,NULL,1,NULL);
     16a:	a1 2c       	mov	r10, r1
     16c:	b1 2c       	mov	r11, r1
     16e:	c1 2c       	mov	r12, r1
     170:	d1 2c       	mov	r13, r1
     172:	e1 2c       	mov	r14, r1
     174:	f1 2c       	mov	r15, r1
     176:	01 e0       	ldi	r16, 0x01	; 1
     178:	20 e0       	ldi	r18, 0x00	; 0
     17a:	30 e0       	ldi	r19, 0x00	; 0
     17c:	46 e9       	ldi	r20, 0x96	; 150
     17e:	50 e0       	ldi	r21, 0x00	; 0
     180:	65 e0       	ldi	r22, 0x05	; 5
     182:	71 e0       	ldi	r23, 0x01	; 1
     184:	84 ea       	ldi	r24, 0xA4	; 164
     186:	94 e0       	ldi	r25, 0x04	; 4
     188:	0e 94 15 12 	call	0x242a	; 0x242a <xTaskGenericCreate>
	xTaskCreate(T_Monitor,"T_Monitor",150,NULL,2,NULL);
     18c:	02 e0       	ldi	r16, 0x02	; 2
     18e:	20 e0       	ldi	r18, 0x00	; 0
     190:	30 e0       	ldi	r19, 0x00	; 0
     192:	46 e9       	ldi	r20, 0x96	; 150
     194:	50 e0       	ldi	r21, 0x00	; 0
     196:	64 e1       	ldi	r22, 0x14	; 20
     198:	71 e0       	ldi	r23, 0x01	; 1
     19a:	88 ee       	ldi	r24, 0xE8	; 232
     19c:	92 e0       	ldi	r25, 0x02	; 2
     19e:	0e 94 15 12 	call	0x242a	; 0x242a <xTaskGenericCreate>
	xTaskCreate(T_Control,"T_Control",150,NULL,3,NULL);
     1a2:	03 e0       	ldi	r16, 0x03	; 3
     1a4:	20 e0       	ldi	r18, 0x00	; 0
     1a6:	30 e0       	ldi	r19, 0x00	; 0
     1a8:	46 e9       	ldi	r20, 0x96	; 150
     1aa:	50 e0       	ldi	r21, 0x00	; 0
     1ac:	6e e1       	ldi	r22, 0x1E	; 30
     1ae:	71 e0       	ldi	r23, 0x01	; 1
     1b0:	8e ea       	ldi	r24, 0xAE	; 174
     1b2:	91 e0       	ldi	r25, 0x01	; 1
     1b4:	0e 94 15 12 	call	0x242a	; 0x242a <xTaskGenericCreate>
	xTaskCreate(T_Connect,"T_Connect",200,NULL,4,NULL);
     1b8:	04 e0       	ldi	r16, 0x04	; 4
     1ba:	20 e0       	ldi	r18, 0x00	; 0
     1bc:	30 e0       	ldi	r19, 0x00	; 0
     1be:	48 ec       	ldi	r20, 0xC8	; 200
     1c0:	50 e0       	ldi	r21, 0x00	; 0
     1c2:	68 e2       	ldi	r22, 0x28	; 40
     1c4:	71 e0       	ldi	r23, 0x01	; 1
     1c6:	85 ef       	ldi	r24, 0xF5	; 245
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	0e 94 15 12 	call	0x242a	; 0x242a <xTaskGenericCreate>
	xTaskCreate(T_RespHandle,"T_RespHandle",100,NULL,5,NULL);
     1ce:	05 e0       	ldi	r16, 0x05	; 5
     1d0:	20 e0       	ldi	r18, 0x00	; 0
     1d2:	30 e0       	ldi	r19, 0x00	; 0
     1d4:	44 e6       	ldi	r20, 0x64	; 100
     1d6:	50 e0       	ldi	r21, 0x00	; 0
     1d8:	62 e3       	ldi	r22, 0x32	; 50
     1da:	71 e0       	ldi	r23, 0x01	; 1
     1dc:	8d ef       	ldi	r24, 0xFD	; 253
     1de:	93 e0       	ldi	r25, 0x03	; 3
     1e0:	0e 94 15 12 	call	0x242a	; 0x242a <xTaskGenericCreate>
	
	
	/* Start OS */
	
	vTaskStartScheduler();
     1e4:	0e 94 1a 13 	call	0x2634	; 0x2634 <vTaskStartScheduler>
     1e8:	ff cf       	rjmp	.-2      	; 0x1e8 <main+0xc2>

000001ea <T_Connect>:
Bool Wifi_Connecting = TRUE ; 

void T_Connect(void* pvData)
{
	EventBits_t ebValues = 0;
	Wifi_EchoMode(NoEcho);
     1ea:	80 e0       	ldi	r24, 0x00	; 0
     1ec:	40 d6       	rcall	.+3200   	; 0xe6e <Wifi_EchoMode>
	vTaskDelay(500);
     1ee:	84 ef       	ldi	r24, 0xF4	; 244
     1f0:	91 e0       	ldi	r25, 0x01	; 1
     1f2:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
	Wifi_Connecting = FALSE;
     1f6:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__DATA_REGION_ORIGIN__>
	vTaskDelay(500);
     1fa:	84 ef       	ldi	r24, 0xF4	; 244
     1fc:	91 e0       	ldi	r25, 0x01	; 1
     1fe:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
	Wifi_AP_Connect((INT_8U*)"etsh",(INT_8U*)"01001225199619");
     202:	6f e3       	ldi	r22, 0x3F	; 63
     204:	71 e0       	ldi	r23, 0x01	; 1
     206:	8e e4       	ldi	r24, 0x4E	; 78
     208:	91 e0       	ldi	r25, 0x01	; 1
     20a:	3f d6       	rcall	.+3198   	; 0xe8a <Wifi_AP_Connect>
	ebValues = xEventGroupWaitBits(egMQTT,WiFi_ACK,1,0,10000);
     20c:	00 e1       	ldi	r16, 0x10	; 16
     20e:	17 e2       	ldi	r17, 0x27	; 39
     210:	20 e0       	ldi	r18, 0x00	; 0
     212:	41 e0       	ldi	r20, 0x01	; 1
     214:	68 e0       	ldi	r22, 0x08	; 8
     216:	70 e0       	ldi	r23, 0x00	; 0
     218:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <egMQTT>
     21c:	90 91 fb 09 	lds	r25, 0x09FB	; 0x8009fb <egMQTT+0x1>
     220:	0e 94 80 0c 	call	0x1900	; 0x1900 <xEventGroupWaitBits>
	if(ebValues&WiFi_ACK)
     224:	83 ff       	sbrs	r24, 3
     226:	13 c0       	rjmp	.+38     	; 0x24e <T_Connect+0x64>
	{
		LCD_DispStrXY(1,1,(INT_8U*)"WiFi connected ");
     228:	43 e5       	ldi	r20, 0x53	; 83
     22a:	51 e0       	ldi	r21, 0x01	; 1
     22c:	61 e0       	ldi	r22, 0x01	; 1
     22e:	81 e0       	ldi	r24, 0x01	; 1
     230:	a1 d5       	rcall	.+2882   	; 0xd74 <LCD_DispStrXY>
		Wifi_Connecting = TRUE ;
     232:	81 e0       	ldi	r24, 0x01	; 1
     234:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
	}else
	{
		LCD_DispStrXY(1,1,(INT_8U*)"WiFi failed");
		while(1);
	}
	vTaskDelay(1000);
     238:	88 ee       	ldi	r24, 0xE8	; 232
     23a:	93 e0       	ldi	r25, 0x03	; 3
     23c:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
	Wifi_ConnectionMode(single);
     240:	80 e0       	ldi	r24, 0x00	; 0
     242:	58 d6       	rcall	.+3248   	; 0xef4 <Wifi_ConnectionMode>
	vTaskDelay(1000);
     244:	88 ee       	ldi	r24, 0xE8	; 232
     246:	93 e0       	ldi	r25, 0x03	; 3
     248:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
     24c:	06 c0       	rjmp	.+12     	; 0x25a <T_Connect+0x70>
	{
		LCD_DispStrXY(1,1,(INT_8U*)"WiFi connected ");
		Wifi_Connecting = TRUE ;
	}else
	{
		LCD_DispStrXY(1,1,(INT_8U*)"WiFi failed");
     24e:	43 e6       	ldi	r20, 0x63	; 99
     250:	51 e0       	ldi	r21, 0x01	; 1
     252:	61 e0       	ldi	r22, 0x01	; 1
     254:	81 e0       	ldi	r24, 0x01	; 1
     256:	8e d5       	rcall	.+2844   	; 0xd74 <LCD_DispStrXY>
     258:	ff cf       	rjmp	.-2      	; 0x258 <T_Connect+0x6e>
	vTaskDelay(1000);
	
	while(1)
	{
		/*  wait for disconnection */
		if(xSemaphoreTake(bsConnect,portMAX_DELAY))
     25a:	20 e0       	ldi	r18, 0x00	; 0
     25c:	4f ef       	ldi	r20, 0xFF	; 255
     25e:	5f ef       	ldi	r21, 0xFF	; 255
     260:	60 e0       	ldi	r22, 0x00	; 0
     262:	70 e0       	ldi	r23, 0x00	; 0
     264:	80 91 fe 09 	lds	r24, 0x09FE	; 0x8009fe <bsConnect>
     268:	90 91 ff 09 	lds	r25, 0x09FF	; 0x8009ff <bsConnect+0x1>
     26c:	0e 94 25 11 	call	0x224a	; 0x224a <xQueueGenericReceive>
     270:	88 23       	and	r24, r24
     272:	99 f3       	breq	.-26     	; 0x25a <T_Connect+0x70>
		{
			Wifi_Connecting = FALSE;
     274:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__DATA_REGION_ORIGIN__>
			Wifi_StartTCP_Conn((INT_8U*)"broker.hivemq.com",(INT_8U*)"1883",(INT_8U*)"10");
     278:	4f e6       	ldi	r20, 0x6F	; 111
     27a:	51 e0       	ldi	r21, 0x01	; 1
     27c:	62 e7       	ldi	r22, 0x72	; 114
     27e:	71 e0       	ldi	r23, 0x01	; 1
     280:	87 e7       	ldi	r24, 0x77	; 119
     282:	91 e0       	ldi	r25, 0x01	; 1
     284:	46 d6       	rcall	.+3212   	; 0xf12 <Wifi_StartTCP_Conn>
			ebValues = xEventGroupWaitBits(egMQTT,WiFi_ACK,1,0,4000);
     286:	00 ea       	ldi	r16, 0xA0	; 160
     288:	1f e0       	ldi	r17, 0x0F	; 15
     28a:	20 e0       	ldi	r18, 0x00	; 0
     28c:	41 e0       	ldi	r20, 0x01	; 1
     28e:	68 e0       	ldi	r22, 0x08	; 8
     290:	70 e0       	ldi	r23, 0x00	; 0
     292:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <egMQTT>
     296:	90 91 fb 09 	lds	r25, 0x09FB	; 0x8009fb <egMQTT+0x1>
     29a:	0e 94 80 0c 	call	0x1900	; 0x1900 <xEventGroupWaitBits>
			if(ebValues&WiFi_ACK)
     29e:	83 ff       	sbrs	r24, 3
			{
				LCD_DispStrXY(2,1,(INT_8U*)"Server connected ");
     2a0:	09 c0       	rjmp	.+18     	; 0x2b4 <T_Connect+0xca>
     2a2:	49 e8       	ldi	r20, 0x89	; 137
     2a4:	51 e0       	ldi	r21, 0x01	; 1
     2a6:	61 e0       	ldi	r22, 0x01	; 1
     2a8:	82 e0       	ldi	r24, 0x02	; 2
     2aa:	64 d5       	rcall	.+2760   	; 0xd74 <LCD_DispStrXY>
				Wifi_Connecting = TRUE;
     2ac:	81 e0       	ldi	r24, 0x01	; 1
     2ae:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
				
			}else
			{
				LCD_DispStrXY(2,1,(INT_8U*)"Server failed");
     2b2:	05 c0       	rjmp	.+10     	; 0x2be <T_Connect+0xd4>
     2b4:	4b e9       	ldi	r20, 0x9B	; 155
     2b6:	51 e0       	ldi	r21, 0x01	; 1
     2b8:	61 e0       	ldi	r22, 0x01	; 1
     2ba:	82 e0       	ldi	r24, 0x02	; 2
     2bc:	5b d5       	rcall	.+2742   	; 0xd74 <LCD_DispStrXY>
			}
			vTaskDelay(1000);
     2be:	88 ee       	ldi	r24, 0xE8	; 232
     2c0:	93 e0       	ldi	r25, 0x03	; 3
     2c2:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
			/* Connect  */
			MQTT_connect("Fedaa");
     2c6:	89 ea       	ldi	r24, 0xA9	; 169
     2c8:	91 e0       	ldi	r25, 0x01	; 1
     2ca:	0e 94 98 0b 	call	0x1730	; 0x1730 <MQTT_connect>
			/*wait CONNACK*/
			ebValues = xEventGroupWaitBits(egMQTT,E_MQTT_CONNACK,1,0,5000);
     2ce:	08 e8       	ldi	r16, 0x88	; 136
     2d0:	13 e1       	ldi	r17, 0x13	; 19
     2d2:	20 e0       	ldi	r18, 0x00	; 0
     2d4:	41 e0       	ldi	r20, 0x01	; 1
     2d6:	64 e0       	ldi	r22, 0x04	; 4
     2d8:	70 e0       	ldi	r23, 0x00	; 0
     2da:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <egMQTT>
     2de:	90 91 fb 09 	lds	r25, 0x09FB	; 0x8009fb <egMQTT+0x1>
     2e2:	0e 94 80 0c 	call	0x1900	; 0x1900 <xEventGroupWaitBits>
			if(ebValues&E_MQTT_CONNACK)
     2e6:	82 ff       	sbrs	r24, 2
     2e8:	2d c0       	rjmp	.+90     	; 0x344 <T_Connect+0x15a>
			{
				/* Connect done */
				vTaskDelay(1000);
     2ea:	88 ee       	ldi	r24, 0xE8	; 232
     2ec:	93 e0       	ldi	r25, 0x03	; 3
     2ee:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
				/*subscribe */
				MQTT_subscribe("SGH_control2020");
     2f2:	8f ea       	ldi	r24, 0xAF	; 175
     2f4:	91 e0       	ldi	r25, 0x01	; 1
     2f6:	0e 94 c6 0b 	call	0x178c	; 0x178c <MQTT_subscribe>
				/* suback */
				ebValues = xEventGroupWaitBits(egMQTT,E_MQTT_SUBACK,1,0,5000);
     2fa:	20 e0       	ldi	r18, 0x00	; 0
     2fc:	41 e0       	ldi	r20, 0x01	; 1
     2fe:	62 e0       	ldi	r22, 0x02	; 2
     300:	70 e0       	ldi	r23, 0x00	; 0
     302:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <egMQTT>
     306:	90 91 fb 09 	lds	r25, 0x09FB	; 0x8009fb <egMQTT+0x1>
     30a:	0e 94 80 0c 	call	0x1900	; 0x1900 <xEventGroupWaitBits>
				if(ebValues&E_MQTT_SUBACK)
     30e:	81 ff       	sbrs	r24, 1
				{
					/* subscribe done */
					system_up = 1 ;	
     310:	0d c0       	rjmp	.+26     	; 0x32c <T_Connect+0x142>
     312:	81 e0       	ldi	r24, 0x01	; 1
     314:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <system_up>
					LCD_DispStrXY(1,1,LCDreadings_Disp1);
     318:	4f eb       	ldi	r20, 0xBF	; 191
     31a:	51 e0       	ldi	r21, 0x01	; 1
     31c:	61 e0       	ldi	r22, 0x01	; 1
					LCD_DispStrXY(2,1,LCDreadings_Disp2);
     31e:	2a d5       	rcall	.+2644   	; 0xd74 <LCD_DispStrXY>
     320:	40 ed       	ldi	r20, 0xD0	; 208
     322:	51 e0       	ldi	r21, 0x01	; 1
     324:	61 e0       	ldi	r22, 0x01	; 1
     326:	82 e0       	ldi	r24, 0x02	; 2
     328:	25 d5       	rcall	.+2634   	; 0xd74 <LCD_DispStrXY>
     32a:	97 cf       	rjmp	.-210    	; 0x25a <T_Connect+0x70>
					
				}else
				{
					xSemaphoreGive(bsConnect);
     32c:	20 e0       	ldi	r18, 0x00	; 0
     32e:	40 e0       	ldi	r20, 0x00	; 0
     330:	50 e0       	ldi	r21, 0x00	; 0
     332:	60 e0       	ldi	r22, 0x00	; 0
     334:	70 e0       	ldi	r23, 0x00	; 0
     336:	80 91 fe 09 	lds	r24, 0x09FE	; 0x8009fe <bsConnect>
     33a:	90 91 ff 09 	lds	r25, 0x09FF	; 0x8009ff <bsConnect+0x1>
     33e:	0e 94 93 10 	call	0x2126	; 0x2126 <xQueueGenericSend>
     342:	8b cf       	rjmp	.-234    	; 0x25a <T_Connect+0x70>
				
				}
				
			}else
			{
				xSemaphoreGive(bsConnect);
     344:	20 e0       	ldi	r18, 0x00	; 0
     346:	40 e0       	ldi	r20, 0x00	; 0
     348:	50 e0       	ldi	r21, 0x00	; 0
     34a:	60 e0       	ldi	r22, 0x00	; 0
     34c:	70 e0       	ldi	r23, 0x00	; 0
     34e:	80 91 fe 09 	lds	r24, 0x09FE	; 0x8009fe <bsConnect>
     352:	90 91 ff 09 	lds	r25, 0x09FF	; 0x8009ff <bsConnect+0x1>
     356:	0e 94 93 10 	call	0x2126	; 0x2126 <xQueueGenericSend>
     35a:	7f cf       	rjmp	.-258    	; 0x25a <T_Connect+0x70>

0000035c <T_Control>:
#include "T_Control.h"

static INT_8U cmdPacket[30];

void T_Control(void* pvData)
{
     35c:	cf 93       	push	r28
     35e:	df 93       	push	r29
     360:	cd b7       	in	r28, 0x3d	; 61
     362:	de b7       	in	r29, 0x3e	; 62
     364:	2f 97       	sbiw	r28, 0x0f	; 15
     366:	0f b6       	in	r0, 0x3f	; 63
     368:	f8 94       	cli
     36a:	de bf       	out	0x3e, r29	; 62
     36c:	0f be       	out	0x3f, r0	; 63
     36e:	cd bf       	out	0x3d, r28	; 61
	INT_8U ind =0;
	char* ptrDol_Sign = NULL;
	char* ptrHash_Sign = NULL;
	INT_8U DataSize = 0;
	INT_8U data[15] = {'0'};
     370:	fe 01       	movw	r30, r28
     372:	31 96       	adiw	r30, 0x01	; 1
     374:	8f e0       	ldi	r24, 0x0F	; 15
     376:	df 01       	movw	r26, r30
     378:	1d 92       	st	X+, r1
     37a:	8a 95       	dec	r24
     37c:	e9 f7       	brne	.-6      	; 0x378 <T_Control+0x1c>
     37e:	80 e3       	ldi	r24, 0x30	; 48
     380:	89 83       	std	Y+1, r24	; 0x01

void T_Control(void* pvData)
{
	INT_8U ind =0;
	char* ptrDol_Sign = NULL;
	char* ptrHash_Sign = NULL;
     382:	c1 2c       	mov	r12, r1
     384:	d1 2c       	mov	r13, r1
static INT_8U cmdPacket[30];

void T_Control(void* pvData)
{
	INT_8U ind =0;
	char* ptrDol_Sign = NULL;
     386:	e1 2c       	mov	r14, r1
     388:	f1 2c       	mov	r15, r1

static INT_8U cmdPacket[30];

void T_Control(void* pvData)
{
	INT_8U ind =0;
     38a:	10 e0       	ldi	r17, 0x00	; 0
     38c:	5e 01       	movw	r10, r28
     38e:	b0 e1       	ldi	r27, 0x10	; 16
     390:	ab 0e       	add	r10, r27
     392:	b1 1c       	adc	r11, r1
				 {
					data[ind]=NULL;
				 }
				 for (ind = 0 ; ind <=DataSize ; ind++)
				 {
					 data[ind] = ptrDol_Sign[ind];
     394:	4f 01       	movw	r8, r30
     396:	7e 2e       	mov	r7, r30
     398:	09 2d       	mov	r16, r9
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     39a:	51 2c       	mov	r5, r1
     39c:	61 2c       	mov	r6, r1
				 {
					 data[ind] = ptrDol_Sign[ind];
				 }
				 if(strcmp(data,"$SC,ON#")==0)
				 {
					 SELF_CONTROL=1;
     39e:	44 24       	eor	r4, r4
     3a0:	43 94       	inc	r4
     3a2:	09 c0       	rjmp	.+18     	; 0x3b6 <T_Control+0x5a>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     3a4:	c5 2c       	mov	r12, r5
     3a6:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     3a8:	e5 2c       	mov	r14, r5
     3aa:	f6 2c       	mov	r15, r6
     3ac:	04 c0       	rjmp	.+8      	; 0x3b6 <T_Control+0x5a>
					 ptrHash_Sign = NULL;	
     3ae:	c5 2c       	mov	r12, r5
     3b0:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     3b2:	e5 2c       	mov	r14, r5
     3b4:	f6 2c       	mov	r15, r6
	INT_8U DataSize = 0;
	INT_8U data[15] = {'0'};
		
	while(1)
	{
		if(xQueueReceive(mqControl,cmdPacket,portMAX_DELAY))
     3b6:	20 e0       	ldi	r18, 0x00	; 0
     3b8:	4f ef       	ldi	r20, 0xFF	; 255
     3ba:	5f ef       	ldi	r21, 0xFF	; 255
     3bc:	61 e5       	ldi	r22, 0x51	; 81
     3be:	73 e0       	ldi	r23, 0x03	; 3
     3c0:	80 91 f8 09 	lds	r24, 0x09F8	; 0x8009f8 <mqControl>
     3c4:	90 91 f9 09 	lds	r25, 0x09F9	; 0x8009f9 <mqControl+0x1>
     3c8:	0e 94 25 11 	call	0x224a	; 0x224a <xQueueGenericReceive>
     3cc:	81 11       	cpse	r24, r1
     3ce:	14 c0       	rjmp	.+40     	; 0x3f8 <T_Control+0x9c>
     3d0:	f2 cf       	rjmp	.-28     	; 0x3b6 <T_Control+0x5a>
		{
			while(ind < 30)
			{
				ind++;
     3d2:	1f 5f       	subi	r17, 0xFF	; 255
				if(cmdPacket[ind]=='$')
     3d4:	21 2f       	mov	r18, r17
     3d6:	30 e0       	ldi	r19, 0x00	; 0
     3d8:	f9 01       	movw	r30, r18
     3da:	ef 5a       	subi	r30, 0xAF	; 175
     3dc:	fc 4f       	sbci	r31, 0xFC	; 252
     3de:	80 81       	ld	r24, Z
     3e0:	84 32       	cpi	r24, 0x24	; 36
     3e2:	11 f4       	brne	.+4      	; 0x3e8 <T_Control+0x8c>
				{
					ptrDol_Sign = &cmdPacket[ind];
     3e4:	7f 01       	movw	r14, r30
     3e6:	0b c0       	rjmp	.+22     	; 0x3fe <T_Control+0xa2>
				}
				if(cmdPacket[ind]=='#')
     3e8:	83 32       	cpi	r24, 0x23	; 35
     3ea:	49 f4       	brne	.+18     	; 0x3fe <T_Control+0xa2>
				{
					ptrHash_Sign = &cmdPacket[ind];
     3ec:	c9 01       	movw	r24, r18
     3ee:	8f 5a       	subi	r24, 0xAF	; 175
     3f0:	9c 4f       	sbci	r25, 0xFC	; 252
     3f2:	6c 01       	movw	r12, r24
					ind = 0;
     3f4:	10 e0       	ldi	r17, 0x00	; 0
					break;
     3f6:	05 c0       	rjmp	.+10     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
		
	while(1)
	{
		if(xQueueReceive(mqControl,cmdPacket,portMAX_DELAY))
		{
			while(ind < 30)
     3f8:	1e 31       	cpi	r17, 0x1E	; 30
     3fa:	58 f3       	brcs	.-42     	; 0x3d2 <T_Control+0x76>
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
     3fe:	1e 31       	cpi	r17, 0x1E	; 30
     400:	41 f7       	brne	.-48     	; 0x3d2 <T_Control+0x76>
					break;
				}
				
			}
			
			if(ptrDol_Sign != NULL && ptrHash_Sign != NULL)
     402:	e1 14       	cp	r14, r1
     404:	f1 04       	cpc	r15, r1
     406:	b9 f2       	breq	.-82     	; 0x3b6 <T_Control+0x5a>
     408:	c1 14       	cp	r12, r1
     40a:	d1 04       	cpc	r13, r1
     40c:	a1 f2       	breq	.-88     	; 0x3b6 <T_Control+0x5a>
			{
				DataSize = ptrHash_Sign - ptrDol_Sign;
     40e:	ce 18       	sub	r12, r14
     410:	fe 01       	movw	r30, r28
     412:	31 96       	adiw	r30, 0x01	; 1
				
				for(ind = 0 ; ind < 15 ; ind++)
				 {
					data[ind]=NULL;
     414:	11 92       	st	Z+, r1
			
			if(ptrDol_Sign != NULL && ptrHash_Sign != NULL)
			{
				DataSize = ptrHash_Sign - ptrDol_Sign;
				
				for(ind = 0 ; ind < 15 ; ind++)
     416:	ea 15       	cp	r30, r10
     418:	fb 05       	cpc	r31, r11
     41a:	e1 f7       	brne	.-8      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
     41c:	10 e0       	ldi	r17, 0x00	; 0
				 {
					data[ind]=NULL;
				 }
				 for (ind = 0 ; ind <=DataSize ; ind++)
				 {
					 data[ind] = ptrDol_Sign[ind];
     41e:	81 2f       	mov	r24, r17
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	f4 01       	movw	r30, r8
     424:	e8 0f       	add	r30, r24
     426:	f9 1f       	adc	r31, r25
     428:	d7 01       	movw	r26, r14
     42a:	a8 0f       	add	r26, r24
     42c:	b9 1f       	adc	r27, r25
     42e:	8c 91       	ld	r24, X
     430:	80 83       	st	Z, r24
				
				for(ind = 0 ; ind < 15 ; ind++)
				 {
					data[ind]=NULL;
				 }
				 for (ind = 0 ; ind <=DataSize ; ind++)
     432:	1f 5f       	subi	r17, 0xFF	; 255
     434:	c1 16       	cp	r12, r17
     436:	98 f7       	brcc	.-26     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
				 {
					 data[ind] = ptrDol_Sign[ind];
				 }
				 if(strcmp(data,"$SC,ON#")==0)
     438:	61 ee       	ldi	r22, 0xE1	; 225
     43a:	71 e0       	ldi	r23, 0x01	; 1
     43c:	87 2d       	mov	r24, r7
     43e:	90 2f       	mov	r25, r16
     440:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     444:	89 2b       	or	r24, r25
     446:	39 f4       	brne	.+14     	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
				 {
					 SELF_CONTROL=1;
     448:	40 92 6f 03 	sts	0x036F, r4	; 0x80036f <SELF_CONTROL>
					// MQTT_publish("SGH_SC",(INT_8U*)"ON",2,0);
					 vTaskDelay(500);
     44c:	84 ef       	ldi	r24, 0xF4	; 244
     44e:	91 e0       	ldi	r25, 0x01	; 1
     450:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
     454:	0e c0       	rjmp	.+28     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
				 }else if(strcmp(data,"$SC,OFF#")==0)
     456:	69 ee       	ldi	r22, 0xE9	; 233
     458:	71 e0       	ldi	r23, 0x01	; 1
     45a:	87 2d       	mov	r24, r7
     45c:	90 2f       	mov	r25, r16
     45e:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     462:	89 2b       	or	r24, r25
     464:	31 f4       	brne	.+12     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
				 {
					 SELF_CONTROL=0;
     466:	10 92 6f 03 	sts	0x036F, r1	; 0x80036f <SELF_CONTROL>
					 //MQTT_publish("SGH_SC",(INT_8U*)"OFF",3,0);
					 vTaskDelay(500);
     46a:	84 ef       	ldi	r24, 0xF4	; 244
     46c:	91 e0       	ldi	r25, 0x01	; 1
     46e:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
				 }
				  if (SELF_CONTROL==0)
     472:	80 91 6f 03 	lds	r24, 0x036F	; 0x80036f <SELF_CONTROL>
     476:	81 11       	cpse	r24, r1
     478:	95 cf       	rjmp	.-214    	; 0x3a4 <T_Control+0x48>
				  {
					if(strcmp(data,"$FAN,ON#")==0)
     47a:	62 ef       	ldi	r22, 0xF2	; 242
     47c:	71 e0       	ldi	r23, 0x01	; 1
     47e:	87 2d       	mov	r24, r7
     480:	90 2f       	mov	r25, r16
     482:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     486:	89 2b       	or	r24, r25
     488:	51 f4       	brne	.+20     	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
					{
						Fan_On();
     48a:	9f d3       	rcall	.+1854   	; 0xbca <Fan_On>
						//MQTT_publish("SGH_FAN",(INT_8U*)"ON",2,0);
						vTaskDelay(500);
     48c:	84 ef       	ldi	r24, 0xF4	; 244
     48e:	91 e0       	ldi	r25, 0x01	; 1
     490:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     494:	c5 2c       	mov	r12, r5
     496:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     498:	e5 2c       	mov	r14, r5
     49a:	f6 2c       	mov	r15, r6
     49c:	8c cf       	rjmp	.-232    	; 0x3b6 <T_Control+0x5a>
					if(strcmp(data,"$FAN,ON#")==0)
					{
						Fan_On();
						//MQTT_publish("SGH_FAN",(INT_8U*)"ON",2,0);
						vTaskDelay(500);
					 }else if(strcmp(data,"$FAN,OFF#")==0)
     49e:	6b ef       	ldi	r22, 0xFB	; 251
     4a0:	71 e0       	ldi	r23, 0x01	; 1
     4a2:	87 2d       	mov	r24, r7
     4a4:	90 2f       	mov	r25, r16
     4a6:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     4aa:	89 2b       	or	r24, r25
					 {
						Fan_Off();
     4ac:	51 f4       	brne	.+20     	; 0x4c2 <__LOCK_REGION_LENGTH__+0xc2>
     4ae:	93 d3       	rcall	.+1830   	; 0xbd6 <Fan_Off>
						//MQTT_publish("SGH_FAN",(INT_8U*)"OFF",3,0);
						vTaskDelay(500);
     4b0:	84 ef       	ldi	r24, 0xF4	; 244
     4b2:	91 e0       	ldi	r25, 0x01	; 1
     4b4:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     4b8:	c5 2c       	mov	r12, r5
     4ba:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     4bc:	e5 2c       	mov	r14, r5
     4be:	f6 2c       	mov	r15, r6
     4c0:	7a cf       	rjmp	.-268    	; 0x3b6 <T_Control+0x5a>
					 }else if(strcmp(data,"$FAN,OFF#")==0)
					 {
						Fan_Off();
						//MQTT_publish("SGH_FAN",(INT_8U*)"OFF",3,0);
						vTaskDelay(500);
					 }else if(strcmp(data,"$WP,ON#")==0)
     4c2:	65 e0       	ldi	r22, 0x05	; 5
     4c4:	72 e0       	ldi	r23, 0x02	; 2
     4c6:	87 2d       	mov	r24, r7
     4c8:	90 2f       	mov	r25, r16
     4ca:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     4ce:	89 2b       	or	r24, r25
					 {
						 Water_Pump_ON();
     4d0:	51 f4       	brne	.+20     	; 0x4e6 <__LOCK_REGION_LENGTH__+0xe6>
     4d2:	9f d4       	rcall	.+2366   	; 0xe12 <Water_Pump_ON>
						//MQTT_publish("SGH_PUMP",(INT_8U*)"ON",2,0);
						vTaskDelay(500);
     4d4:	84 ef       	ldi	r24, 0xF4	; 244
     4d6:	91 e0       	ldi	r25, 0x01	; 1
     4d8:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     4dc:	c5 2c       	mov	r12, r5
     4de:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     4e0:	e5 2c       	mov	r14, r5
     4e2:	f6 2c       	mov	r15, r6
     4e4:	68 cf       	rjmp	.-304    	; 0x3b6 <T_Control+0x5a>
					 }else if(strcmp(data,"$WP,ON#")==0)
					 {
						 Water_Pump_ON();
						//MQTT_publish("SGH_PUMP",(INT_8U*)"ON",2,0);
						vTaskDelay(500);
					 }else if(strcmp(data,"$WP,OFF#")==0)
     4e6:	6d e0       	ldi	r22, 0x0D	; 13
     4e8:	72 e0       	ldi	r23, 0x02	; 2
     4ea:	87 2d       	mov	r24, r7
     4ec:	90 2f       	mov	r25, r16
     4ee:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     4f2:	89 2b       	or	r24, r25
					 {
						 Water_Pump_OFF();
     4f4:	51 f4       	brne	.+20     	; 0x50a <__LOCK_REGION_LENGTH__+0x10a>
     4f6:	8f d4       	rcall	.+2334   	; 0xe16 <Water_Pump_OFF>
						 //MQTT_publish("SGH_PUMP",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
     4f8:	84 ef       	ldi	r24, 0xF4	; 244
     4fa:	91 e0       	ldi	r25, 0x01	; 1
     4fc:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     500:	c5 2c       	mov	r12, r5
     502:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     504:	e5 2c       	mov	r14, r5
     506:	f6 2c       	mov	r15, r6
     508:	56 cf       	rjmp	.-340    	; 0x3b6 <T_Control+0x5a>
					 {
						 Water_Pump_OFF();
						 //MQTT_publish("SGH_PUMP",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
						 
					 }else if(strcmp(data,"$LIGHT,100#")==0)
     50a:	66 e1       	ldi	r22, 0x16	; 22
     50c:	72 e0       	ldi	r23, 0x02	; 2
     50e:	87 2d       	mov	r24, r7
     510:	90 2f       	mov	r25, r16
     512:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     516:	89 2b       	or	r24, r25
					 {
						 Dim_LED_Stop();
     518:	51 f4       	brne	.+20     	; 0x52e <__LOCK_REGION_LENGTH__+0x12e>
     51a:	77 d3       	rcall	.+1774   	; 0xc0a <Dim_LED_Stop>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"100%",4,0);
						 vTaskDelay(500);
     51c:	84 ef       	ldi	r24, 0xF4	; 244
     51e:	91 e0       	ldi	r25, 0x01	; 1
     520:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     524:	c5 2c       	mov	r12, r5
     526:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     528:	e5 2c       	mov	r14, r5
     52a:	f6 2c       	mov	r15, r6
     52c:	44 cf       	rjmp	.-376    	; 0x3b6 <T_Control+0x5a>
					 }else if(strcmp(data,"$LIGHT,100#")==0)
					 {
						 Dim_LED_Stop();
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"100%",4,0);
						 vTaskDelay(500);
					 }else if(strcmp(data,"$LIGHT,75#")==0)
     52e:	62 e2       	ldi	r22, 0x22	; 34
     530:	72 e0       	ldi	r23, 0x02	; 2
     532:	87 2d       	mov	r24, r7
     534:	90 2f       	mov	r25, r16
     536:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     53a:	89 2b       	or	r24, r25
					 {
						 Dim_LED_Brightness(25);
     53c:	61 f4       	brne	.+24     	; 0x556 <__LOCK_REGION_LENGTH__+0x156>
     53e:	89 e1       	ldi	r24, 0x19	; 25
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	56 d3       	rcall	.+1708   	; 0xbf0 <Dim_LED_Brightness>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"75%",3,0);
						 vTaskDelay(500);
     544:	84 ef       	ldi	r24, 0xF4	; 244
     546:	91 e0       	ldi	r25, 0x01	; 1
     548:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     54c:	c5 2c       	mov	r12, r5
     54e:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     550:	e5 2c       	mov	r14, r5
     552:	f6 2c       	mov	r15, r6
     554:	30 cf       	rjmp	.-416    	; 0x3b6 <T_Control+0x5a>
					 }else if(strcmp(data,"$LIGHT,75#")==0)
					 {
						 Dim_LED_Brightness(25);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"75%",3,0);
						 vTaskDelay(500);
					 }else if(strcmp(data,"$LIGHT,50#")==0)
     556:	6d e2       	ldi	r22, 0x2D	; 45
     558:	72 e0       	ldi	r23, 0x02	; 2
     55a:	87 2d       	mov	r24, r7
     55c:	90 2f       	mov	r25, r16
     55e:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     562:	89 2b       	or	r24, r25
					 {
						 Dim_LED_Brightness(50);
     564:	61 f4       	brne	.+24     	; 0x57e <__LOCK_REGION_LENGTH__+0x17e>
     566:	82 e3       	ldi	r24, 0x32	; 50
     568:	90 e0       	ldi	r25, 0x00	; 0
     56a:	42 d3       	rcall	.+1668   	; 0xbf0 <Dim_LED_Brightness>
						 //QTT_publish("SGH_LIGHT",(INT_8U*)"50%",3,0);
						 vTaskDelay(500);
     56c:	84 ef       	ldi	r24, 0xF4	; 244
     56e:	91 e0       	ldi	r25, 0x01	; 1
     570:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     574:	c5 2c       	mov	r12, r5
     576:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     578:	e5 2c       	mov	r14, r5
     57a:	f6 2c       	mov	r15, r6
     57c:	1c cf       	rjmp	.-456    	; 0x3b6 <T_Control+0x5a>
					 }else if(strcmp(data,"$LIGHT,50#")==0)
					 {
						 Dim_LED_Brightness(50);
						 //QTT_publish("SGH_LIGHT",(INT_8U*)"50%",3,0);
						 vTaskDelay(500);
					 }else if(strcmp(data,"$LIGHT,25#")==0)
     57e:	68 e3       	ldi	r22, 0x38	; 56
     580:	72 e0       	ldi	r23, 0x02	; 2
     582:	87 2d       	mov	r24, r7
     584:	90 2f       	mov	r25, r16
     586:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     58a:	89 2b       	or	r24, r25
					 {
						 Dim_LED_Brightness(75);
     58c:	61 f4       	brne	.+24     	; 0x5a6 <__LOCK_REGION_LENGTH__+0x1a6>
     58e:	8b e4       	ldi	r24, 0x4B	; 75
     590:	90 e0       	ldi	r25, 0x00	; 0
     592:	2e d3       	rcall	.+1628   	; 0xbf0 <Dim_LED_Brightness>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"25%",3,0);
						 vTaskDelay(500);
     594:	84 ef       	ldi	r24, 0xF4	; 244
     596:	91 e0       	ldi	r25, 0x01	; 1
     598:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     59c:	c5 2c       	mov	r12, r5
     59e:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     5a0:	e5 2c       	mov	r14, r5
     5a2:	f6 2c       	mov	r15, r6
     5a4:	08 cf       	rjmp	.-496    	; 0x3b6 <T_Control+0x5a>
					 }else if(strcmp(data,"$LIGHT,25#")==0)
					 {
						 Dim_LED_Brightness(75);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"25%",3,0);
						 vTaskDelay(500);
					 }else if(strcmp(data,"$LIGHT,0#")==0)
     5a6:	63 e4       	ldi	r22, 0x43	; 67
     5a8:	72 e0       	ldi	r23, 0x02	; 2
     5aa:	87 2d       	mov	r24, r7
     5ac:	90 2f       	mov	r25, r16
     5ae:	0e 94 15 18 	call	0x302a	; 0x302a <strcmp>
     5b2:	89 2b       	or	r24, r25
     5b4:	09 f0       	breq	.+2      	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
					 {
						 Dim_LED_Brightness(100);
     5b6:	fb ce       	rjmp	.-522    	; 0x3ae <T_Control+0x52>
     5b8:	84 e6       	ldi	r24, 0x64	; 100
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	19 d3       	rcall	.+1586   	; 0xbf0 <Dim_LED_Brightness>
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
     5be:	84 ef       	ldi	r24, 0xF4	; 244
     5c0:	91 e0       	ldi	r25, 0x01	; 1
     5c2:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
					 }
				 }
					 ptrDol_Sign = NULL;
					 ptrHash_Sign = NULL;	
     5c6:	c5 2c       	mov	r12, r5
     5c8:	d6 2c       	mov	r13, r6
						 Dim_LED_Brightness(100);
						 //MQTT_publish("SGH_LIGHT",(INT_8U*)"OFF",3,0);
						 vTaskDelay(500);
					 }
				 }
					 ptrDol_Sign = NULL;
     5ca:	e5 2c       	mov	r14, r5
     5cc:	f6 2c       	mov	r15, r6
     5ce:	f3 ce       	rjmp	.-538    	; 0x3b6 <T_Control+0x5a>

000005d0 <T_Monitor>:
 */ 

#include "T_Monitor.h"

void T_Monitor(void* pvData)
{
     5d0:	cf 93       	push	r28
     5d2:	df 93       	push	r29
     5d4:	cd b7       	in	r28, 0x3d	; 61
     5d6:	de b7       	in	r29, 0x3e	; 62
     5d8:	64 97       	sbiw	r28, 0x14	; 20
     5da:	0f b6       	in	r0, 0x3f	; 63
     5dc:	f8 94       	cli
     5de:	de bf       	out	0x3e, r29	; 62
     5e0:	0f be       	out	0x3f, r0	; 63
     5e2:	cd bf       	out	0x3d, r28	; 61
		/*	arrays to convert sensors readings to strings
			to be displayed published  	*/
	INT_8U H_data[5] = {'0'};
     5e4:	95 e0       	ldi	r25, 0x05	; 5
     5e6:	fe 01       	movw	r30, r28
     5e8:	31 96       	adiw	r30, 0x01	; 1
     5ea:	df 01       	movw	r26, r30
     5ec:	29 2f       	mov	r18, r25
     5ee:	1d 92       	st	X+, r1
     5f0:	2a 95       	dec	r18
     5f2:	e9 f7       	brne	.-6      	; 0x5ee <T_Monitor+0x1e>
     5f4:	80 e3       	ldi	r24, 0x30	; 48
     5f6:	89 83       	std	Y+1, r24	; 0x01
	INT_8U T_data[5] = {'0'};
     5f8:	35 96       	adiw	r30, 0x05	; 5
     5fa:	df 01       	movw	r26, r30
     5fc:	29 2f       	mov	r18, r25
     5fe:	1d 92       	st	X+, r1
     600:	2a 95       	dec	r18
     602:	e9 f7       	brne	.-6      	; 0x5fe <T_Monitor+0x2e>
     604:	8e 83       	std	Y+6, r24	; 0x06
	INT_8U soil_arr[5] = {'0'};
     606:	35 96       	adiw	r30, 0x05	; 5
     608:	df 01       	movw	r26, r30
     60a:	29 2f       	mov	r18, r25
     60c:	1d 92       	st	X+, r1
     60e:	2a 95       	dec	r18
     610:	e9 f7       	brne	.-6      	; 0x60c <T_Monitor+0x3c>
     612:	8b 87       	std	Y+11, r24	; 0x0b
	INT_8U light_arr[5] = {'0'};
     614:	35 96       	adiw	r30, 0x05	; 5
     616:	df 01       	movw	r26, r30
     618:	1d 92       	st	X+, r1
     61a:	9a 95       	dec	r25
     61c:	e9 f7       	brne	.-6      	; 0x618 <T_Monitor+0x48>
     61e:	88 8b       	std	Y+16, r24	; 0x10
				/* Ping received */
				vTaskDelay(1000);
				
				/* Read,display & publish ldr value */
				LDR_Val(&light);
				sprintf(light_arr,"%d",light);
     620:	0f 2e       	mov	r0, r31
     622:	fd e4       	ldi	r31, 0x4D	; 77
     624:	af 2e       	mov	r10, r31
     626:	f2 e0       	ldi	r31, 0x02	; 2
     628:	bf 2e       	mov	r11, r31
     62a:	f0 2d       	mov	r31, r0
     62c:	6f 01       	movw	r12, r30
				MQTT_publish("L_Monitor",(INT_8U*)light_arr,strlen(light_arr),0);		
				LCD_DispStrXY(2,13,(INT_8U*)light_arr);
				vTaskDelay(700);
				/* Read,display & publish soil moisture value */
				Soil_Moisture_Read(&Soil_data);
				sprintf(soil_arr,"%d",Soil_data);
     62e:	7e 01       	movw	r14, r28
     630:	2b e0       	ldi	r18, 0x0B	; 11
     632:	e2 0e       	add	r14, r18
     634:	f1 1c       	adc	r15, r1
					LCD_DispStrXY(1,0,(INT_8U*)"Error");
				}
				else
				{
					/* display & publish humidity value */
					sprintf(H_data,"%d",I_H);
     636:	be 01       	movw	r22, r28
     638:	6f 5f       	subi	r22, 0xFF	; 255
     63a:	7f 4f       	sbci	r23, 0xFF	; 255
     63c:	3b 01       	movw	r6, r22
					MQTT_publish("H_Monitor",(INT_8U*)H_data,strlen(H_data),0);
					LCD_DispStrXY(2,5,(INT_8U*)H_data);
					vTaskDelay(700);
					/* display & publish temperature value */
					sprintf(T_data,"%d",I_Temp);
     63e:	4e 01       	movw	r8, r28
     640:	76 e0       	ldi	r23, 0x06	; 6
     642:	87 0e       	add	r8, r23
     644:	91 1c       	adc	r9, r1
	EventBits_t ebValues = 0;
	while(1)
	{
		/*  system_up : is set to check on system 
			and created at T_connect*/
		if (system_up == 1)
     646:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
     64a:	81 30       	cpi	r24, 0x01	; 1
     64c:	09 f0       	breq	.+2      	; 0x650 <T_Monitor+0x80>
     64e:	d0 c0       	rjmp	.+416    	; 0x7f0 <T_Monitor+0x220>
		{
			MQTT_Ping();
     650:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <MQTT_Ping>
			ebValues = xEventGroupWaitBits(egMQTT,E_MQTT_PINGREQ,1,0,5000);
     654:	08 e8       	ldi	r16, 0x88	; 136
     656:	13 e1       	ldi	r17, 0x13	; 19
     658:	20 e0       	ldi	r18, 0x00	; 0
     65a:	41 e0       	ldi	r20, 0x01	; 1
     65c:	60 e1       	ldi	r22, 0x10	; 16
     65e:	70 e0       	ldi	r23, 0x00	; 0
     660:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <egMQTT>
     664:	90 91 fb 09 	lds	r25, 0x09FB	; 0x8009fb <egMQTT+0x1>
     668:	0e 94 80 0c 	call	0x1900	; 0x1900 <xEventGroupWaitBits>
			if(ebValues&E_MQTT_PINGREQ)
     66c:	84 ff       	sbrs	r24, 4
     66e:	b3 c0       	rjmp	.+358    	; 0x7d6 <T_Monitor+0x206>
			{
				/* Ping received */
				vTaskDelay(1000);
     670:	88 ee       	ldi	r24, 0xE8	; 232
     672:	93 e0       	ldi	r25, 0x03	; 3
     674:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
				
				/* Read,display & publish ldr value */
				LDR_Val(&light);
     678:	82 e7       	ldi	r24, 0x72	; 114
     67a:	93 e0       	ldi	r25, 0x03	; 3
     67c:	8e d3       	rcall	.+1820   	; 0xd9a <LDR_Val>
				sprintf(light_arr,"%d",light);
     67e:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <light+0x1>
     682:	8f 93       	push	r24
     684:	80 91 72 03 	lds	r24, 0x0372	; 0x800372 <light>
     688:	8f 93       	push	r24
     68a:	bf 92       	push	r11
     68c:	af 92       	push	r10
     68e:	df 92       	push	r13
     690:	cf 92       	push	r12
     692:	0e 94 1e 18 	call	0x303c	; 0x303c <sprintf>
				MQTT_publish("L_Monitor",(INT_8U*)light_arr,strlen(light_arr),0);		
     696:	f6 01       	movw	r30, r12
     698:	01 90       	ld	r0, Z+
     69a:	00 20       	and	r0, r0
     69c:	e9 f7       	brne	.-6      	; 0x698 <T_Monitor+0xc8>
     69e:	31 97       	sbiw	r30, 0x01	; 1
     6a0:	af 01       	movw	r20, r30
     6a2:	4c 19       	sub	r20, r12
     6a4:	5d 09       	sbc	r21, r13
     6a6:	20 e0       	ldi	r18, 0x00	; 0
     6a8:	b6 01       	movw	r22, r12
     6aa:	80 e5       	ldi	r24, 0x50	; 80
     6ac:	92 e0       	ldi	r25, 0x02	; 2
     6ae:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <MQTT_publish>
				LCD_DispStrXY(2,13,(INT_8U*)light_arr);
     6b2:	a6 01       	movw	r20, r12
     6b4:	6d e0       	ldi	r22, 0x0D	; 13
     6b6:	82 e0       	ldi	r24, 0x02	; 2
     6b8:	5d d3       	rcall	.+1722   	; 0xd74 <LCD_DispStrXY>
				vTaskDelay(700);
     6ba:	8c eb       	ldi	r24, 0xBC	; 188
     6bc:	92 e0       	ldi	r25, 0x02	; 2
     6be:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
				/* Read,display & publish soil moisture value */
				Soil_Moisture_Read(&Soil_data);
     6c2:	80 e7       	ldi	r24, 0x70	; 112
     6c4:	93 e0       	ldi	r25, 0x03	; 3
     6c6:	88 d3       	rcall	.+1808   	; 0xdd8 <Soil_Moisture_Read>
				sprintf(soil_arr,"%d",Soil_data);
     6c8:	80 91 71 03 	lds	r24, 0x0371	; 0x800371 <Soil_data+0x1>
     6cc:	8f 93       	push	r24
     6ce:	80 91 70 03 	lds	r24, 0x0370	; 0x800370 <Soil_data>
     6d2:	8f 93       	push	r24
     6d4:	bf 92       	push	r11
     6d6:	af 92       	push	r10
     6d8:	ff 92       	push	r15
     6da:	ef 92       	push	r14
     6dc:	0e 94 1e 18 	call	0x303c	; 0x303c <sprintf>
				MQTT_publish("SM_Monitor",(INT_8U*)soil_arr,strlen(soil_arr),0);
     6e0:	f7 01       	movw	r30, r14
     6e2:	01 90       	ld	r0, Z+
     6e4:	00 20       	and	r0, r0
     6e6:	e9 f7       	brne	.-6      	; 0x6e2 <T_Monitor+0x112>
     6e8:	31 97       	sbiw	r30, 0x01	; 1
     6ea:	af 01       	movw	r20, r30
     6ec:	4e 19       	sub	r20, r14
     6ee:	5f 09       	sbc	r21, r15
     6f0:	20 e0       	ldi	r18, 0x00	; 0
     6f2:	b7 01       	movw	r22, r14
     6f4:	8a e5       	ldi	r24, 0x5A	; 90
     6f6:	92 e0       	ldi	r25, 0x02	; 2
     6f8:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <MQTT_publish>
				LCD_DispStrXY(1,14,(INT_8U*)soil_arr);
     6fc:	a7 01       	movw	r20, r14
     6fe:	6e e0       	ldi	r22, 0x0E	; 14
     700:	81 e0       	ldi	r24, 0x01	; 1
     702:	38 d3       	rcall	.+1648   	; 0xd74 <LCD_DispStrXY>
				vTaskDelay(1000);
     704:	88 ee       	ldi	r24, 0xE8	; 232
     706:	93 e0       	ldi	r25, 0x03	; 3
     708:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
	
				if ((I_H+D_H+I_Temp+D_Temp) != CheckSum)
     70c:	40 91 50 03 	lds	r20, 0x0350	; 0x800350 <I_H>
     710:	80 91 4f 03 	lds	r24, 0x034F	; 0x80034f <D_H>
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	84 0f       	add	r24, r20
     718:	91 1d       	adc	r25, r1
     71a:	20 91 4e 03 	lds	r18, 0x034E	; 0x80034e <I_Temp>
     71e:	82 0f       	add	r24, r18
     720:	91 1d       	adc	r25, r1
     722:	20 91 4d 03 	lds	r18, 0x034D	; 0x80034d <D_Temp>
     726:	82 0f       	add	r24, r18
     728:	91 1d       	adc	r25, r1
     72a:	20 91 4c 03 	lds	r18, 0x034C	; 0x80034c <__data_end>
     72e:	30 e0       	ldi	r19, 0x00	; 0
     730:	0f b6       	in	r0, 0x3f	; 63
     732:	f8 94       	cli
     734:	de bf       	out	0x3e, r29	; 62
     736:	0f be       	out	0x3f, r0	; 63
     738:	cd bf       	out	0x3d, r28	; 61
     73a:	82 17       	cp	r24, r18
     73c:	93 07       	cpc	r25, r19
     73e:	31 f0       	breq	.+12     	; 0x74c <T_Monitor+0x17c>
				{
					LCD_DispStrXY(1,0,(INT_8U*)"Error");
     740:	45 e6       	ldi	r20, 0x65	; 101
     742:	52 e0       	ldi	r21, 0x02	; 2
     744:	60 e0       	ldi	r22, 0x00	; 0
     746:	81 e0       	ldi	r24, 0x01	; 1
     748:	15 d3       	rcall	.+1578   	; 0xd74 <LCD_DispStrXY>
     74a:	52 c0       	rjmp	.+164    	; 0x7f0 <T_Monitor+0x220>
				}
				else
				{
					/* display & publish humidity value */
					sprintf(H_data,"%d",I_H);
     74c:	1f 92       	push	r1
     74e:	4f 93       	push	r20
     750:	bf 92       	push	r11
     752:	af 92       	push	r10
     754:	7f 92       	push	r7
     756:	6f 92       	push	r6
     758:	0e 94 1e 18 	call	0x303c	; 0x303c <sprintf>
					MQTT_publish("H_Monitor",(INT_8U*)H_data,strlen(H_data),0);
     75c:	f3 01       	movw	r30, r6
     75e:	01 90       	ld	r0, Z+
     760:	00 20       	and	r0, r0
     762:	e9 f7       	brne	.-6      	; 0x75e <T_Monitor+0x18e>
     764:	31 97       	sbiw	r30, 0x01	; 1
     766:	af 01       	movw	r20, r30
     768:	46 19       	sub	r20, r6
     76a:	57 09       	sbc	r21, r7
     76c:	20 e0       	ldi	r18, 0x00	; 0
     76e:	b3 01       	movw	r22, r6
     770:	8b e6       	ldi	r24, 0x6B	; 107
     772:	92 e0       	ldi	r25, 0x02	; 2
     774:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <MQTT_publish>
					LCD_DispStrXY(2,5,(INT_8U*)H_data);
     778:	a3 01       	movw	r20, r6
     77a:	65 e0       	ldi	r22, 0x05	; 5
     77c:	82 e0       	ldi	r24, 0x02	; 2
     77e:	fa d2       	rcall	.+1524   	; 0xd74 <LCD_DispStrXY>
					vTaskDelay(700);
     780:	8c eb       	ldi	r24, 0xBC	; 188
     782:	92 e0       	ldi	r25, 0x02	; 2
     784:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
					/* display & publish temperature value */
					sprintf(T_data,"%d",I_Temp);
     788:	80 91 4e 03 	lds	r24, 0x034E	; 0x80034e <I_Temp>
     78c:	1f 92       	push	r1
     78e:	8f 93       	push	r24
     790:	bf 92       	push	r11
     792:	af 92       	push	r10
     794:	9f 92       	push	r9
     796:	8f 92       	push	r8
     798:	0e 94 1e 18 	call	0x303c	; 0x303c <sprintf>
					LCD_DispStrXY(1,6,(INT_8U*)T_data);
     79c:	a4 01       	movw	r20, r8
     79e:	66 e0       	ldi	r22, 0x06	; 6
     7a0:	81 e0       	ldi	r24, 0x01	; 1
					LCD_DispChar(0xDF);
     7a2:	e8 d2       	rcall	.+1488   	; 0xd74 <LCD_DispStrXY>
     7a4:	8f ed       	ldi	r24, 0xDF	; 223
     7a6:	c3 d2       	rcall	.+1414   	; 0xd2e <LCD_DispChar>
					LCD_DispStr((INT_8U*)"C");
     7a8:	85 e7       	ldi	r24, 0x75	; 117
     7aa:	92 e0       	ldi	r25, 0x02	; 2
     7ac:	c2 d2       	rcall	.+1412   	; 0xd32 <LCD_DispStr>
     7ae:	f4 01       	movw	r30, r8
					MQTT_publish("T_Monitor",(INT_8U*)T_data,strlen(T_data),0);
     7b0:	01 90       	ld	r0, Z+
     7b2:	00 20       	and	r0, r0
     7b4:	e9 f7       	brne	.-6      	; 0x7b0 <T_Monitor+0x1e0>
     7b6:	31 97       	sbiw	r30, 0x01	; 1
     7b8:	af 01       	movw	r20, r30
     7ba:	48 19       	sub	r20, r8
     7bc:	59 09       	sbc	r21, r9
     7be:	20 e0       	ldi	r18, 0x00	; 0
     7c0:	b4 01       	movw	r22, r8
     7c2:	84 e1       	ldi	r24, 0x14	; 20
     7c4:	91 e0       	ldi	r25, 0x01	; 1
     7c6:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <MQTT_publish>
     7ca:	0f b6       	in	r0, 0x3f	; 63
     7cc:	f8 94       	cli
     7ce:	de bf       	out	0x3e, r29	; 62
     7d0:	0f be       	out	0x3f, r0	; 63
     7d2:	cd bf       	out	0x3d, r28	; 61
     7d4:	0d c0       	rjmp	.+26     	; 0x7f0 <T_Monitor+0x220>
     7d6:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <system_up>
				}	
				}else
				{
					system_up = 0;
     7da:	20 e0       	ldi	r18, 0x00	; 0
					xSemaphoreGive(bsConnect);
     7dc:	40 e0       	ldi	r20, 0x00	; 0
     7de:	50 e0       	ldi	r21, 0x00	; 0
     7e0:	60 e0       	ldi	r22, 0x00	; 0
     7e2:	70 e0       	ldi	r23, 0x00	; 0
     7e4:	80 91 fe 09 	lds	r24, 0x09FE	; 0x8009fe <bsConnect>
     7e8:	90 91 ff 09 	lds	r25, 0x09FF	; 0x8009ff <bsConnect+0x1>
     7ec:	0e 94 93 10 	call	0x2126	; 0x2126 <xQueueGenericSend>
     7f0:	80 e4       	ldi	r24, 0x40	; 64
				}
			}
		vTaskDelay(8000);	
     7f2:	9f e1       	ldi	r25, 0x1F	; 31
     7f4:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
     7f8:	26 cf       	rjmp	.-436    	; 0x646 <T_Monitor+0x76>

000007fa <T_RespHandle>:
#include "T_RespHandle.h"

static INT_8U recpacket[30];

void T_RespHandle(void* pvData)
{
     7fa:	cf 93       	push	r28
     7fc:	df 93       	push	r29
     7fe:	1f 92       	push	r1
     800:	cd b7       	in	r28, 0x3d	; 61
     802:	de b7       	in	r29, 0x3e	; 62
	INT_8U u8Byte = 0;
     804:	19 82       	std	Y+1, r1	; 0x01
	RecState recState = 0;
	INT_8U  recInd = 0;
	INT_8U  remLen = 0;
     806:	f1 2c       	mov	r15, r1

void T_RespHandle(void* pvData)
{
	INT_8U u8Byte = 0;
	RecState recState = 0;
	INT_8U  recInd = 0;
     808:	00 e0       	ldi	r16, 0x00	; 0
static INT_8U recpacket[30];

void T_RespHandle(void* pvData)
{
	INT_8U u8Byte = 0;
	RecState recState = 0;
     80a:	10 e0       	ldi	r17, 0x00	; 0
					}
				}
					
					break;
					case RS_PackType:
					recpacket[1] = u8Byte;
     80c:	0f 2e       	mov	r0, r31
     80e:	f4 e7       	ldi	r31, 0x74	; 116
     810:	cf 2e       	mov	r12, r31
     812:	f3 e0       	ldi	r31, 0x03	; 3
     814:	df 2e       	mov	r13, r31
     816:	f0 2d       	mov	r31, r0
					remLen = u8Byte;
					recInd = 0;
					recState = RS_Remaining;
     818:	68 94       	set
     81a:	ee 24       	eor	r14, r14
     81c:	e1 f8       	bld	r14, 1
				u8Byte == 0x30||
				u8Byte == 0x40
				)
				{
					recpacket[0] = u8Byte;
					recState = RS_PackType;
     81e:	bb 24       	eor	r11, r11
     820:	b3 94       	inc	r11
     822:	02 c0       	rjmp	.+4      	; 0x828 <T_RespHandle+0x2e>
					recInd = 0;
					recState = RS_Remaining;
					break;
					case RS_Remaining:
					recpacket[recInd + 2] = u8Byte;
					recInd++;
     824:	0f 2d       	mov	r16, r15
					if(recInd == remLen)
					{
						recState = RS_NONE;
     826:	10 e0       	ldi	r17, 0x00	; 0
	RecState recState = 0;
	INT_8U  recInd = 0;
	INT_8U  remLen = 0;
	while(1)
	{
		if(UART_RecieveByte_Unblocked(UART_0,&u8Byte))
     828:	be 01       	movw	r22, r28
     82a:	6f 5f       	subi	r22, 0xFF	; 255
     82c:	7f 4f       	sbci	r23, 0xFF	; 255
     82e:	80 e0       	ldi	r24, 0x00	; 0
     830:	f0 d6       	rcall	.+3552   	; 0x1612 <UART_RecieveByte_Unblocked>
     832:	88 23       	and	r24, r24
     834:	09 f4       	brne	.+2      	; 0x838 <T_RespHandle+0x3e>
     836:	83 c0       	rjmp	.+262    	; 0x93e <T_RespHandle+0x144>
		{
			switch(recState)
     838:	11 30       	cpi	r17, 0x01	; 1
     83a:	b9 f1       	breq	.+110    	; 0x8aa <T_RespHandle+0xb0>
     83c:	18 f0       	brcs	.+6      	; 0x844 <T_RespHandle+0x4a>
     83e:	12 30       	cpi	r17, 0x02	; 2
     840:	d1 f1       	breq	.+116    	; 0x8b6 <T_RespHandle+0xbc>
     842:	f2 cf       	rjmp	.-28     	; 0x828 <T_RespHandle+0x2e>
			{
				case RS_NONE:
				if(Wifi_Connecting == TRUE && u8Byte == 0x3A)
     844:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
     848:	81 30       	cpi	r24, 0x01	; 1
     84a:	e9 f4       	brne	.+58     	; 0x886 <T_RespHandle+0x8c>
     84c:	89 81       	ldd	r24, Y+1	; 0x01
     84e:	8a 33       	cpi	r24, 0x3A	; 58
     850:	59 f7       	brne	.-42     	; 0x828 <T_RespHandle+0x2e>
				{
					u8Byte = UART_Receive(UART_0);
     852:	80 e0       	ldi	r24, 0x00	; 0
     854:	b9 d6       	rcall	.+3442   	; 0x15c8 <UART_Receive>
     856:	89 83       	std	Y+1, r24	; 0x01
					if (u8Byte == 0xD0)
     858:	80 3d       	cpi	r24, 0xD0	; 208
     85a:	41 f4       	brne	.+16     	; 0x86c <T_RespHandle+0x72>
					{
						xEventGroupSetBits(egMQTT,E_MQTT_PINGREQ);
     85c:	60 e1       	ldi	r22, 0x10	; 16
     85e:	70 e0       	ldi	r23, 0x00	; 0
     860:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <egMQTT>
     864:	90 91 fb 09 	lds	r25, 0x09FB	; 0x8009fb <egMQTT+0x1>
     868:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <xEventGroupSetBits>
					}
				if(u8Byte == 0x90||
     86c:	89 81       	ldd	r24, Y+1	; 0x01
     86e:	80 39       	cpi	r24, 0x90	; 144
     870:	31 f0       	breq	.+12     	; 0x87e <T_RespHandle+0x84>
     872:	98 2f       	mov	r25, r24
     874:	9f 7e       	andi	r25, 0xEF	; 239
     876:	90 32       	cpi	r25, 0x20	; 32
     878:	11 f0       	breq	.+4      	; 0x87e <T_RespHandle+0x84>
				u8Byte == 0x20||
				u8Byte == 0x30||
     87a:	80 34       	cpi	r24, 0x40	; 64
     87c:	a9 f6       	brne	.-86     	; 0x828 <T_RespHandle+0x2e>
				u8Byte == 0x40
				)
				{
					recpacket[0] = u8Byte;
     87e:	f6 01       	movw	r30, r12
     880:	80 83       	st	Z, r24
					recState = RS_PackType;
     882:	1b 2d       	mov	r17, r11
     884:	d1 cf       	rjmp	.-94     	; 0x828 <T_RespHandle+0x2e>
					
				}
				}else if (Wifi_Connecting == FALSE)
     886:	81 11       	cpse	r24, r1
     888:	cf cf       	rjmp	.-98     	; 0x828 <T_RespHandle+0x2e>
				{
					if(u8Byte == 'O')
     88a:	89 81       	ldd	r24, Y+1	; 0x01
     88c:	8f 34       	cpi	r24, 0x4F	; 79
					{
						if(UART_Receive(UART_0)=='K')
     88e:	61 f6       	brne	.-104    	; 0x828 <T_RespHandle+0x2e>
     890:	80 e0       	ldi	r24, 0x00	; 0
     892:	9a d6       	rcall	.+3380   	; 0x15c8 <UART_Receive>
     894:	8b 34       	cpi	r24, 0x4B	; 75
     896:	41 f6       	brne	.-112    	; 0x828 <T_RespHandle+0x2e>
						{
							xEventGroupSetBits(egMQTT,WiFi_ACK);
     898:	68 e0       	ldi	r22, 0x08	; 8
     89a:	70 e0       	ldi	r23, 0x00	; 0
     89c:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <egMQTT>
     8a0:	90 91 fb 09 	lds	r25, 0x09FB	; 0x8009fb <egMQTT+0x1>
     8a4:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <xEventGroupSetBits>
     8a8:	bf cf       	rjmp	.-130    	; 0x828 <T_RespHandle+0x2e>
					}
				}
					
					break;
					case RS_PackType:
					recpacket[1] = u8Byte;
     8aa:	f9 80       	ldd	r15, Y+1	; 0x01
     8ac:	f6 01       	movw	r30, r12
     8ae:	f1 82       	std	Z+1, r15	; 0x01
					remLen = u8Byte;
					recInd = 0;
     8b0:	00 e0       	ldi	r16, 0x00	; 0
					recState = RS_Remaining;
     8b2:	1e 2d       	mov	r17, r14
					break;
     8b4:	b9 cf       	rjmp	.-142    	; 0x828 <T_RespHandle+0x2e>
					case RS_Remaining:
					recpacket[recInd + 2] = u8Byte;
     8b6:	e0 2f       	mov	r30, r16
     8b8:	f0 e0       	ldi	r31, 0x00	; 0
     8ba:	ec 58       	subi	r30, 0x8C	; 140
     8bc:	fc 4f       	sbci	r31, 0xFC	; 252
     8be:	89 81       	ldd	r24, Y+1	; 0x01
     8c0:	82 83       	std	Z+2, r24	; 0x02
					recInd++;
     8c2:	0f 5f       	subi	r16, 0xFF	; 255
					if(recInd == remLen)
     8c4:	f0 12       	cpse	r15, r16
     8c6:	b0 cf       	rjmp	.-160    	; 0x828 <T_RespHandle+0x2e>
					{
						recState = RS_NONE;
						switch(recpacket[0])
     8c8:	f6 01       	movw	r30, r12
     8ca:	80 81       	ld	r24, Z
     8cc:	80 33       	cpi	r24, 0x30	; 48
     8ce:	49 f0       	breq	.+18     	; 0x8e2 <T_RespHandle+0xe8>
     8d0:	18 f4       	brcc	.+6      	; 0x8d8 <T_RespHandle+0xde>
     8d2:	80 32       	cpi	r24, 0x20	; 32
     8d4:	99 f0       	breq	.+38     	; 0x8fc <T_RespHandle+0x102>
     8d6:	a6 cf       	rjmp	.-180    	; 0x824 <T_RespHandle+0x2a>
     8d8:	80 34       	cpi	r24, 0x40	; 64
     8da:	d9 f0       	breq	.+54     	; 0x912 <T_RespHandle+0x118>
     8dc:	80 39       	cpi	r24, 0x90	; 144
     8de:	21 f1       	breq	.+72     	; 0x928 <T_RespHandle+0x12e>
     8e0:	a1 cf       	rjmp	.-190    	; 0x824 <T_RespHandle+0x2a>
						{
							case 0x30:
							xQueueSend(mqControl,recpacket,0);
     8e2:	20 e0       	ldi	r18, 0x00	; 0
     8e4:	40 e0       	ldi	r20, 0x00	; 0
     8e6:	50 e0       	ldi	r21, 0x00	; 0
     8e8:	b6 01       	movw	r22, r12
     8ea:	80 91 f8 09 	lds	r24, 0x09F8	; 0x8009f8 <mqControl>
     8ee:	90 91 f9 09 	lds	r25, 0x09F9	; 0x8009f9 <mqControl+0x1>
     8f2:	0e 94 93 10 	call	0x2126	; 0x2126 <xQueueGenericSend>
					recInd = 0;
					recState = RS_Remaining;
					break;
					case RS_Remaining:
					recpacket[recInd + 2] = u8Byte;
					recInd++;
     8f6:	0f 2d       	mov	r16, r15
					if(recInd == remLen)
					{
						recState = RS_NONE;
     8f8:	10 e0       	ldi	r17, 0x00	; 0
						switch(recpacket[0])
						{
							case 0x30:
							xQueueSend(mqControl,recpacket,0);
							break;
     8fa:	96 cf       	rjmp	.-212    	; 0x828 <T_RespHandle+0x2e>
							case 0x20:
							xEventGroupSetBits(egMQTT,E_MQTT_CONNACK);
     8fc:	64 e0       	ldi	r22, 0x04	; 4
     8fe:	70 e0       	ldi	r23, 0x00	; 0
     900:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <egMQTT>
     904:	90 91 fb 09 	lds	r25, 0x09FB	; 0x8009fb <egMQTT+0x1>
     908:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <xEventGroupSetBits>
					recInd = 0;
					recState = RS_Remaining;
					break;
					case RS_Remaining:
					recpacket[recInd + 2] = u8Byte;
					recInd++;
     90c:	0f 2d       	mov	r16, r15
					if(recInd == remLen)
					{
						recState = RS_NONE;
     90e:	10 e0       	ldi	r17, 0x00	; 0
							case 0x30:
							xQueueSend(mqControl,recpacket,0);
							break;
							case 0x20:
							xEventGroupSetBits(egMQTT,E_MQTT_CONNACK);
							break;
     910:	8b cf       	rjmp	.-234    	; 0x828 <T_RespHandle+0x2e>
							case 0x40:
							xEventGroupSetBits(egMQTT,E_MQTT_PUBACK);
     912:	61 e0       	ldi	r22, 0x01	; 1
     914:	70 e0       	ldi	r23, 0x00	; 0
     916:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <egMQTT>
     91a:	90 91 fb 09 	lds	r25, 0x09FB	; 0x8009fb <egMQTT+0x1>
     91e:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <xEventGroupSetBits>
					recInd = 0;
					recState = RS_Remaining;
					break;
					case RS_Remaining:
					recpacket[recInd + 2] = u8Byte;
					recInd++;
     922:	0f 2d       	mov	r16, r15
					if(recInd == remLen)
					{
						recState = RS_NONE;
     924:	10 e0       	ldi	r17, 0x00	; 0
							case 0x20:
							xEventGroupSetBits(egMQTT,E_MQTT_CONNACK);
							break;
							case 0x40:
							xEventGroupSetBits(egMQTT,E_MQTT_PUBACK);
							break;
     926:	80 cf       	rjmp	.-256    	; 0x828 <T_RespHandle+0x2e>
							case 0x90:
							xEventGroupSetBits(egMQTT,E_MQTT_SUBACK);
     928:	62 e0       	ldi	r22, 0x02	; 2
     92a:	70 e0       	ldi	r23, 0x00	; 0
     92c:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <egMQTT>
     930:	90 91 fb 09 	lds	r25, 0x09FB	; 0x8009fb <egMQTT+0x1>
     934:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <xEventGroupSetBits>
					recInd = 0;
					recState = RS_Remaining;
					break;
					case RS_Remaining:
					recpacket[recInd + 2] = u8Byte;
					recInd++;
     938:	0f 2d       	mov	r16, r15
					if(recInd == remLen)
					{
						recState = RS_NONE;
     93a:	10 e0       	ldi	r17, 0x00	; 0
							case 0x40:
							xEventGroupSetBits(egMQTT,E_MQTT_PUBACK);
							break;
							case 0x90:
							xEventGroupSetBits(egMQTT,E_MQTT_SUBACK);
							break;
     93c:	75 cf       	rjmp	.-278    	; 0x828 <T_RespHandle+0x2e>
						
					}
					break;
				}
			}
			else vTaskDelay(2);
     93e:	82 e0       	ldi	r24, 0x02	; 2
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
     946:	70 cf       	rjmp	.-288    	; 0x828 <T_RespHandle+0x2e>

00000948 <T_Self_Control>:
#include "T_Self_Control.h"

void T_Self_Control(void* pvData)
{
	INT_8U X =0 ,y =0  ;
	INT_8U z1=0,z2=0,z3=0,z4=0,z5=0 ;
     948:	b1 2c       	mov	r11, r1
     94a:	c1 2c       	mov	r12, r1
     94c:	e1 2c       	mov	r14, r1
     94e:	f1 2c       	mov	r15, r1
     950:	00 e0       	ldi	r16, 0x00	; 0

#include "T_Self_Control.h"

void T_Self_Control(void* pvData)
{
	INT_8U X =0 ,y =0  ;
     952:	10 e0       	ldi	r17, 0x00	; 0
     954:	d0 e0       	ldi	r29, 0x00	; 0
					}
					z1=0;
					z2=0;
					z3=0;
					z4=0;
					z5=1;
     956:	dd 24       	eor	r13, r13
     958:	d3 94       	inc	r13
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=0;
					z4=0;
     95a:	c0 e0       	ldi	r28, 0x00	; 0
	INT_8U X =0 ,y =0  ;
	INT_8U z1=0,z2=0,z3=0,z4=0,z5=0 ;
	
	while (1)
	{
		if (SELF_CONTROL == 1)
     95c:	80 91 6f 03 	lds	r24, 0x036F	; 0x80036f <SELF_CONTROL>
     960:	81 30       	cpi	r24, 0x01	; 1
     962:	09 f0       	breq	.+2      	; 0x966 <T_Self_Control+0x1e>
     964:	e8 c0       	rjmp	.+464    	; 0xb36 <T_Self_Control+0x1ee>
		{
			if (Soil_data>=0 && Soil_data<=40 && X==0)
     966:	80 91 70 03 	lds	r24, 0x0370	; 0x800370 <Soil_data>
     96a:	90 91 71 03 	lds	r25, 0x0371	; 0x800371 <Soil_data+0x1>
     96e:	89 32       	cpi	r24, 0x29	; 41
     970:	91 05       	cpc	r25, r1
     972:	68 f4       	brcc	.+26     	; 0x98e <T_Self_Control+0x46>
     974:	d1 11       	cpse	r29, r1
     976:	0b c0       	rjmp	.+22     	; 0x98e <T_Self_Control+0x46>
			{
				X=1 ;
				Water_Pump_ON();
     978:	4c d2       	rcall	.+1176   	; 0xe12 <Water_Pump_ON>
				if(system_up == 1)
     97a:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
     97e:	81 30       	cpi	r24, 0x01	; 1
     980:	b1 f4       	brne	.+44     	; 0x9ae <T_Self_Control+0x66>
				{
					//MQTT_publish("SGH_PUMP","ON",2,0);
					vTaskDelay(500);
     982:	84 ef       	ldi	r24, 0xF4	; 244
     984:	91 e0       	ldi	r25, 0x01	; 1
     986:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
	{
		if (SELF_CONTROL == 1)
		{
			if (Soil_data>=0 && Soil_data<=40 && X==0)
			{
				X=1 ;
     98a:	dd 2d       	mov	r29, r13
     98c:	13 c0       	rjmp	.+38     	; 0x9b4 <T_Self_Control+0x6c>
				{
					//MQTT_publish("SGH_PUMP","ON",2,0);
					vTaskDelay(500);
				}		
			}
			else if (Soil_data>40 && Soil_data<=100 && X==1)
     98e:	89 97       	sbiw	r24, 0x29	; 41
     990:	cc 97       	sbiw	r24, 0x3c	; 60
     992:	80 f4       	brcc	.+32     	; 0x9b4 <T_Self_Control+0x6c>
     994:	d1 30       	cpi	r29, 0x01	; 1
			{
				X=0;
				Water_Pump_OFF();
     996:	71 f4       	brne	.+28     	; 0x9b4 <T_Self_Control+0x6c>
     998:	3e d2       	rcall	.+1148   	; 0xe16 <Water_Pump_OFF>
				if(system_up == 1)
     99a:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
     99e:	81 30       	cpi	r24, 0x01	; 1
     9a0:	41 f4       	brne	.+16     	; 0x9b2 <T_Self_Control+0x6a>
				{
					//MQTT_publish("SGH_PUMP","OFF",3,0);
					vTaskDelay(500);
     9a2:	84 ef       	ldi	r24, 0xF4	; 244
     9a4:	91 e0       	ldi	r25, 0x01	; 1
     9a6:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
					vTaskDelay(500);
				}		
			}
			else if (Soil_data>40 && Soil_data<=100 && X==1)
			{
				X=0;
     9aa:	dc 2f       	mov	r29, r28
     9ac:	03 c0       	rjmp	.+6      	; 0x9b4 <T_Self_Control+0x6c>
	{
		if (SELF_CONTROL == 1)
		{
			if (Soil_data>=0 && Soil_data<=40 && X==0)
			{
				X=1 ;
     9ae:	dd 2d       	mov	r29, r13
     9b0:	01 c0       	rjmp	.+2      	; 0x9b4 <T_Self_Control+0x6c>
					vTaskDelay(500);
				}		
			}
			else if (Soil_data>40 && Soil_data<=100 && X==1)
			{
				X=0;
     9b2:	dc 2f       	mov	r29, r28
					//MQTT_publish("SGH_PUMP","OFF",3,0);
					vTaskDelay(500);
				}
			}
			else{}
			if (I_Temp>35 && I_Temp<60 && y==0)
     9b4:	80 91 4e 03 	lds	r24, 0x034E	; 0x80034e <I_Temp>
     9b8:	9c ed       	ldi	r25, 0xDC	; 220
     9ba:	98 0f       	add	r25, r24
     9bc:	98 31       	cpi	r25, 0x18	; 24
     9be:	68 f4       	brcc	.+26     	; 0x9da <T_Self_Control+0x92>
     9c0:	11 11       	cpse	r17, r1
			{
				Fan_On();
     9c2:	0b c0       	rjmp	.+22     	; 0x9da <T_Self_Control+0x92>
     9c4:	02 d1       	rcall	.+516    	; 0xbca <Fan_On>
				if(system_up == 1)
     9c6:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
     9ca:	81 30       	cpi	r24, 0x01	; 1
     9cc:	b1 f4       	brne	.+44     	; 0x9fa <T_Self_Control+0xb2>
				{
					//MQTT_publish("SGH_FAN","ON",2,0);
					vTaskDelay(500);
     9ce:	84 ef       	ldi	r24, 0xF4	; 244
     9d0:	91 e0       	ldi	r25, 0x01	; 1
     9d2:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
				}
				y=1 ;
     9d6:	1d 2d       	mov	r17, r13
     9d8:	13 c0       	rjmp	.+38     	; 0xa00 <T_Self_Control+0xb8>
			}
			else if (I_Temp>0 && I_Temp<35 && y==1)
     9da:	81 50       	subi	r24, 0x01	; 1
     9dc:	82 32       	cpi	r24, 0x22	; 34
     9de:	80 f4       	brcc	.+32     	; 0xa00 <T_Self_Control+0xb8>
     9e0:	11 30       	cpi	r17, 0x01	; 1
			{
				Fan_Off();
     9e2:	71 f4       	brne	.+28     	; 0xa00 <T_Self_Control+0xb8>
     9e4:	f8 d0       	rcall	.+496    	; 0xbd6 <Fan_Off>
				if (system_up == 1)
     9e6:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
     9ea:	81 30       	cpi	r24, 0x01	; 1
     9ec:	41 f4       	brne	.+16     	; 0x9fe <T_Self_Control+0xb6>
				{
					//MQTT_publish("SGH_FAN","OFF",3,0);
					vTaskDelay(500);
     9ee:	84 ef       	ldi	r24, 0xF4	; 244
     9f0:	91 e0       	ldi	r25, 0x01	; 1
     9f2:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
				}
				y=0;
     9f6:	1c 2f       	mov	r17, r28
     9f8:	03 c0       	rjmp	.+6      	; 0xa00 <T_Self_Control+0xb8>
				if(system_up == 1)
				{
					//MQTT_publish("SGH_FAN","ON",2,0);
					vTaskDelay(500);
				}
				y=1 ;
     9fa:	1d 2d       	mov	r17, r13
     9fc:	01 c0       	rjmp	.+2      	; 0xa00 <T_Self_Control+0xb8>
				if (system_up == 1)
				{
					//MQTT_publish("SGH_FAN","OFF",3,0);
					vTaskDelay(500);
				}
				y=0;
     9fe:	1c 2f       	mov	r17, r28
			}
			else{}
				if (light>80 && light<=100 &&  z1 == 0 )
     a00:	80 91 72 03 	lds	r24, 0x0372	; 0x800372 <light>
     a04:	90 91 73 03 	lds	r25, 0x0373	; 0x800373 <light+0x1>
     a08:	9c 01       	movw	r18, r24
     a0a:	21 55       	subi	r18, 0x51	; 81
     a0c:	31 09       	sbc	r19, r1
     a0e:	24 31       	cpi	r18, 0x14	; 20
     a10:	31 05       	cpc	r19, r1
     a12:	a0 f4       	brcc	.+40     	; 0xa3c <T_Self_Control+0xf4>
     a14:	01 11       	cpse	r16, r1
     a16:	12 c0       	rjmp	.+36     	; 0xa3c <T_Self_Control+0xf4>
				{
					//Dim_LED_Stop();
					if (system_up == 1)
     a18:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
     a1c:	81 30       	cpi	r24, 0x01	; 1
     a1e:	09 f0       	breq	.+2      	; 0xa22 <T_Self_Control+0xda>
					{
						Dim_LED_Brightness(100);
     a20:	6d c0       	rjmp	.+218    	; 0xafc <T_Self_Control+0x1b4>
     a22:	84 e6       	ldi	r24, 0x64	; 100
     a24:	90 e0       	ldi	r25, 0x00	; 0
     a26:	e4 d0       	rcall	.+456    	; 0xbf0 <Dim_LED_Brightness>
						//MQTT_publish("SGH_LIGHT","OFF",3,0);
						vTaskDelay(500);
     a28:	84 ef       	ldi	r24, 0xF4	; 244
     a2a:	91 e0       	ldi	r25, 0x01	; 1
     a2c:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
					}
					z1=1;
					z2=0;
					z3=0;
					z4=0;
					z5=0;
     a30:	bc 2e       	mov	r11, r28
						vTaskDelay(500);
					}
					z1=1;
					z2=0;
					z3=0;
					z4=0;
     a32:	cc 2e       	mov	r12, r28
						//MQTT_publish("SGH_LIGHT","OFF",3,0);
						vTaskDelay(500);
					}
					z1=1;
					z2=0;
					z3=0;
     a34:	ec 2e       	mov	r14, r28
						Dim_LED_Brightness(100);
						//MQTT_publish("SGH_LIGHT","OFF",3,0);
						vTaskDelay(500);
					}
					z1=1;
					z2=0;
     a36:	fc 2e       	mov	r15, r28
					{
						Dim_LED_Brightness(100);
						//MQTT_publish("SGH_LIGHT","OFF",3,0);
						vTaskDelay(500);
					}
					z1=1;
     a38:	0d 2d       	mov	r16, r13
     a3a:	7d c0       	rjmp	.+250    	; 0xb36 <T_Self_Control+0x1ee>
					z2=0;
					z3=0;
					z4=0;
					z5=0;
				}
				else if (light>=60 && light<=80 && z2 == 0)
     a3c:	9c 01       	movw	r18, r24
     a3e:	2c 53       	subi	r18, 0x3C	; 60
     a40:	31 09       	sbc	r19, r1
     a42:	25 31       	cpi	r18, 0x15	; 21
     a44:	31 05       	cpc	r19, r1
     a46:	a0 f4       	brcc	.+40     	; 0xa70 <T_Self_Control+0x128>
     a48:	f1 10       	cpse	r15, r1
				{
					Dim_LED_Brightness(75);
     a4a:	12 c0       	rjmp	.+36     	; 0xa70 <T_Self_Control+0x128>
     a4c:	8b e4       	ldi	r24, 0x4B	; 75
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	cf d0       	rcall	.+414    	; 0xbf0 <Dim_LED_Brightness>
					if (system_up == 1)
     a52:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
     a56:	81 30       	cpi	r24, 0x01	; 1
     a58:	09 f0       	breq	.+2      	; 0xa5c <T_Self_Control+0x114>
     a5a:	56 c0       	rjmp	.+172    	; 0xb08 <T_Self_Control+0x1c0>
					{
						//MQTT_publish("SGH_LIGHT","25%",3,0);
						vTaskDelay(500);
     a5c:	84 ef       	ldi	r24, 0xF4	; 244
     a5e:	91 e0       	ldi	r25, 0x01	; 1
     a60:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
					}
					z1=0;
					z2=1;
					z3=0;
					z4=0;
					z5=0;	
     a64:	bc 2e       	mov	r11, r28
						vTaskDelay(500);
					}
					z1=0;
					z2=1;
					z3=0;
					z4=0;
     a66:	cc 2e       	mov	r12, r28
						//MQTT_publish("SGH_LIGHT","25%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=1;
					z3=0;
     a68:	ec 2e       	mov	r14, r28
					{
						//MQTT_publish("SGH_LIGHT","25%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=1;
     a6a:	fd 2c       	mov	r15, r13
					if (system_up == 1)
					{
						//MQTT_publish("SGH_LIGHT","25%",3,0);
						vTaskDelay(500);
					}
					z1=0;
     a6c:	0c 2f       	mov	r16, r28
     a6e:	63 c0       	rjmp	.+198    	; 0xb36 <T_Self_Control+0x1ee>
					z2=1;
					z3=0;
					z4=0;
					z5=0;	
				}
				else if (light>=40 && light<60 && z3 == 0 )
     a70:	9c 01       	movw	r18, r24
     a72:	28 52       	subi	r18, 0x28	; 40
     a74:	31 09       	sbc	r19, r1
     a76:	24 31       	cpi	r18, 0x14	; 20
     a78:	31 05       	cpc	r19, r1
     a7a:	a0 f4       	brcc	.+40     	; 0xaa4 <T_Self_Control+0x15c>
     a7c:	e1 10       	cpse	r14, r1
				{
					Dim_LED_Brightness(50);
     a7e:	12 c0       	rjmp	.+36     	; 0xaa4 <T_Self_Control+0x15c>
     a80:	82 e3       	ldi	r24, 0x32	; 50
     a82:	90 e0       	ldi	r25, 0x00	; 0
     a84:	b5 d0       	rcall	.+362    	; 0xbf0 <Dim_LED_Brightness>
					if (system_up == 1)
     a86:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
     a8a:	81 30       	cpi	r24, 0x01	; 1
     a8c:	09 f0       	breq	.+2      	; 0xa90 <T_Self_Control+0x148>
     a8e:	42 c0       	rjmp	.+132    	; 0xb14 <T_Self_Control+0x1cc>
					{
						//MQTT_publish("SGH_LIGHT","50%",3,0);
						vTaskDelay(500);
     a90:	84 ef       	ldi	r24, 0xF4	; 244
     a92:	91 e0       	ldi	r25, 0x01	; 1
     a94:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
					}
					z1=0;
					z2=0;
					z3=1;
					z4=0;
					z5=0;	
     a98:	bc 2e       	mov	r11, r28
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=1;
					z4=0;
     a9a:	cc 2e       	mov	r12, r28
						//MQTT_publish("SGH_LIGHT","50%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=1;
     a9c:	ed 2c       	mov	r14, r13
					{
						//MQTT_publish("SGH_LIGHT","50%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
     a9e:	fc 2e       	mov	r15, r28
					if (system_up == 1)
					{
						//MQTT_publish("SGH_LIGHT","50%",3,0);
						vTaskDelay(500);
					}
					z1=0;
     aa0:	0c 2f       	mov	r16, r28
     aa2:	49 c0       	rjmp	.+146    	; 0xb36 <T_Self_Control+0x1ee>
					z2=0;
					z3=1;
					z4=0;
					z5=0;	
				}
				else if (light>=20 && light<40 && z4 == 0 )
     aa4:	9c 01       	movw	r18, r24
     aa6:	24 51       	subi	r18, 0x14	; 20
     aa8:	31 09       	sbc	r19, r1
     aaa:	24 31       	cpi	r18, 0x14	; 20
     aac:	31 05       	cpc	r19, r1
     aae:	98 f4       	brcc	.+38     	; 0xad6 <T_Self_Control+0x18e>
     ab0:	c1 10       	cpse	r12, r1
				{
					Dim_LED_Brightness(25);
     ab2:	11 c0       	rjmp	.+34     	; 0xad6 <T_Self_Control+0x18e>
     ab4:	89 e1       	ldi	r24, 0x19	; 25
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	9b d0       	rcall	.+310    	; 0xbf0 <Dim_LED_Brightness>
					
					if (system_up == 1)
     aba:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
     abe:	81 30       	cpi	r24, 0x01	; 1
     ac0:	79 f5       	brne	.+94     	; 0xb20 <T_Self_Control+0x1d8>
					{		
						//MQTT_publish("SGH_LIGHT","75%",3,0);
						vTaskDelay(500);
     ac2:	84 ef       	ldi	r24, 0xF4	; 244
     ac4:	91 e0       	ldi	r25, 0x01	; 1
     ac6:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
					}
					z1=0;
					z2=0;
					z3=0;
					z4=1;
					z5=0;	
     aca:	bc 2e       	mov	r11, r28
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=0;
					z4=1;
     acc:	cd 2c       	mov	r12, r13
					{		
						//MQTT_publish("SGH_LIGHT","75%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
     ace:	ec 2e       	mov	r14, r28
					if (system_up == 1)
					{		
						//MQTT_publish("SGH_LIGHT","75%",3,0);
						vTaskDelay(500);
					}
					z1=0;
     ad0:	fc 2e       	mov	r15, r28
     ad2:	0c 2f       	mov	r16, r28
					z2=0;
					z3=0;
					z4=1;
					z5=0;	
				}
				else if (light>=0 && light<20 && z5==0 )
     ad4:	30 c0       	rjmp	.+96     	; 0xb36 <T_Self_Control+0x1ee>
     ad6:	44 97       	sbiw	r24, 0x14	; 20
     ad8:	70 f5       	brcc	.+92     	; 0xb36 <T_Self_Control+0x1ee>
     ada:	b1 10       	cpse	r11, r1
				{
					Dim_LED_Stop();
     adc:	2c c0       	rjmp	.+88     	; 0xb36 <T_Self_Control+0x1ee>
     ade:	95 d0       	rcall	.+298    	; 0xc0a <Dim_LED_Stop>
					
					if (system_up == 1)
     ae0:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <system_up>
     ae4:	81 30       	cpi	r24, 0x01	; 1
     ae6:	11 f5       	brne	.+68     	; 0xb2c <T_Self_Control+0x1e4>
					{
						//MQTT_publish("SGH_LIGHT","100%",4,0);
						vTaskDelay(500);
     ae8:	84 ef       	ldi	r24, 0xF4	; 244
     aea:	91 e0       	ldi	r25, 0x01	; 1
     aec:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
					}
					z1=0;
					z2=0;
					z3=0;
					z4=0;
					z5=1;
     af0:	bd 2c       	mov	r11, r13
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=0;
					z4=0;
     af2:	cc 2e       	mov	r12, r28
						//MQTT_publish("SGH_LIGHT","100%",4,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=0;
     af4:	ec 2e       	mov	r14, r28
					{
						//MQTT_publish("SGH_LIGHT","100%",4,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
     af6:	fc 2e       	mov	r15, r28
					if (system_up == 1)
					{
						//MQTT_publish("SGH_LIGHT","100%",4,0);
						vTaskDelay(500);
					}
					z1=0;
     af8:	0c 2f       	mov	r16, r28
     afa:	1d c0       	rjmp	.+58     	; 0xb36 <T_Self_Control+0x1ee>
					}
					z1=1;
					z2=0;
					z3=0;
					z4=0;
					z5=0;
     afc:	bc 2e       	mov	r11, r28
						vTaskDelay(500);
					}
					z1=1;
					z2=0;
					z3=0;
					z4=0;
     afe:	cc 2e       	mov	r12, r28
						//MQTT_publish("SGH_LIGHT","OFF",3,0);
						vTaskDelay(500);
					}
					z1=1;
					z2=0;
					z3=0;
     b00:	ec 2e       	mov	r14, r28
						Dim_LED_Brightness(100);
						//MQTT_publish("SGH_LIGHT","OFF",3,0);
						vTaskDelay(500);
					}
					z1=1;
					z2=0;
     b02:	fc 2e       	mov	r15, r28
					{
						Dim_LED_Brightness(100);
						//MQTT_publish("SGH_LIGHT","OFF",3,0);
						vTaskDelay(500);
					}
					z1=1;
     b04:	0d 2d       	mov	r16, r13
     b06:	17 c0       	rjmp	.+46     	; 0xb36 <T_Self_Control+0x1ee>
					}
					z1=0;
					z2=1;
					z3=0;
					z4=0;
					z5=0;	
     b08:	bc 2e       	mov	r11, r28
						vTaskDelay(500);
					}
					z1=0;
					z2=1;
					z3=0;
					z4=0;
     b0a:	cc 2e       	mov	r12, r28
						//MQTT_publish("SGH_LIGHT","25%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=1;
					z3=0;
     b0c:	ec 2e       	mov	r14, r28
					{
						//MQTT_publish("SGH_LIGHT","25%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=1;
     b0e:	fd 2c       	mov	r15, r13
					if (system_up == 1)
					{
						//MQTT_publish("SGH_LIGHT","25%",3,0);
						vTaskDelay(500);
					}
					z1=0;
     b10:	0c 2f       	mov	r16, r28
     b12:	11 c0       	rjmp	.+34     	; 0xb36 <T_Self_Control+0x1ee>
					}
					z1=0;
					z2=0;
					z3=1;
					z4=0;
					z5=0;	
     b14:	bc 2e       	mov	r11, r28
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=1;
					z4=0;
     b16:	cc 2e       	mov	r12, r28
						//MQTT_publish("SGH_LIGHT","50%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=1;
     b18:	ed 2c       	mov	r14, r13
					{
						//MQTT_publish("SGH_LIGHT","50%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
     b1a:	fc 2e       	mov	r15, r28
					if (system_up == 1)
					{
						//MQTT_publish("SGH_LIGHT","50%",3,0);
						vTaskDelay(500);
					}
					z1=0;
     b1c:	0c 2f       	mov	r16, r28
     b1e:	0b c0       	rjmp	.+22     	; 0xb36 <T_Self_Control+0x1ee>
					}
					z1=0;
					z2=0;
					z3=0;
					z4=1;
					z5=0;	
     b20:	bc 2e       	mov	r11, r28
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=0;
					z4=1;
     b22:	cd 2c       	mov	r12, r13
						//MQTT_publish("SGH_LIGHT","75%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=0;
     b24:	ec 2e       	mov	r14, r28
					{		
						//MQTT_publish("SGH_LIGHT","75%",3,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
     b26:	fc 2e       	mov	r15, r28
					if (system_up == 1)
					{		
						//MQTT_publish("SGH_LIGHT","75%",3,0);
						vTaskDelay(500);
					}
					z1=0;
     b28:	0c 2f       	mov	r16, r28
     b2a:	05 c0       	rjmp	.+10     	; 0xb36 <T_Self_Control+0x1ee>
					}
					z1=0;
					z2=0;
					z3=0;
					z4=0;
					z5=1;
     b2c:	bd 2c       	mov	r11, r13
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=0;
					z4=0;
     b2e:	cc 2e       	mov	r12, r28
						//MQTT_publish("SGH_LIGHT","100%",4,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
					z3=0;
     b30:	ec 2e       	mov	r14, r28
					{
						//MQTT_publish("SGH_LIGHT","100%",4,0);
						vTaskDelay(500);
					}
					z1=0;
					z2=0;
     b32:	fc 2e       	mov	r15, r28
					if (system_up == 1)
					{
						//MQTT_publish("SGH_LIGHT","100%",4,0);
						vTaskDelay(500);
					}
					z1=0;
     b34:	0c 2f       	mov	r16, r28
					z4=0;
					z5=1;
				}
				else{}	
		}
		vTaskDelay(5000);
     b36:	88 e8       	ldi	r24, 0x88	; 136
     b38:	93 e1       	ldi	r25, 0x13	; 19
     b3a:	0e 94 7f 14 	call	0x28fe	; 0x28fe <vTaskDelay>
	}	
     b3e:	0e cf       	rjmp	.-484    	; 0x95c <T_Self_Control+0x14>

00000b40 <Start_Signal>:
INT_8U data_byte	=	0;

void Start_Signal()
{
		/*Set as O/P */
	SETBIT(DHT11_DDR,DHT11_Data);
     b40:	12 9a       	sbi	0x02, 2	; 2
		/* Free status HIGH */
	SETBIT(DHT11_PORT,DHT11_Data);
     b42:	1a 9a       	sbi	0x03, 2	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b44:	8f ec       	ldi	r24, 0xCF	; 207
     b46:	97 e0       	ldi	r25, 0x07	; 7
     b48:	01 97       	sbiw	r24, 0x01	; 1
     b4a:	f1 f7       	brne	.-4      	; 0xb48 <Start_Signal+0x8>
     b4c:	00 c0       	rjmp	.+0      	; 0xb4e <Start_Signal+0xe>
     b4e:	00 00       	nop
	_delay_ms(1);
	/*Start Start Signal*/
	CLEARBIT(DHT11_PORT,DHT11_Data);
     b50:	1a 98       	cbi	0x03, 2	; 3
     b52:	8f e3       	ldi	r24, 0x3F	; 63
     b54:	9c e9       	ldi	r25, 0x9C	; 156
     b56:	01 97       	sbiw	r24, 0x01	; 1
     b58:	f1 f7       	brne	.-4      	; 0xb56 <Start_Signal+0x16>
     b5a:	00 c0       	rjmp	.+0      	; 0xb5c <Start_Signal+0x1c>
     b5c:	00 00       	nop
	_delay_ms(20);
	SETBIT(DHT11_PORT,DHT11_Data);
     b5e:	1a 9a       	sbi	0x03, 2	; 3
     b60:	08 95       	ret

00000b62 <Response_Signal>:
}

void Response_Signal()
{
		/*Set as I/P */
	CLEARBIT(DHT11_DDR,DHT11_Data);
     b62:	12 98       	cbi	0x02, 2	; 2
	while(	readbit(DHT11_PIN,DHT11_Data)); 
     b64:	0a 99       	sbic	0x01, 2	; 1
     b66:	fe cf       	rjmp	.-4      	; 0xb64 <Response_Signal+0x2>
	/* Wait for DHT LOW response signal*/
	while(! readbit(DHT11_PIN,DHT11_Data));	
     b68:	0a 9b       	sbis	0x01, 2	; 1
     b6a:	fe cf       	rjmp	.-4      	; 0xb68 <Response_Signal+0x6>
	/* Wait for DHT HIGH response signal*/
	while(  readbit(DHT11_PIN,DHT11_Data));  
     b6c:	0a 99       	sbic	0x01, 2	; 1
     b6e:	fe cf       	rjmp	.-4      	; 0xb6c <Response_Signal+0xa>
}
     b70:	08 95       	ret

00000b72 <Receive_data>:

INT_8U Receive_data()
{
     b72:	87 e0       	ldi	r24, 0x07	; 7
     b74:	90 e0       	ldi	r25, 0x00	; 0
		{
			SETBIT(data_byte,(7-i));
		}
		else
		{
			CLEARBIT(data_byte,(7-i));
     b76:	41 e0       	ldi	r20, 0x01	; 1
     b78:	50 e0       	ldi	r21, 0x00	; 0

INT_8U Receive_data()
{
	for (INT_8U i=0; i<8; i++)
	{
		while(readbit(DHT11_PIN,DHT11_Data)==0);
     b7a:	0a 9b       	sbis	0x01, 2	; 1
     b7c:	fe cf       	rjmp	.-4      	; 0xb7a <Receive_data+0x8>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b7e:	20 e5       	ldi	r18, 0x50	; 80
     b80:	2a 95       	dec	r18
     b82:	f1 f7       	brne	.-4      	; 0xb80 <Receive_data+0xe>
		_delay_us(30);
		if(readbit(DHT11_PIN,DHT11_Data))
     b84:	0a 9b       	sbis	0x01, 2	; 1
     b86:	0d c0       	rjmp	.+26     	; 0xba2 <Receive_data+0x30>
		{
			SETBIT(data_byte,(7-i));
     b88:	60 91 92 03 	lds	r22, 0x0392	; 0x800392 <data_byte>
     b8c:	9a 01       	movw	r18, r20
     b8e:	08 2e       	mov	r0, r24
     b90:	02 c0       	rjmp	.+4      	; 0xb96 <Receive_data+0x24>
     b92:	22 0f       	add	r18, r18
     b94:	33 1f       	adc	r19, r19
     b96:	0a 94       	dec	r0
     b98:	e2 f7       	brpl	.-8      	; 0xb92 <Receive_data+0x20>
     b9a:	26 2b       	or	r18, r22
     b9c:	20 93 92 03 	sts	0x0392, r18	; 0x800392 <data_byte>
     ba0:	0d c0       	rjmp	.+26     	; 0xbbc <Receive_data+0x4a>
		}
		else
		{
			CLEARBIT(data_byte,(7-i));
     ba2:	9a 01       	movw	r18, r20
     ba4:	08 2e       	mov	r0, r24
     ba6:	02 c0       	rjmp	.+4      	; 0xbac <Receive_data+0x3a>
     ba8:	22 0f       	add	r18, r18
     baa:	33 1f       	adc	r19, r19
     bac:	0a 94       	dec	r0
     bae:	e2 f7       	brpl	.-8      	; 0xba8 <Receive_data+0x36>
     bb0:	20 95       	com	r18
     bb2:	30 91 92 03 	lds	r19, 0x0392	; 0x800392 <data_byte>
     bb6:	23 23       	and	r18, r19
     bb8:	20 93 92 03 	sts	0x0392, r18	; 0x800392 <data_byte>
		}
		while(readbit(DHT11_PIN,DHT11_Data));
     bbc:	0a 99       	sbic	0x01, 2	; 1
     bbe:	fe cf       	rjmp	.-4      	; 0xbbc <Receive_data+0x4a>
     bc0:	01 97       	sbiw	r24, 0x01	; 1
     bc2:	d8 f6       	brcc	.-74     	; 0xb7a <Receive_data+0x8>
	}
	return data_byte;
}
     bc4:	80 91 92 03 	lds	r24, 0x0392	; 0x800392 <data_byte>
     bc8:	08 95       	ret

00000bca <Fan_On>:
	Fan_Off();
}
void Fan_On(void)
{
	/* high */
	SETBIT(Fan_PORT,Fan_PIN_Number);
     bca:	e2 e6       	ldi	r30, 0x62	; 98
     bcc:	f0 e0       	ldi	r31, 0x00	; 0
     bce:	80 81       	ld	r24, Z
     bd0:	88 60       	ori	r24, 0x08	; 8
     bd2:	80 83       	st	Z, r24
     bd4:	08 95       	ret

00000bd6 <Fan_Off>:
}
void Fan_Off(void)
{
	/* low */
	CLEARBIT(Fan_PORT,Fan_PIN_Number);
     bd6:	e2 e6       	ldi	r30, 0x62	; 98
     bd8:	f0 e0       	ldi	r31, 0x00	; 0
     bda:	80 81       	ld	r24, Z
     bdc:	87 7f       	andi	r24, 0xF7	; 247
     bde:	80 83       	st	Z, r24
     be0:	08 95       	ret

00000be2 <Fan_Init>:
	}
	return data_byte;
}
void Fan_Init(void)
{   /* out */
	SETBIT(Fan_DDR,Fan_PIN_Number);
     be2:	e1 e6       	ldi	r30, 0x61	; 97
     be4:	f0 e0       	ldi	r31, 0x00	; 0
     be6:	80 81       	ld	r24, Z
     be8:	88 60       	ori	r24, 0x08	; 8
     bea:	80 83       	st	Z, r24
	/* Fan off */
	Fan_Off();
     bec:	f4 cf       	rjmp	.-24     	; 0xbd6 <Fan_Off>
     bee:	08 95       	ret

00000bf0 <Dim_LED_Brightness>:
	Dim_LED_Brightness(100);
}


void Dim_LED_Brightness (INT_8U Duty)
{
     bf0:	cf 93       	push	r28
     bf2:	c8 2f       	mov	r28, r24
	Timer3_Start();
     bf4:	b5 d3       	rcall	.+1898   	; 0x1360 <Timer3_Start>
	Timer3_SetDuty(Duty);
     bf6:	8c 2f       	mov	r24, r28
     bf8:	18 d4       	rcall	.+2096   	; 0x142a <Timer3_SetDuty>
}
     bfa:	cf 91       	pop	r28
     bfc:	08 95       	ret

00000bfe <Dim_LED_Init>:
#include "Dim_LED.h"
#include "board.h"

void Dim_LED_Init (void)
{
	Timer3_Init(MODE_FAST_PWM);
     bfe:	82 e0       	ldi	r24, 0x02	; 2
     c00:	c7 d3       	rcall	.+1934   	; 0x1390 <Timer3_Init>
	SETBIT(DDRE,PE3);
     c02:	13 9a       	sbi	0x02, 3	; 2
	Dim_LED_Brightness(100);
     c04:	84 e6       	ldi	r24, 0x64	; 100
     c06:	f4 cf       	rjmp	.-24     	; 0xbf0 <Dim_LED_Brightness>
     c08:	08 95       	ret

00000c0a <Dim_LED_Stop>:
	Timer3_Start();
	Timer3_SetDuty(Duty);
}
void Dim_LED_Stop (void)
{
	Timer3_SetDuty(0);
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	0e d4       	rcall	.+2076   	; 0x142a <Timer3_SetDuty>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c0e:	8f ec       	ldi	r24, 0xCF	; 207
     c10:	97 e0       	ldi	r25, 0x07	; 7
     c12:	01 97       	sbiw	r24, 0x01	; 1
     c14:	f1 f7       	brne	.-4      	; 0xc12 <Dim_LED_Stop+0x8>
     c16:	00 c0       	rjmp	.+0      	; 0xc18 <Dim_LED_Stop+0xe>
	_delay_ms(1);
	Timer3_Stop();
     c18:	00 00       	nop
     c1a:	ae c3       	rjmp	.+1884   	; 0x1378 <Timer3_Stop>
     c1c:	08 95       	ret

00000c1e <LCD_SendCmd>:
	}
}
void LCD_DispCharXY(INT_8U x, INT_8U y, INT_8U u8Char){
	LCD_GotoXY(x,y);
	LCD_DispChar(u8Char);
}
     c1e:	c5 98       	cbi	0x18, 5	; 24
     c20:	95 b3       	in	r25, 0x15	; 21
     c22:	9f 70       	andi	r25, 0x0F	; 15
     c24:	95 bb       	out	0x15, r25	; 21
     c26:	95 b3       	in	r25, 0x15	; 21
     c28:	28 2f       	mov	r18, r24
     c2a:	20 7f       	andi	r18, 0xF0	; 240
     c2c:	92 2b       	or	r25, r18
     c2e:	95 bb       	out	0x15, r25	; 21
     c30:	c7 9a       	sbi	0x18, 7	; 24
     c32:	ef ec       	ldi	r30, 0xCF	; 207
     c34:	f7 e0       	ldi	r31, 0x07	; 7
     c36:	31 97       	sbiw	r30, 0x01	; 1
     c38:	f1 f7       	brne	.-4      	; 0xc36 <LCD_SendCmd+0x18>
     c3a:	00 c0       	rjmp	.+0      	; 0xc3c <LCD_SendCmd+0x1e>
     c3c:	00 00       	nop
     c3e:	c7 98       	cbi	0x18, 7	; 24
     c40:	ef ec       	ldi	r30, 0xCF	; 207
     c42:	f7 e0       	ldi	r31, 0x07	; 7
     c44:	31 97       	sbiw	r30, 0x01	; 1
     c46:	f1 f7       	brne	.-4      	; 0xc44 <LCD_SendCmd+0x26>
     c48:	00 c0       	rjmp	.+0      	; 0xc4a <LCD_SendCmd+0x2c>
     c4a:	00 00       	nop
     c4c:	95 b3       	in	r25, 0x15	; 21
     c4e:	9f 70       	andi	r25, 0x0F	; 15
     c50:	95 bb       	out	0x15, r25	; 21
     c52:	25 b3       	in	r18, 0x15	; 21
     c54:	f0 e1       	ldi	r31, 0x10	; 16
     c56:	8f 9f       	mul	r24, r31
     c58:	c0 01       	movw	r24, r0
     c5a:	11 24       	eor	r1, r1
     c5c:	82 2b       	or	r24, r18
     c5e:	85 bb       	out	0x15, r24	; 21
     c60:	c7 9a       	sbi	0x18, 7	; 24
     c62:	8f ec       	ldi	r24, 0xCF	; 207
     c64:	97 e0       	ldi	r25, 0x07	; 7
     c66:	01 97       	sbiw	r24, 0x01	; 1
     c68:	f1 f7       	brne	.-4      	; 0xc66 <LCD_SendCmd+0x48>
     c6a:	00 c0       	rjmp	.+0      	; 0xc6c <LCD_SendCmd+0x4e>
     c6c:	00 00       	nop
     c6e:	c7 98       	cbi	0x18, 7	; 24
     c70:	ef ec       	ldi	r30, 0xCF	; 207
     c72:	f7 e0       	ldi	r31, 0x07	; 7
     c74:	31 97       	sbiw	r30, 0x01	; 1
     c76:	f1 f7       	brne	.-4      	; 0xc74 <LCD_SendCmd+0x56>
     c78:	00 c0       	rjmp	.+0      	; 0xc7a <LCD_SendCmd+0x5c>
     c7a:	00 00       	nop
     c7c:	fa e6       	ldi	r31, 0x6A	; 106
     c7e:	fa 95       	dec	r31
     c80:	f1 f7       	brne	.-4      	; 0xc7e <LCD_SendCmd+0x60>
     c82:	00 c0       	rjmp	.+0      	; 0xc84 <LCD_SendCmd+0x66>
     c84:	08 95       	ret

00000c86 <LCD_SendData>:
     c86:	c5 9a       	sbi	0x18, 5	; 24
     c88:	95 b3       	in	r25, 0x15	; 21
     c8a:	9f 70       	andi	r25, 0x0F	; 15
     c8c:	95 bb       	out	0x15, r25	; 21
     c8e:	95 b3       	in	r25, 0x15	; 21
     c90:	28 2f       	mov	r18, r24
     c92:	20 7f       	andi	r18, 0xF0	; 240
     c94:	92 2b       	or	r25, r18
     c96:	95 bb       	out	0x15, r25	; 21
     c98:	c7 9a       	sbi	0x18, 7	; 24
     c9a:	ef ec       	ldi	r30, 0xCF	; 207
     c9c:	f7 e0       	ldi	r31, 0x07	; 7
     c9e:	31 97       	sbiw	r30, 0x01	; 1
     ca0:	f1 f7       	brne	.-4      	; 0xc9e <LCD_SendData+0x18>
     ca2:	00 c0       	rjmp	.+0      	; 0xca4 <LCD_SendData+0x1e>
     ca4:	00 00       	nop
     ca6:	c7 98       	cbi	0x18, 7	; 24
     ca8:	ef ec       	ldi	r30, 0xCF	; 207
     caa:	f7 e0       	ldi	r31, 0x07	; 7
     cac:	31 97       	sbiw	r30, 0x01	; 1
     cae:	f1 f7       	brne	.-4      	; 0xcac <LCD_SendData+0x26>
     cb0:	00 c0       	rjmp	.+0      	; 0xcb2 <LCD_SendData+0x2c>
     cb2:	00 00       	nop
     cb4:	95 b3       	in	r25, 0x15	; 21
     cb6:	9f 70       	andi	r25, 0x0F	; 15
     cb8:	95 bb       	out	0x15, r25	; 21
     cba:	25 b3       	in	r18, 0x15	; 21
     cbc:	f0 e1       	ldi	r31, 0x10	; 16
     cbe:	8f 9f       	mul	r24, r31
     cc0:	c0 01       	movw	r24, r0
     cc2:	11 24       	eor	r1, r1
     cc4:	82 2b       	or	r24, r18
     cc6:	85 bb       	out	0x15, r24	; 21
     cc8:	c7 9a       	sbi	0x18, 7	; 24
     cca:	8f ec       	ldi	r24, 0xCF	; 207
     ccc:	97 e0       	ldi	r25, 0x07	; 7
     cce:	01 97       	sbiw	r24, 0x01	; 1
     cd0:	f1 f7       	brne	.-4      	; 0xcce <LCD_SendData+0x48>
     cd2:	00 c0       	rjmp	.+0      	; 0xcd4 <LCD_SendData+0x4e>
     cd4:	00 00       	nop
     cd6:	c7 98       	cbi	0x18, 7	; 24
     cd8:	ef ec       	ldi	r30, 0xCF	; 207
     cda:	f7 e0       	ldi	r31, 0x07	; 7
     cdc:	31 97       	sbiw	r30, 0x01	; 1
     cde:	f1 f7       	brne	.-4      	; 0xcdc <LCD_SendData+0x56>
     ce0:	00 c0       	rjmp	.+0      	; 0xce2 <LCD_SendData+0x5c>
     ce2:	00 00       	nop
     ce4:	fa e6       	ldi	r31, 0x6A	; 106
     ce6:	fa 95       	dec	r31
     ce8:	f1 f7       	brne	.-4      	; 0xce6 <LCD_SendData+0x60>
     cea:	00 c0       	rjmp	.+0      	; 0xcec <LCD_SendData+0x66>
     cec:	08 95       	ret

00000cee <LCD_Init>:
     cee:	84 b3       	in	r24, 0x14	; 20
     cf0:	80 6f       	ori	r24, 0xF0	; 240
     cf2:	84 bb       	out	0x14, r24	; 20
     cf4:	bf 9a       	sbi	0x17, 7	; 23
     cf6:	bd 9a       	sbi	0x17, 5	; 23
     cf8:	be 9a       	sbi	0x17, 6	; 23
     cfa:	c6 98       	cbi	0x18, 6	; 24
     cfc:	14 9a       	sbi	0x02, 4	; 2
     cfe:	1c 9a       	sbi	0x03, 4	; 3
     d00:	8f e3       	ldi	r24, 0x3F	; 63
     d02:	9c e9       	ldi	r25, 0x9C	; 156
     d04:	01 97       	sbiw	r24, 0x01	; 1
     d06:	f1 f7       	brne	.-4      	; 0xd04 <LCD_Init+0x16>
     d08:	00 c0       	rjmp	.+0      	; 0xd0a <LCD_Init+0x1c>
     d0a:	00 00       	nop
     d0c:	82 e0       	ldi	r24, 0x02	; 2
     d0e:	87 df       	rcall	.-242    	; 0xc1e <LCD_SendCmd>
     d10:	88 e2       	ldi	r24, 0x28	; 40
     d12:	85 df       	rcall	.-246    	; 0xc1e <LCD_SendCmd>
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	83 df       	rcall	.-250    	; 0xc1e <LCD_SendCmd>
     d18:	8c e0       	ldi	r24, 0x0C	; 12
     d1a:	81 df       	rcall	.-254    	; 0xc1e <LCD_SendCmd>
     d1c:	86 e0       	ldi	r24, 0x06	; 6
     d1e:	7f df       	rcall	.-258    	; 0xc1e <LCD_SendCmd>
     d20:	8f e3       	ldi	r24, 0x3F	; 63
     d22:	9c e9       	ldi	r25, 0x9C	; 156
     d24:	01 97       	sbiw	r24, 0x01	; 1
     d26:	f1 f7       	brne	.-4      	; 0xd24 <LCD_Init+0x36>
     d28:	00 c0       	rjmp	.+0      	; 0xd2a <LCD_Init+0x3c>
     d2a:	00 00       	nop
     d2c:	08 95       	ret

00000d2e <LCD_DispChar>:
     d2e:	ab cf       	rjmp	.-170    	; 0xc86 <LCD_SendData>
     d30:	08 95       	ret

00000d32 <LCD_DispStr>:
     d32:	ef 92       	push	r14
     d34:	ff 92       	push	r15
     d36:	0f 93       	push	r16
     d38:	1f 93       	push	r17
     d3a:	cf 93       	push	r28
     d3c:	df 93       	push	r29
     d3e:	8c 01       	movw	r16, r24
     d40:	7c 01       	movw	r14, r24
     d42:	c0 e0       	ldi	r28, 0x00	; 0
     d44:	d0 e0       	ldi	r29, 0x00	; 0
     d46:	05 c0       	rjmp	.+10     	; 0xd52 <LCD_DispStr+0x20>
     d48:	f7 01       	movw	r30, r14
     d4a:	81 91       	ld	r24, Z+
     d4c:	7f 01       	movw	r14, r30
     d4e:	9b df       	rcall	.-202    	; 0xc86 <LCD_SendData>
     d50:	21 96       	adiw	r28, 0x01	; 1
     d52:	f8 01       	movw	r30, r16
     d54:	01 90       	ld	r0, Z+
     d56:	00 20       	and	r0, r0
     d58:	e9 f7       	brne	.-6      	; 0xd54 <LCD_DispStr+0x22>
     d5a:	31 97       	sbiw	r30, 0x01	; 1
     d5c:	e0 1b       	sub	r30, r16
     d5e:	f1 0b       	sbc	r31, r17
     d60:	ce 17       	cp	r28, r30
     d62:	df 07       	cpc	r29, r31
     d64:	88 f3       	brcs	.-30     	; 0xd48 <LCD_DispStr+0x16>
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	1f 91       	pop	r17
     d6c:	0f 91       	pop	r16
     d6e:	ff 90       	pop	r15
     d70:	ef 90       	pop	r14
     d72:	08 95       	ret

00000d74 <LCD_DispStrXY>:
void LCD_DispStrXY(INT_8U x, INT_8U y, INT_8U* pu8Str){
     d74:	cf 93       	push	r28
     d76:	df 93       	push	r29
     d78:	ea 01       	movw	r28, r20
	Line 1: 0x00
	Line 2: 0x40
*/
static void LCD_GotoXY(INT_8U x, INT_8U y){
	/* get address of DDRAM using x,y */
	if(x == 1){
     d7a:	81 30       	cpi	r24, 0x01	; 1
     d7c:	21 f4       	brne	.+8      	; 0xd86 <LCD_DispStrXY+0x12>
		LCD_SendCmd((0x80|0x00) + y-1); /* Eqn */
     d7e:	8f e7       	ldi	r24, 0x7F	; 127
     d80:	86 0f       	add	r24, r22
     d82:	4d df       	rcall	.-358    	; 0xc1e <LCD_SendCmd>
     d84:	03 c0       	rjmp	.+6      	; 0xd8c <LCD_DispStrXY+0x18>
	}
	else{
		LCD_SendCmd((0x80|0x40) + y-1); /* Eqn */
     d86:	8f eb       	ldi	r24, 0xBF	; 191
     d88:	86 0f       	add	r24, r22
     d8a:	49 df       	rcall	.-366    	; 0xc1e <LCD_SendCmd>
	LCD_GotoXY(x,y);
	LCD_DispChar(u8Char);
}
void LCD_DispStrXY(INT_8U x, INT_8U y, INT_8U* pu8Str){
	LCD_GotoXY(x,y);
	LCD_DispStr(pu8Str);
     d8c:	ce 01       	movw	r24, r28
     d8e:	d1 df       	rcall	.-94     	; 0xd32 <LCD_DispStr>
     d90:	df 91       	pop	r29
}
     d92:	cf 91       	pop	r28
     d94:	08 95       	ret

00000d96 <LDR_Init>:
 */ 
#include "LDR.h"

void LDR_Init(void)
{
	ADC_INIT();
     d96:	2f c1       	rjmp	.+606    	; 0xff6 <ADC_INIT>
     d98:	08 95       	ret

00000d9a <LDR_Val>:
}
void LDR_Val (INT_16U* u16LDR_Value)
{
     d9a:	cf 93       	push	r28
     d9c:	df 93       	push	r29
     d9e:	ec 01       	movw	r28, r24
		/* Read adc value*/
    *u16LDR_Value=ADC_Read(LDR_channel); 
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	32 d1       	rcall	.+612    	; 0x1008 <ADC_Read>
		/* Convert adc value to percentage*/
	*u16LDR_Value=( *u16LDR_Value /850.0)*100.0;
     da4:	bc 01       	movw	r22, r24
     da6:	80 e0       	ldi	r24, 0x00	; 0
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <__floatunsisf>
     dae:	20 e0       	ldi	r18, 0x00	; 0
     db0:	30 e8       	ldi	r19, 0x80	; 128
     db2:	44 e5       	ldi	r20, 0x54	; 84
     db4:	54 e4       	ldi	r21, 0x44	; 68
     db6:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <__divsf3>
     dba:	20 e0       	ldi	r18, 0x00	; 0
     dbc:	30 e0       	ldi	r19, 0x00	; 0
     dbe:	48 ec       	ldi	r20, 0xC8	; 200
     dc0:	52 e4       	ldi	r21, 0x42	; 66
     dc2:	0e 94 6e 17 	call	0x2edc	; 0x2edc <__mulsf3>
     dc6:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <__fixunssfsi>
     dca:	79 83       	std	Y+1, r23	; 0x01
     dcc:	68 83       	st	Y, r22
	
     dce:	df 91       	pop	r29
     dd0:	cf 91       	pop	r28
     dd2:	08 95       	ret

00000dd4 <Soil_Moisture_Init>:

#include    "SOIL_MOISTURE.h"

void Soil_Moisture_Init(void)
{
	ADC_INIT();	
     dd4:	10 c1       	rjmp	.+544    	; 0xff6 <ADC_INIT>
     dd6:	08 95       	ret

00000dd8 <Soil_Moisture_Read>:
}

void Soil_Moisture_Read(INT_16U* COPY_u16Data)
{
     dd8:	cf 93       	push	r28
     dda:	df 93       	push	r29
     ddc:	ec 01       	movw	r28, r24
		/* Read adc value*/
	*COPY_u16Data=ADC_Read(Soil_Moisture_channel);
     dde:	86 e0       	ldi	r24, 0x06	; 6
     de0:	13 d1       	rcall	.+550    	; 0x1008 <ADC_Read>
		/* Convert adc value to percentage*/
	*COPY_u16Data=(  ((FP32)(*COPY_u16Data)/1000 ) *100 );
     de2:	bc 01       	movw	r22, r24
     de4:	80 e0       	ldi	r24, 0x00	; 0
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <__floatunsisf>
     dec:	20 e0       	ldi	r18, 0x00	; 0
     dee:	30 e0       	ldi	r19, 0x00	; 0
     df0:	4a e7       	ldi	r20, 0x7A	; 122
     df2:	54 e4       	ldi	r21, 0x44	; 68
     df4:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <__divsf3>
     df8:	20 e0       	ldi	r18, 0x00	; 0
     dfa:	30 e0       	ldi	r19, 0x00	; 0
     dfc:	48 ec       	ldi	r20, 0xC8	; 200
     dfe:	52 e4       	ldi	r21, 0x42	; 66
     e00:	0e 94 6e 17 	call	0x2edc	; 0x2edc <__mulsf3>
     e04:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <__fixunssfsi>
     e08:	79 83       	std	Y+1, r23	; 0x01
     e0a:	68 83       	st	Y, r22
	
}
     e0c:	df 91       	pop	r29
     e0e:	cf 91       	pop	r28
     e10:	08 95       	ret

00000e12 <Water_Pump_ON>:
}


void Water_Pump_ON(void)
{
	SETBIT(Water_Pump_PORT,Water_Pump_PIN_Number);
     e12:	90 9a       	sbi	0x12, 0	; 18
     e14:	08 95       	ret

00000e16 <Water_Pump_OFF>:
}

void Water_Pump_OFF(void)
{
	CLEARBIT(Water_Pump_PORT,Water_Pump_PIN_Number);
     e16:	90 98       	cbi	0x12, 0	; 18
     e18:	08 95       	ret

00000e1a <Water_Pump_Init>:
	
}

void Water_Pump_Init(void)
{
	SETBIT(Water_Pump_DDR,Water_Pump_PIN_Number);
     e1a:	88 9a       	sbi	0x11, 0	; 17
	Water_Pump_OFF();
     e1c:	fc cf       	rjmp	.-8      	; 0xe16 <Water_Pump_OFF>
     e1e:	08 95       	ret

00000e20 <Wifi_Init>:
			
		
	}
	return result;
	
}
     e20:	cf 93       	push	r28
     e22:	c8 2f       	mov	r28, r24
     e24:	40 e8       	ldi	r20, 0x80	; 128
     e26:	55 e2       	ldi	r21, 0x25	; 37
     e28:	60 e0       	ldi	r22, 0x00	; 0
     e2a:	70 e0       	ldi	r23, 0x00	; 0
     e2c:	80 e0       	ldi	r24, 0x00	; 0
     e2e:	77 d3       	rcall	.+1774   	; 0x151e <UART_Init>
     e30:	c2 30       	cpi	r28, 0x02	; 2
     e32:	49 f0       	breq	.+18     	; 0xe46 <Wifi_Init+0x26>
     e34:	c3 30       	cpi	r28, 0x03	; 3
     e36:	61 f0       	breq	.+24     	; 0xe50 <Wifi_Init+0x30>
     e38:	c1 30       	cpi	r28, 0x01	; 1
     e3a:	71 f4       	brne	.+28     	; 0xe58 <Wifi_Init+0x38>
     e3c:	67 e7       	ldi	r22, 0x77	; 119
     e3e:	72 e0       	ldi	r23, 0x02	; 2
     e40:	80 e0       	ldi	r24, 0x00	; 0
     e42:	d5 d3       	rcall	.+1962   	; 0x15ee <UART_SendString>
     e44:	09 c0       	rjmp	.+18     	; 0xe58 <Wifi_Init+0x38>
     e46:	69 e8       	ldi	r22, 0x89	; 137
     e48:	72 e0       	ldi	r23, 0x02	; 2
     e4a:	80 e0       	ldi	r24, 0x00	; 0
     e4c:	d0 d3       	rcall	.+1952   	; 0x15ee <UART_SendString>
     e4e:	04 c0       	rjmp	.+8      	; 0xe58 <Wifi_Init+0x38>
     e50:	6b e9       	ldi	r22, 0x9B	; 155
     e52:	72 e0       	ldi	r23, 0x02	; 2
     e54:	80 e0       	ldi	r24, 0x00	; 0
     e56:	cb d3       	rcall	.+1942   	; 0x15ee <UART_SendString>
     e58:	2f ef       	ldi	r18, 0xFF	; 255
     e5a:	89 e6       	ldi	r24, 0x69	; 105
     e5c:	98 e1       	ldi	r25, 0x18	; 24
     e5e:	21 50       	subi	r18, 0x01	; 1
     e60:	80 40       	sbci	r24, 0x00	; 0
     e62:	90 40       	sbci	r25, 0x00	; 0
     e64:	e1 f7       	brne	.-8      	; 0xe5e <Wifi_Init+0x3e>
     e66:	00 c0       	rjmp	.+0      	; 0xe68 <Wifi_Init+0x48>
     e68:	00 00       	nop
     e6a:	cf 91       	pop	r28
     e6c:	08 95       	ret

00000e6e <Wifi_EchoMode>:
     e6e:	88 23       	and	r24, r24
     e70:	39 f0       	breq	.+14     	; 0xe80 <Wifi_EchoMode+0x12>
     e72:	81 30       	cpi	r24, 0x01	; 1
     e74:	49 f4       	brne	.+18     	; 0xe88 <Wifi_EchoMode+0x1a>
     e76:	6d ea       	ldi	r22, 0xAD	; 173
     e78:	72 e0       	ldi	r23, 0x02	; 2
     e7a:	80 e0       	ldi	r24, 0x00	; 0
     e7c:	b8 c3       	rjmp	.+1904   	; 0x15ee <UART_SendString>
     e7e:	08 95       	ret
     e80:	64 eb       	ldi	r22, 0xB4	; 180
     e82:	72 e0       	ldi	r23, 0x02	; 2
     e84:	80 e0       	ldi	r24, 0x00	; 0
     e86:	b3 c3       	rjmp	.+1894   	; 0x15ee <UART_SendString>
     e88:	08 95       	ret

00000e8a <Wifi_AP_Connect>:
     e8a:	0f 93       	push	r16
     e8c:	1f 93       	push	r17
     e8e:	cf 93       	push	r28
     e90:	df 93       	push	r29
     e92:	cd b7       	in	r28, 0x3d	; 61
     e94:	de b7       	in	r29, 0x3e	; 62
     e96:	e2 97       	sbiw	r28, 0x32	; 50
     e98:	0f b6       	in	r0, 0x3f	; 63
     e9a:	f8 94       	cli
     e9c:	de bf       	out	0x3e, r29	; 62
     e9e:	0f be       	out	0x3f, r0	; 63
     ea0:	cd bf       	out	0x3d, r28	; 61
     ea2:	8e 01       	movw	r16, r28
     ea4:	0f 5f       	subi	r16, 0xFF	; 255
     ea6:	1f 4f       	sbci	r17, 0xFF	; 255
     ea8:	22 e3       	ldi	r18, 0x32	; 50
     eaa:	f8 01       	movw	r30, r16
     eac:	11 92       	st	Z+, r1
     eae:	2a 95       	dec	r18
     eb0:	e9 f7       	brne	.-6      	; 0xeac <Wifi_AP_Connect+0x22>
     eb2:	20 e3       	ldi	r18, 0x30	; 48
     eb4:	29 83       	std	Y+1, r18	; 0x01
     eb6:	7f 93       	push	r23
     eb8:	6f 93       	push	r22
     eba:	9f 93       	push	r25
     ebc:	8f 93       	push	r24
     ebe:	8b eb       	ldi	r24, 0xBB	; 187
     ec0:	92 e0       	ldi	r25, 0x02	; 2
     ec2:	9f 93       	push	r25
     ec4:	8f 93       	push	r24
     ec6:	1f 93       	push	r17
     ec8:	0f 93       	push	r16
     eca:	0e 94 1e 18 	call	0x303c	; 0x303c <sprintf>
     ece:	b8 01       	movw	r22, r16
     ed0:	80 e0       	ldi	r24, 0x00	; 0
     ed2:	8d d3       	rcall	.+1818   	; 0x15ee <UART_SendString>
     ed4:	0f b6       	in	r0, 0x3f	; 63
     ed6:	f8 94       	cli
     ed8:	de bf       	out	0x3e, r29	; 62
     eda:	0f be       	out	0x3f, r0	; 63
     edc:	cd bf       	out	0x3d, r28	; 61
     ede:	e2 96       	adiw	r28, 0x32	; 50
     ee0:	0f b6       	in	r0, 0x3f	; 63
     ee2:	f8 94       	cli
     ee4:	de bf       	out	0x3e, r29	; 62
     ee6:	0f be       	out	0x3f, r0	; 63
     ee8:	cd bf       	out	0x3d, r28	; 61
     eea:	df 91       	pop	r29
     eec:	cf 91       	pop	r28
     eee:	1f 91       	pop	r17
     ef0:	0f 91       	pop	r16
     ef2:	08 95       	ret

00000ef4 <Wifi_ConnectionMode>:
     ef4:	88 23       	and	r24, r24
     ef6:	19 f0       	breq	.+6      	; 0xefe <Wifi_ConnectionMode+0xa>
     ef8:	81 30       	cpi	r24, 0x01	; 1
     efa:	31 f0       	breq	.+12     	; 0xf08 <Wifi_ConnectionMode+0x14>
     efc:	08 95       	ret
     efe:	64 ed       	ldi	r22, 0xD4	; 212
     f00:	72 e0       	ldi	r23, 0x02	; 2
     f02:	80 e0       	ldi	r24, 0x00	; 0
     f04:	74 c3       	rjmp	.+1768   	; 0x15ee <UART_SendString>
     f06:	08 95       	ret
     f08:	62 ee       	ldi	r22, 0xE2	; 226
     f0a:	72 e0       	ldi	r23, 0x02	; 2
     f0c:	80 e0       	ldi	r24, 0x00	; 0
     f0e:	6f c3       	rjmp	.+1758   	; 0x15ee <UART_SendString>
     f10:	08 95       	ret

00000f12 <Wifi_StartTCP_Conn>:
     f12:	0f 93       	push	r16
     f14:	1f 93       	push	r17
     f16:	cf 93       	push	r28
     f18:	df 93       	push	r29
     f1a:	cd b7       	in	r28, 0x3d	; 61
     f1c:	de b7       	in	r29, 0x3e	; 62
     f1e:	e2 97       	sbiw	r28, 0x32	; 50
     f20:	0f b6       	in	r0, 0x3f	; 63
     f22:	f8 94       	cli
     f24:	de bf       	out	0x3e, r29	; 62
     f26:	0f be       	out	0x3f, r0	; 63
     f28:	cd bf       	out	0x3d, r28	; 61
     f2a:	8e 01       	movw	r16, r28
     f2c:	0f 5f       	subi	r16, 0xFF	; 255
     f2e:	1f 4f       	sbci	r17, 0xFF	; 255
     f30:	22 e3       	ldi	r18, 0x32	; 50
     f32:	f8 01       	movw	r30, r16
     f34:	11 92       	st	Z+, r1
     f36:	2a 95       	dec	r18
     f38:	e9 f7       	brne	.-6      	; 0xf34 <Wifi_StartTCP_Conn+0x22>
     f3a:	20 e3       	ldi	r18, 0x30	; 48
     f3c:	29 83       	std	Y+1, r18	; 0x01
     f3e:	7f 93       	push	r23
     f40:	6f 93       	push	r22
     f42:	9f 93       	push	r25
     f44:	8f 93       	push	r24
     f46:	80 ef       	ldi	r24, 0xF0	; 240
     f48:	92 e0       	ldi	r25, 0x02	; 2
     f4a:	9f 93       	push	r25
     f4c:	8f 93       	push	r24
     f4e:	1f 93       	push	r17
     f50:	0f 93       	push	r16
     f52:	0e 94 1e 18 	call	0x303c	; 0x303c <sprintf>
     f56:	b8 01       	movw	r22, r16
     f58:	80 e0       	ldi	r24, 0x00	; 0
     f5a:	49 d3       	rcall	.+1682   	; 0x15ee <UART_SendString>
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	de bf       	out	0x3e, r29	; 62
     f62:	0f be       	out	0x3f, r0	; 63
     f64:	cd bf       	out	0x3d, r28	; 61
     f66:	e2 96       	adiw	r28, 0x32	; 50
     f68:	0f b6       	in	r0, 0x3f	; 63
     f6a:	f8 94       	cli
     f6c:	de bf       	out	0x3e, r29	; 62
     f6e:	0f be       	out	0x3f, r0	; 63
     f70:	cd bf       	out	0x3d, r28	; 61
     f72:	df 91       	pop	r29
     f74:	cf 91       	pop	r28
     f76:	1f 91       	pop	r17
     f78:	0f 91       	pop	r16
     f7a:	08 95       	ret

00000f7c <Wifi_Sendex_Command>:

void Wifi_Sendex_Command(INT_8U length)
{
     f7c:	0f 93       	push	r16
     f7e:	1f 93       	push	r17
     f80:	cf 93       	push	r28
     f82:	df 93       	push	r29
     f84:	cd b7       	in	r28, 0x3d	; 61
     f86:	de b7       	in	r29, 0x3e	; 62
     f88:	64 97       	sbiw	r28, 0x14	; 20
     f8a:	0f b6       	in	r0, 0x3f	; 63
     f8c:	f8 94       	cli
     f8e:	de bf       	out	0x3e, r29	; 62
     f90:	0f be       	out	0x3f, r0	; 63
     f92:	cd bf       	out	0x3d, r28	; 61
	
	INT_8U str[20]={'0'};
     f94:	8e 01       	movw	r16, r28
     f96:	0f 5f       	subi	r16, 0xFF	; 255
     f98:	1f 4f       	sbci	r17, 0xFF	; 255
     f9a:	94 e1       	ldi	r25, 0x14	; 20
     f9c:	f8 01       	movw	r30, r16
     f9e:	11 92       	st	Z+, r1
     fa0:	9a 95       	dec	r25
     fa2:	e9 f7       	brne	.-6      	; 0xf9e <Wifi_Sendex_Command+0x22>
     fa4:	90 e3       	ldi	r25, 0x30	; 48
     fa6:	99 83       	std	Y+1, r25	; 0x01
	sprintf(str,"AT+CIPSENDEX=%d\r\n",length);
     fa8:	1f 92       	push	r1
     faa:	8f 93       	push	r24
     fac:	8c e1       	ldi	r24, 0x1C	; 28
     fae:	93 e0       	ldi	r25, 0x03	; 3
     fb0:	9f 93       	push	r25
     fb2:	8f 93       	push	r24
     fb4:	1f 93       	push	r17
     fb6:	0f 93       	push	r16
     fb8:	0e 94 1e 18 	call	0x303c	; 0x303c <sprintf>
	UART_SendString(UART_0,str);
     fbc:	b8 01       	movw	r22, r16
     fbe:	80 e0       	ldi	r24, 0x00	; 0
     fc0:	16 d3       	rcall	.+1580   	; 0x15ee <UART_SendString>
     fc2:	ff ef       	ldi	r31, 0xFF	; 255
     fc4:	22 e5       	ldi	r18, 0x52	; 82
     fc6:	87 e0       	ldi	r24, 0x07	; 7
     fc8:	f1 50       	subi	r31, 0x01	; 1
     fca:	20 40       	sbci	r18, 0x00	; 0
     fcc:	80 40       	sbci	r24, 0x00	; 0
     fce:	e1 f7       	brne	.-8      	; 0xfc8 <Wifi_Sendex_Command+0x4c>
     fd0:	00 c0       	rjmp	.+0      	; 0xfd2 <Wifi_Sendex_Command+0x56>
     fd2:	00 00       	nop
	_delay_ms(300);
}
     fd4:	0f 90       	pop	r0
     fd6:	0f 90       	pop	r0
     fd8:	0f 90       	pop	r0
     fda:	0f 90       	pop	r0
     fdc:	0f 90       	pop	r0
     fde:	0f 90       	pop	r0
     fe0:	64 96       	adiw	r28, 0x14	; 20
     fe2:	0f b6       	in	r0, 0x3f	; 63
     fe4:	f8 94       	cli
     fe6:	de bf       	out	0x3e, r29	; 62
     fe8:	0f be       	out	0x3f, r0	; 63
     fea:	cd bf       	out	0x3d, r28	; 61
     fec:	df 91       	pop	r29
     fee:	cf 91       	pop	r28
     ff0:	1f 91       	pop	r17
     ff2:	0f 91       	pop	r16
     ff4:	08 95       	ret

00000ff6 <ADC_INIT>:
#include "LCD4bit.h"

void ADC_INIT(void)
{
	/*  clock       */
	ADC_struct->ADCSRA_BF.ADPS = 0b111;
     ff6:	86 b1       	in	r24, 0x06	; 6
     ff8:	87 60       	ori	r24, 0x07	; 7
     ffa:	86 b9       	out	0x06, r24	; 6
	/*  ref->  AVCC */
	ADC_struct->ADCMUX_BF.REFS = 0b01;
     ffc:	87 b1       	in	r24, 0x07	; 7
     ffe:	8f 73       	andi	r24, 0x3F	; 63
    1000:	80 64       	ori	r24, 0x40	; 64
    1002:	87 b9       	out	0x07, r24	; 7
	/*  Enable      */  
	ADC_struct->ADCSRA_BF.ADEN_B = 1;
    1004:	37 9a       	sbi	0x06, 7	; 6
    1006:	08 95       	ret

00001008 <ADC_Read>:
}

INT_16U ADC_Read (INT_8U u8channel)
{
	//   =========select channel=============
	ADC_struct->ADCMUX_BF.MUX = u8channel;
    1008:	8f 71       	andi	r24, 0x1F	; 31
    100a:	97 b1       	in	r25, 0x07	; 7
    100c:	90 7e       	andi	r25, 0xE0	; 224
    100e:	89 2b       	or	r24, r25
    1010:	87 b9       	out	0x07, r24	; 7
	//   =========start conversion===========
	ADC_struct->ADCSRA_BF.ADSC_B = 1;
    1012:	36 9a       	sbi	0x06, 6	; 6
	//   ===wait until conversion completes==
	while(ADC_struct->ADCSRA_BF.ADSC_B == 1);  
    1014:	36 99       	sbic	0x06, 6	; 6
    1016:	fe cf       	rjmp	.-4      	; 0x1014 <ADC_Read+0xc>
	//   =========return ADC data============
	return ADC_struct->ADC_Data;
    1018:	84 b1       	in	r24, 0x04	; 4
    101a:	95 b1       	in	r25, 0x05	; 5
}
    101c:	08 95       	ret

0000101e <__vector_1>:
	ptr_CallList[intNUM]= ptr_CallBack_Fun;
}


ISR(INT0_vect)
{
    101e:	1f 92       	push	r1
    1020:	0f 92       	push	r0
    1022:	0f b6       	in	r0, 0x3f	; 63
    1024:	0f 92       	push	r0
    1026:	11 24       	eor	r1, r1
    1028:	0b b6       	in	r0, 0x3b	; 59
    102a:	0f 92       	push	r0
    102c:	2f 93       	push	r18
    102e:	3f 93       	push	r19
    1030:	4f 93       	push	r20
    1032:	5f 93       	push	r21
    1034:	6f 93       	push	r22
    1036:	7f 93       	push	r23
    1038:	8f 93       	push	r24
    103a:	9f 93       	push	r25
    103c:	af 93       	push	r26
    103e:	bf 93       	push	r27
    1040:	ef 93       	push	r30
    1042:	ff 93       	push	r31
	ptr_CallList[INT_NUM_0]();
    1044:	e0 91 01 0a 	lds	r30, 0x0A01	; 0x800a01 <ptr_CallList>
    1048:	f0 91 02 0a 	lds	r31, 0x0A02	; 0x800a02 <ptr_CallList+0x1>
    104c:	09 95       	icall
}
    104e:	ff 91       	pop	r31
    1050:	ef 91       	pop	r30
    1052:	bf 91       	pop	r27
    1054:	af 91       	pop	r26
    1056:	9f 91       	pop	r25
    1058:	8f 91       	pop	r24
    105a:	7f 91       	pop	r23
    105c:	6f 91       	pop	r22
    105e:	5f 91       	pop	r21
    1060:	4f 91       	pop	r20
    1062:	3f 91       	pop	r19
    1064:	2f 91       	pop	r18
    1066:	0f 90       	pop	r0
    1068:	0b be       	out	0x3b, r0	; 59
    106a:	0f 90       	pop	r0
    106c:	0f be       	out	0x3f, r0	; 63
    106e:	0f 90       	pop	r0
    1070:	1f 90       	pop	r1
    1072:	18 95       	reti

00001074 <__vector_2>:
ISR(INT1_vect)
{
    1074:	1f 92       	push	r1
    1076:	0f 92       	push	r0
    1078:	0f b6       	in	r0, 0x3f	; 63
    107a:	0f 92       	push	r0
    107c:	11 24       	eor	r1, r1
    107e:	0b b6       	in	r0, 0x3b	; 59
    1080:	0f 92       	push	r0
    1082:	2f 93       	push	r18
    1084:	3f 93       	push	r19
    1086:	4f 93       	push	r20
    1088:	5f 93       	push	r21
    108a:	6f 93       	push	r22
    108c:	7f 93       	push	r23
    108e:	8f 93       	push	r24
    1090:	9f 93       	push	r25
    1092:	af 93       	push	r26
    1094:	bf 93       	push	r27
    1096:	ef 93       	push	r30
    1098:	ff 93       	push	r31
	ptr_CallList[INT_NUM_1]();
    109a:	e0 91 03 0a 	lds	r30, 0x0A03	; 0x800a03 <ptr_CallList+0x2>
    109e:	f0 91 04 0a 	lds	r31, 0x0A04	; 0x800a04 <ptr_CallList+0x3>
    10a2:	09 95       	icall
}
    10a4:	ff 91       	pop	r31
    10a6:	ef 91       	pop	r30
    10a8:	bf 91       	pop	r27
    10aa:	af 91       	pop	r26
    10ac:	9f 91       	pop	r25
    10ae:	8f 91       	pop	r24
    10b0:	7f 91       	pop	r23
    10b2:	6f 91       	pop	r22
    10b4:	5f 91       	pop	r21
    10b6:	4f 91       	pop	r20
    10b8:	3f 91       	pop	r19
    10ba:	2f 91       	pop	r18
    10bc:	0f 90       	pop	r0
    10be:	0b be       	out	0x3b, r0	; 59
    10c0:	0f 90       	pop	r0
    10c2:	0f be       	out	0x3f, r0	; 63
    10c4:	0f 90       	pop	r0
    10c6:	1f 90       	pop	r1
    10c8:	18 95       	reti

000010ca <__vector_3>:
ISR(INT2_vect)
{
    10ca:	1f 92       	push	r1
    10cc:	0f 92       	push	r0
    10ce:	0f b6       	in	r0, 0x3f	; 63
    10d0:	0f 92       	push	r0
    10d2:	11 24       	eor	r1, r1
    10d4:	0b b6       	in	r0, 0x3b	; 59
    10d6:	0f 92       	push	r0
    10d8:	2f 93       	push	r18
    10da:	3f 93       	push	r19
    10dc:	4f 93       	push	r20
    10de:	5f 93       	push	r21
    10e0:	6f 93       	push	r22
    10e2:	7f 93       	push	r23
    10e4:	8f 93       	push	r24
    10e6:	9f 93       	push	r25
    10e8:	af 93       	push	r26
    10ea:	bf 93       	push	r27
    10ec:	ef 93       	push	r30
    10ee:	ff 93       	push	r31
	ptr_CallList[INT_NUM_2]();
    10f0:	e0 91 05 0a 	lds	r30, 0x0A05	; 0x800a05 <ptr_CallList+0x4>
    10f4:	f0 91 06 0a 	lds	r31, 0x0A06	; 0x800a06 <ptr_CallList+0x5>
    10f8:	09 95       	icall
}
    10fa:	ff 91       	pop	r31
    10fc:	ef 91       	pop	r30
    10fe:	bf 91       	pop	r27
    1100:	af 91       	pop	r26
    1102:	9f 91       	pop	r25
    1104:	8f 91       	pop	r24
    1106:	7f 91       	pop	r23
    1108:	6f 91       	pop	r22
    110a:	5f 91       	pop	r21
    110c:	4f 91       	pop	r20
    110e:	3f 91       	pop	r19
    1110:	2f 91       	pop	r18
    1112:	0f 90       	pop	r0
    1114:	0b be       	out	0x3b, r0	; 59
    1116:	0f 90       	pop	r0
    1118:	0f be       	out	0x3f, r0	; 63
    111a:	0f 90       	pop	r0
    111c:	1f 90       	pop	r1
    111e:	18 95       	reti

00001120 <__vector_4>:
ISR(INT3_vect)
{
    1120:	1f 92       	push	r1
    1122:	0f 92       	push	r0
    1124:	0f b6       	in	r0, 0x3f	; 63
    1126:	0f 92       	push	r0
    1128:	11 24       	eor	r1, r1
    112a:	0b b6       	in	r0, 0x3b	; 59
    112c:	0f 92       	push	r0
    112e:	2f 93       	push	r18
    1130:	3f 93       	push	r19
    1132:	4f 93       	push	r20
    1134:	5f 93       	push	r21
    1136:	6f 93       	push	r22
    1138:	7f 93       	push	r23
    113a:	8f 93       	push	r24
    113c:	9f 93       	push	r25
    113e:	af 93       	push	r26
    1140:	bf 93       	push	r27
    1142:	ef 93       	push	r30
    1144:	ff 93       	push	r31
	ptr_CallList[INT_NUM_3]();
    1146:	e0 91 07 0a 	lds	r30, 0x0A07	; 0x800a07 <ptr_CallList+0x6>
    114a:	f0 91 08 0a 	lds	r31, 0x0A08	; 0x800a08 <ptr_CallList+0x7>
    114e:	09 95       	icall
    1150:	ff 91       	pop	r31
    1152:	ef 91       	pop	r30
    1154:	bf 91       	pop	r27
    1156:	af 91       	pop	r26
    1158:	9f 91       	pop	r25
    115a:	8f 91       	pop	r24
    115c:	7f 91       	pop	r23
    115e:	6f 91       	pop	r22
    1160:	5f 91       	pop	r21
    1162:	4f 91       	pop	r20
    1164:	3f 91       	pop	r19
    1166:	2f 91       	pop	r18
    1168:	0f 90       	pop	r0
    116a:	0b be       	out	0x3b, r0	; 59
    116c:	0f 90       	pop	r0
    116e:	0f be       	out	0x3f, r0	; 63
    1170:	0f 90       	pop	r0
    1172:	1f 90       	pop	r1
    1174:	18 95       	reti

00001176 <Timer0_Start>:
	}
	else
	{
		OCR0 = 0;
	}
}
    1176:	83 b7       	in	r24, 0x33	; 51
    1178:	8e 7f       	andi	r24, 0xFE	; 254
    117a:	83 bf       	out	0x33, r24	; 51
    117c:	83 b7       	in	r24, 0x33	; 51
    117e:	82 60       	ori	r24, 0x02	; 2
    1180:	83 bf       	out	0x33, r24	; 51
    1182:	83 b7       	in	r24, 0x33	; 51
    1184:	8b 7f       	andi	r24, 0xFB	; 251
    1186:	83 bf       	out	0x33, r24	; 51
    1188:	08 95       	ret

0000118a <Timer0_Stop>:
    118a:	83 b7       	in	r24, 0x33	; 51
    118c:	8e 7f       	andi	r24, 0xFE	; 254
    118e:	83 bf       	out	0x33, r24	; 51
    1190:	83 b7       	in	r24, 0x33	; 51
    1192:	8d 7f       	andi	r24, 0xFD	; 253
    1194:	83 bf       	out	0x33, r24	; 51
    1196:	83 b7       	in	r24, 0x33	; 51
    1198:	8b 7f       	andi	r24, 0xFB	; 251
    119a:	83 bf       	out	0x33, r24	; 51
    119c:	08 95       	ret

0000119e <Timer0_Init>:
    119e:	81 30       	cpi	r24, 0x01	; 1
    11a0:	81 f0       	breq	.+32     	; 0x11c2 <Timer0_Init+0x24>
    11a2:	28 f0       	brcs	.+10     	; 0x11ae <Timer0_Init+0x10>
    11a4:	82 30       	cpi	r24, 0x02	; 2
    11a6:	d1 f0       	breq	.+52     	; 0x11dc <Timer0_Init+0x3e>
    11a8:	83 30       	cpi	r24, 0x03	; 3
    11aa:	29 f1       	breq	.+74     	; 0x11f6 <Timer0_Init+0x58>
    11ac:	30 c0       	rjmp	.+96     	; 0x120e <Timer0_Init+0x70>
    11ae:	83 b7       	in	r24, 0x33	; 51
    11b0:	8f 7b       	andi	r24, 0xBF	; 191
    11b2:	83 bf       	out	0x33, r24	; 51
    11b4:	83 b7       	in	r24, 0x33	; 51
    11b6:	87 7f       	andi	r24, 0xF7	; 247
    11b8:	83 bf       	out	0x33, r24	; 51
    11ba:	87 b7       	in	r24, 0x37	; 55
    11bc:	81 60       	ori	r24, 0x01	; 1
    11be:	87 bf       	out	0x37, r24	; 55
    11c0:	26 c0       	rjmp	.+76     	; 0x120e <Timer0_Init+0x70>
    11c2:	83 b7       	in	r24, 0x33	; 51
    11c4:	8f 7b       	andi	r24, 0xBF	; 191
    11c6:	83 bf       	out	0x33, r24	; 51
    11c8:	83 b7       	in	r24, 0x33	; 51
    11ca:	88 60       	ori	r24, 0x08	; 8
    11cc:	83 bf       	out	0x33, r24	; 51
    11ce:	83 b7       	in	r24, 0x33	; 51
    11d0:	80 61       	ori	r24, 0x10	; 16
    11d2:	83 bf       	out	0x33, r24	; 51
    11d4:	83 b7       	in	r24, 0x33	; 51
    11d6:	8f 7d       	andi	r24, 0xDF	; 223
    11d8:	83 bf       	out	0x33, r24	; 51
    11da:	19 c0       	rjmp	.+50     	; 0x120e <Timer0_Init+0x70>
    11dc:	83 b7       	in	r24, 0x33	; 51
    11de:	80 64       	ori	r24, 0x40	; 64
    11e0:	83 bf       	out	0x33, r24	; 51
    11e2:	83 b7       	in	r24, 0x33	; 51
    11e4:	88 60       	ori	r24, 0x08	; 8
    11e6:	83 bf       	out	0x33, r24	; 51
    11e8:	83 b7       	in	r24, 0x33	; 51
    11ea:	8f 7e       	andi	r24, 0xEF	; 239
    11ec:	83 bf       	out	0x33, r24	; 51
    11ee:	83 b7       	in	r24, 0x33	; 51
    11f0:	80 62       	ori	r24, 0x20	; 32
    11f2:	83 bf       	out	0x33, r24	; 51
    11f4:	0c c0       	rjmp	.+24     	; 0x120e <Timer0_Init+0x70>
    11f6:	83 b7       	in	r24, 0x33	; 51
    11f8:	80 64       	ori	r24, 0x40	; 64
    11fa:	83 bf       	out	0x33, r24	; 51
    11fc:	83 b7       	in	r24, 0x33	; 51
    11fe:	87 7f       	andi	r24, 0xF7	; 247
    1200:	83 bf       	out	0x33, r24	; 51
    1202:	83 b7       	in	r24, 0x33	; 51
    1204:	8f 7e       	andi	r24, 0xEF	; 239
    1206:	83 bf       	out	0x33, r24	; 51
    1208:	83 b7       	in	r24, 0x33	; 51
    120a:	80 62       	ori	r24, 0x20	; 32
    120c:	83 bf       	out	0x33, r24	; 51
    120e:	bd cf       	rjmp	.-134    	; 0x118a <Timer0_Stop>
    1210:	08 95       	ret

00001212 <Timer0_ResetCounters>:
    1212:	12 be       	out	0x32, r1	; 50
    1214:	10 92 9b 03 	sts	0x039B, r1	; 0x80039b <OverFlows>
    1218:	10 92 9c 03 	sts	0x039C, r1	; 0x80039c <OverFlows+0x1>
    121c:	10 92 9d 03 	sts	0x039D, r1	; 0x80039d <OverFlows+0x2>
    1220:	10 92 9e 03 	sts	0x039E, r1	; 0x80039e <OverFlows+0x3>
    1224:	08 95       	ret

00001226 <Timer0_SetNotification>:

/*    send any notification after delay   */
void Timer0_SetNotification(void (*ptrFun)(void) ,INT_32U notifyDelay)
{
    1226:	cf 92       	push	r12
    1228:	df 92       	push	r13
    122a:	ef 92       	push	r14
    122c:	ff 92       	push	r15
    122e:	6a 01       	movw	r12, r20
    1230:	7b 01       	movw	r14, r22
	notifier = ptrFun;
    1232:	90 93 0a 0a 	sts	0x0A0A, r25	; 0x800a0a <notifier+0x1>
    1236:	80 93 09 0a 	sts	0x0A09, r24	; 0x800a09 <notifier>
	notifiertime = notifyDelay;
    123a:	40 93 93 03 	sts	0x0393, r20	; 0x800393 <notifiertime>
    123e:	50 93 94 03 	sts	0x0394, r21	; 0x800394 <notifiertime+0x1>
    1242:	60 93 95 03 	sts	0x0395, r22	; 0x800395 <notifiertime+0x2>
    1246:	70 93 96 03 	sts	0x0396, r23	; 0x800396 <notifiertime+0x3>
	Timer0_ResetCounters();
    124a:	e3 df       	rcall	.-58     	; 0x1212 <Timer0_ResetCounters>
	//calc counters
	TCNT0 = 256 - ((notifyDelay*1000)%256 - 1);
    124c:	81 e0       	ldi	r24, 0x01	; 1
    124e:	98 e1       	ldi	r25, 0x18	; 24
    1250:	c9 9e       	mul	r12, r25
    1252:	80 0d       	add	r24, r0
    1254:	11 24       	eor	r1, r1
    1256:	82 bf       	out	0x32, r24	; 50
	CalcOverFlows = ((notifyDelay*1000)/256 + 1);
    1258:	a8 ee       	ldi	r26, 0xE8	; 232
    125a:	b3 e0       	ldi	r27, 0x03	; 3
    125c:	a7 01       	movw	r20, r14
    125e:	96 01       	movw	r18, r12
    1260:	0e 94 02 18 	call	0x3004	; 0x3004 <__muluhisi3>
    1264:	bb 27       	eor	r27, r27
    1266:	a9 2f       	mov	r26, r25
    1268:	98 2f       	mov	r25, r24
    126a:	87 2f       	mov	r24, r23
    126c:	01 96       	adiw	r24, 0x01	; 1
    126e:	a1 1d       	adc	r26, r1
    1270:	b1 1d       	adc	r27, r1
    1272:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <CalcOverFlows>
    1276:	90 93 98 03 	sts	0x0398, r25	; 0x800398 <CalcOverFlows+0x1>
    127a:	a0 93 99 03 	sts	0x0399, r26	; 0x800399 <CalcOverFlows+0x2>
    127e:	b0 93 9a 03 	sts	0x039A, r27	; 0x80039a <CalcOverFlows+0x3>
	Timer0_Start();
    1282:	79 df       	rcall	.-270    	; 0x1176 <Timer0_Start>
}
    1284:	ff 90       	pop	r15
    1286:	ef 90       	pop	r14
    1288:	df 90       	pop	r13
    128a:	cf 90       	pop	r12
    128c:	08 95       	ret

0000128e <__vector_16>:


ISR(TIMER0_OVF_vect)
{
    128e:	1f 92       	push	r1
    1290:	0f 92       	push	r0
    1292:	0f b6       	in	r0, 0x3f	; 63
    1294:	0f 92       	push	r0
    1296:	11 24       	eor	r1, r1
    1298:	0b b6       	in	r0, 0x3b	; 59
    129a:	0f 92       	push	r0
    129c:	2f 93       	push	r18
    129e:	3f 93       	push	r19
    12a0:	4f 93       	push	r20
    12a2:	5f 93       	push	r21
    12a4:	6f 93       	push	r22
    12a6:	7f 93       	push	r23
    12a8:	8f 93       	push	r24
    12aa:	9f 93       	push	r25
    12ac:	af 93       	push	r26
    12ae:	bf 93       	push	r27
    12b0:	ef 93       	push	r30
    12b2:	ff 93       	push	r31
	OverFlows++;
    12b4:	80 91 9b 03 	lds	r24, 0x039B	; 0x80039b <OverFlows>
    12b8:	90 91 9c 03 	lds	r25, 0x039C	; 0x80039c <OverFlows+0x1>
    12bc:	a0 91 9d 03 	lds	r26, 0x039D	; 0x80039d <OverFlows+0x2>
    12c0:	b0 91 9e 03 	lds	r27, 0x039E	; 0x80039e <OverFlows+0x3>
    12c4:	01 96       	adiw	r24, 0x01	; 1
    12c6:	a1 1d       	adc	r26, r1
    12c8:	b1 1d       	adc	r27, r1
    12ca:	80 93 9b 03 	sts	0x039B, r24	; 0x80039b <OverFlows>
    12ce:	90 93 9c 03 	sts	0x039C, r25	; 0x80039c <OverFlows+0x1>
    12d2:	a0 93 9d 03 	sts	0x039D, r26	; 0x80039d <OverFlows+0x2>
    12d6:	b0 93 9e 03 	sts	0x039E, r27	; 0x80039e <OverFlows+0x3>
	
if(OverFlows==CalcOverFlows)
    12da:	40 91 9b 03 	lds	r20, 0x039B	; 0x80039b <OverFlows>
    12de:	50 91 9c 03 	lds	r21, 0x039C	; 0x80039c <OverFlows+0x1>
    12e2:	60 91 9d 03 	lds	r22, 0x039D	; 0x80039d <OverFlows+0x2>
    12e6:	70 91 9e 03 	lds	r23, 0x039E	; 0x80039e <OverFlows+0x3>
    12ea:	80 91 97 03 	lds	r24, 0x0397	; 0x800397 <CalcOverFlows>
    12ee:	90 91 98 03 	lds	r25, 0x0398	; 0x800398 <CalcOverFlows+0x1>
    12f2:	a0 91 99 03 	lds	r26, 0x0399	; 0x800399 <CalcOverFlows+0x2>
    12f6:	b0 91 9a 03 	lds	r27, 0x039A	; 0x80039a <CalcOverFlows+0x3>
    12fa:	48 17       	cp	r20, r24
    12fc:	59 07       	cpc	r21, r25
    12fe:	6a 07       	cpc	r22, r26
    1300:	7b 07       	cpc	r23, r27
    1302:	d9 f4       	brne	.+54     	; 0x133a <__vector_16+0xac>
{
	notifier();
    1304:	e0 91 09 0a 	lds	r30, 0x0A09	; 0x800a09 <notifier>
    1308:	f0 91 0a 0a 	lds	r31, 0x0A0A	; 0x800a0a <notifier+0x1>
    130c:	09 95       	icall
	OverFlows = 0;
    130e:	10 92 9b 03 	sts	0x039B, r1	; 0x80039b <OverFlows>
    1312:	10 92 9c 03 	sts	0x039C, r1	; 0x80039c <OverFlows+0x1>
    1316:	10 92 9d 03 	sts	0x039D, r1	; 0x80039d <OverFlows+0x2>
    131a:	10 92 9e 03 	sts	0x039E, r1	; 0x80039e <OverFlows+0x3>
	TCNT0 = 256 - ((notifiertime*1000)%256 - 1);
    131e:	40 91 93 03 	lds	r20, 0x0393	; 0x800393 <notifiertime>
    1322:	50 91 94 03 	lds	r21, 0x0394	; 0x800394 <notifiertime+0x1>
    1326:	60 91 95 03 	lds	r22, 0x0395	; 0x800395 <notifiertime+0x2>
    132a:	70 91 96 03 	lds	r23, 0x0396	; 0x800396 <notifiertime+0x3>
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	98 e1       	ldi	r25, 0x18	; 24
    1332:	49 9f       	mul	r20, r25
    1334:	80 0d       	add	r24, r0
    1336:	11 24       	eor	r1, r1
    1338:	82 bf       	out	0x32, r24	; 50
}
    133a:	ff 91       	pop	r31
    133c:	ef 91       	pop	r30
    133e:	bf 91       	pop	r27
    1340:	af 91       	pop	r26
    1342:	9f 91       	pop	r25
    1344:	8f 91       	pop	r24
    1346:	7f 91       	pop	r23
    1348:	6f 91       	pop	r22
    134a:	5f 91       	pop	r21
    134c:	4f 91       	pop	r20
    134e:	3f 91       	pop	r19
    1350:	2f 91       	pop	r18
    1352:	0f 90       	pop	r0
    1354:	0b be       	out	0x3b, r0	; 59
    1356:	0f 90       	pop	r0
    1358:	0f be       	out	0x3f, r0	; 63
    135a:	0f 90       	pop	r0
    135c:	1f 90       	pop	r1
    135e:	18 95       	reti

00001360 <Timer3_Start>:
	Timer3_ResetCounters();
	//calc counters
	TCNT0 = 256 - ((notifyDelay*1000)%256 - 1);
	CalcOverFlows = ((notifyDelay*1000)/256 + 1);
	Timer3_Start();
}
    1360:	ea e8       	ldi	r30, 0x8A	; 138
    1362:	f0 e0       	ldi	r31, 0x00	; 0
    1364:	80 81       	ld	r24, Z
    1366:	8e 7f       	andi	r24, 0xFE	; 254
    1368:	80 83       	st	Z, r24
    136a:	80 81       	ld	r24, Z
    136c:	82 60       	ori	r24, 0x02	; 2
    136e:	80 83       	st	Z, r24
    1370:	80 81       	ld	r24, Z
    1372:	8b 7f       	andi	r24, 0xFB	; 251
    1374:	80 83       	st	Z, r24
    1376:	08 95       	ret

00001378 <Timer3_Stop>:
    1378:	ea e8       	ldi	r30, 0x8A	; 138
    137a:	f0 e0       	ldi	r31, 0x00	; 0
    137c:	80 81       	ld	r24, Z
    137e:	8e 7f       	andi	r24, 0xFE	; 254
    1380:	80 83       	st	Z, r24
    1382:	80 81       	ld	r24, Z
    1384:	8d 7f       	andi	r24, 0xFD	; 253
    1386:	80 83       	st	Z, r24
    1388:	80 81       	ld	r24, Z
    138a:	8b 7f       	andi	r24, 0xFB	; 251
    138c:	80 83       	st	Z, r24
    138e:	08 95       	ret

00001390 <Timer3_Init>:
    1390:	13 9a       	sbi	0x02, 3	; 2
    1392:	81 30       	cpi	r24, 0x01	; 1
    1394:	91 f0       	breq	.+36     	; 0x13ba <Timer3_Init+0x2a>
    1396:	28 f0       	brcs	.+10     	; 0x13a2 <Timer3_Init+0x12>
    1398:	82 30       	cpi	r24, 0x02	; 2
    139a:	e1 f0       	breq	.+56     	; 0x13d4 <Timer3_Init+0x44>
    139c:	83 30       	cpi	r24, 0x03	; 3
    139e:	b9 f1       	breq	.+110    	; 0x140e <Timer3_Init+0x7e>
    13a0:	42 c0       	rjmp	.+132    	; 0x1426 <Timer3_Init+0x96>
    13a2:	eb e8       	ldi	r30, 0x8B	; 139
    13a4:	f0 e0       	ldi	r31, 0x00	; 0
    13a6:	80 81       	ld	r24, Z
    13a8:	8f 7b       	andi	r24, 0xBF	; 191
    13aa:	80 83       	st	Z, r24
    13ac:	80 81       	ld	r24, Z
    13ae:	87 7f       	andi	r24, 0xF7	; 247
    13b0:	80 83       	st	Z, r24
    13b2:	87 b7       	in	r24, 0x37	; 55
    13b4:	81 60       	ori	r24, 0x01	; 1
    13b6:	87 bf       	out	0x37, r24	; 55
    13b8:	36 c0       	rjmp	.+108    	; 0x1426 <Timer3_Init+0x96>
    13ba:	83 b7       	in	r24, 0x33	; 51
    13bc:	8f 7b       	andi	r24, 0xBF	; 191
    13be:	83 bf       	out	0x33, r24	; 51
    13c0:	83 b7       	in	r24, 0x33	; 51
    13c2:	88 60       	ori	r24, 0x08	; 8
    13c4:	83 bf       	out	0x33, r24	; 51
    13c6:	83 b7       	in	r24, 0x33	; 51
    13c8:	80 61       	ori	r24, 0x10	; 16
    13ca:	83 bf       	out	0x33, r24	; 51
    13cc:	83 b7       	in	r24, 0x33	; 51
    13ce:	8f 7d       	andi	r24, 0xDF	; 223
    13d0:	83 bf       	out	0x33, r24	; 51
    13d2:	29 c0       	rjmp	.+82     	; 0x1426 <Timer3_Init+0x96>
    13d4:	eb e8       	ldi	r30, 0x8B	; 139
    13d6:	f0 e0       	ldi	r31, 0x00	; 0
    13d8:	80 81       	ld	r24, Z
    13da:	8e 7f       	andi	r24, 0xFE	; 254
    13dc:	80 83       	st	Z, r24
    13de:	80 81       	ld	r24, Z
    13e0:	82 60       	ori	r24, 0x02	; 2
    13e2:	80 83       	st	Z, r24
    13e4:	80 81       	ld	r24, Z
    13e6:	8f 7b       	andi	r24, 0xBF	; 191
    13e8:	80 83       	st	Z, r24
    13ea:	80 81       	ld	r24, Z
    13ec:	80 68       	ori	r24, 0x80	; 128
    13ee:	80 83       	st	Z, r24
    13f0:	ea e8       	ldi	r30, 0x8A	; 138
    13f2:	f0 e0       	ldi	r31, 0x00	; 0
    13f4:	80 81       	ld	r24, Z
    13f6:	88 60       	ori	r24, 0x08	; 8
    13f8:	80 83       	st	Z, r24
    13fa:	80 81       	ld	r24, Z
    13fc:	80 61       	ori	r24, 0x10	; 16
    13fe:	80 83       	st	Z, r24
    1400:	8f ef       	ldi	r24, 0xFF	; 255
    1402:	90 e0       	ldi	r25, 0x00	; 0
    1404:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    1408:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    140c:	0c c0       	rjmp	.+24     	; 0x1426 <Timer3_Init+0x96>
    140e:	83 b7       	in	r24, 0x33	; 51
    1410:	80 64       	ori	r24, 0x40	; 64
    1412:	83 bf       	out	0x33, r24	; 51
    1414:	83 b7       	in	r24, 0x33	; 51
    1416:	87 7f       	andi	r24, 0xF7	; 247
    1418:	83 bf       	out	0x33, r24	; 51
    141a:	83 b7       	in	r24, 0x33	; 51
    141c:	8f 7e       	andi	r24, 0xEF	; 239
    141e:	83 bf       	out	0x33, r24	; 51
    1420:	83 b7       	in	r24, 0x33	; 51
    1422:	80 62       	ori	r24, 0x20	; 32
    1424:	83 bf       	out	0x33, r24	; 51
    1426:	a8 cf       	rjmp	.-176    	; 0x1378 <Timer3_Stop>
    1428:	08 95       	ret

0000142a <Timer3_SetDuty>:
    142a:	28 2f       	mov	r18, r24
    142c:	30 e0       	ldi	r19, 0x00	; 0
    142e:	af ef       	ldi	r26, 0xFF	; 255
    1430:	b0 e0       	ldi	r27, 0x00	; 0
    1432:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <__umulhisi3>
    1436:	24 e6       	ldi	r18, 0x64	; 100
    1438:	30 e0       	ldi	r19, 0x00	; 0
    143a:	40 e0       	ldi	r20, 0x00	; 0
    143c:	50 e0       	ldi	r21, 0x00	; 0
    143e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <__udivmodsi4>
    1442:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
    1446:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
    144a:	08 95       	ret

0000144c <__vector_29>:


ISR(TIMER3_OVF_vect)
{
    144c:	1f 92       	push	r1
    144e:	0f 92       	push	r0
    1450:	0f b6       	in	r0, 0x3f	; 63
    1452:	0f 92       	push	r0
    1454:	11 24       	eor	r1, r1
    1456:	0b b6       	in	r0, 0x3b	; 59
    1458:	0f 92       	push	r0
    145a:	2f 93       	push	r18
    145c:	3f 93       	push	r19
    145e:	4f 93       	push	r20
    1460:	5f 93       	push	r21
    1462:	6f 93       	push	r22
    1464:	7f 93       	push	r23
    1466:	8f 93       	push	r24
    1468:	9f 93       	push	r25
    146a:	af 93       	push	r26
    146c:	bf 93       	push	r27
    146e:	ef 93       	push	r30
    1470:	ff 93       	push	r31
	OverFlows++;
    1472:	80 91 a7 03 	lds	r24, 0x03A7	; 0x8003a7 <OverFlows>
    1476:	90 91 a8 03 	lds	r25, 0x03A8	; 0x8003a8 <OverFlows+0x1>
    147a:	a0 91 a9 03 	lds	r26, 0x03A9	; 0x8003a9 <OverFlows+0x2>
    147e:	b0 91 aa 03 	lds	r27, 0x03AA	; 0x8003aa <OverFlows+0x3>
    1482:	01 96       	adiw	r24, 0x01	; 1
    1484:	a1 1d       	adc	r26, r1
    1486:	b1 1d       	adc	r27, r1
    1488:	80 93 a7 03 	sts	0x03A7, r24	; 0x8003a7 <OverFlows>
    148c:	90 93 a8 03 	sts	0x03A8, r25	; 0x8003a8 <OverFlows+0x1>
    1490:	a0 93 a9 03 	sts	0x03A9, r26	; 0x8003a9 <OverFlows+0x2>
    1494:	b0 93 aa 03 	sts	0x03AA, r27	; 0x8003aa <OverFlows+0x3>
	
if(OverFlows==CalcOverFlows)
    1498:	40 91 a7 03 	lds	r20, 0x03A7	; 0x8003a7 <OverFlows>
    149c:	50 91 a8 03 	lds	r21, 0x03A8	; 0x8003a8 <OverFlows+0x1>
    14a0:	60 91 a9 03 	lds	r22, 0x03A9	; 0x8003a9 <OverFlows+0x2>
    14a4:	70 91 aa 03 	lds	r23, 0x03AA	; 0x8003aa <OverFlows+0x3>
    14a8:	80 91 a3 03 	lds	r24, 0x03A3	; 0x8003a3 <CalcOverFlows>
    14ac:	90 91 a4 03 	lds	r25, 0x03A4	; 0x8003a4 <CalcOverFlows+0x1>
    14b0:	a0 91 a5 03 	lds	r26, 0x03A5	; 0x8003a5 <CalcOverFlows+0x2>
    14b4:	b0 91 a6 03 	lds	r27, 0x03A6	; 0x8003a6 <CalcOverFlows+0x3>
    14b8:	48 17       	cp	r20, r24
    14ba:	59 07       	cpc	r21, r25
    14bc:	6a 07       	cpc	r22, r26
    14be:	7b 07       	cpc	r23, r27
    14c0:	d9 f4       	brne	.+54     	; 0x14f8 <__vector_29+0xac>
{
	notifier();
    14c2:	e0 91 09 0a 	lds	r30, 0x0A09	; 0x800a09 <notifier>
    14c6:	f0 91 0a 0a 	lds	r31, 0x0A0A	; 0x800a0a <notifier+0x1>
    14ca:	09 95       	icall
	OverFlows = 0;
    14cc:	10 92 a7 03 	sts	0x03A7, r1	; 0x8003a7 <OverFlows>
    14d0:	10 92 a8 03 	sts	0x03A8, r1	; 0x8003a8 <OverFlows+0x1>
    14d4:	10 92 a9 03 	sts	0x03A9, r1	; 0x8003a9 <OverFlows+0x2>
    14d8:	10 92 aa 03 	sts	0x03AA, r1	; 0x8003aa <OverFlows+0x3>
	TCNT0 = 256 - ((notifiertime*1000)%256 - 1);
    14dc:	40 91 9f 03 	lds	r20, 0x039F	; 0x80039f <notifiertime>
    14e0:	50 91 a0 03 	lds	r21, 0x03A0	; 0x8003a0 <notifiertime+0x1>
    14e4:	60 91 a1 03 	lds	r22, 0x03A1	; 0x8003a1 <notifiertime+0x2>
    14e8:	70 91 a2 03 	lds	r23, 0x03A2	; 0x8003a2 <notifiertime+0x3>
    14ec:	81 e0       	ldi	r24, 0x01	; 1
    14ee:	98 e1       	ldi	r25, 0x18	; 24
    14f0:	49 9f       	mul	r20, r25
    14f2:	80 0d       	add	r24, r0
    14f4:	11 24       	eor	r1, r1
    14f6:	82 bf       	out	0x32, r24	; 50
}
    14f8:	ff 91       	pop	r31
    14fa:	ef 91       	pop	r30
    14fc:	bf 91       	pop	r27
    14fe:	af 91       	pop	r26
    1500:	9f 91       	pop	r25
    1502:	8f 91       	pop	r24
    1504:	7f 91       	pop	r23
    1506:	6f 91       	pop	r22
    1508:	5f 91       	pop	r21
    150a:	4f 91       	pop	r20
    150c:	3f 91       	pop	r19
    150e:	2f 91       	pop	r18
    1510:	0f 90       	pop	r0
    1512:	0b be       	out	0x3b, r0	; 59
    1514:	0f 90       	pop	r0
    1516:	0f be       	out	0x3f, r0	; 63
    1518:	0f 90       	pop	r0
    151a:	1f 90       	pop	r1
    151c:	18 95       	reti

0000151e <UART_Init>:
		break;
		case UART_1:
		SETBIT(UCSR1B,RXCIE);
		break;
	}
	ptr_CallList[uartType]= ptr_CallBack_Fun;
    151e:	cf 93       	push	r28
    1520:	c8 2f       	mov	r28, r24
    1522:	db 01       	movw	r26, r22
    1524:	ca 01       	movw	r24, r20
    1526:	88 0f       	add	r24, r24
    1528:	99 1f       	adc	r25, r25
    152a:	aa 1f       	adc	r26, r26
    152c:	bb 1f       	adc	r27, r27
    152e:	88 0f       	add	r24, r24
    1530:	99 1f       	adc	r25, r25
    1532:	aa 1f       	adc	r26, r26
    1534:	bb 1f       	adc	r27, r27
    1536:	9c 01       	movw	r18, r24
    1538:	ad 01       	movw	r20, r26
    153a:	22 0f       	add	r18, r18
    153c:	33 1f       	adc	r19, r19
    153e:	44 1f       	adc	r20, r20
    1540:	55 1f       	adc	r21, r21
    1542:	22 0f       	add	r18, r18
    1544:	33 1f       	adc	r19, r19
    1546:	44 1f       	adc	r20, r20
    1548:	55 1f       	adc	r21, r21
    154a:	60 e0       	ldi	r22, 0x00	; 0
    154c:	72 e1       	ldi	r23, 0x12	; 18
    154e:	8a e7       	ldi	r24, 0x7A	; 122
    1550:	90 e0       	ldi	r25, 0x00	; 0
    1552:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <__udivmodsi4>
    1556:	ba 01       	movw	r22, r20
    1558:	a9 01       	movw	r20, r18
    155a:	41 50       	subi	r20, 0x01	; 1
    155c:	51 09       	sbc	r21, r1
    155e:	61 09       	sbc	r22, r1
    1560:	71 09       	sbc	r23, r1
    1562:	cc 23       	and	r28, r28
    1564:	19 f0       	breq	.+6      	; 0x156c <UART_Init+0x4e>
    1566:	c1 30       	cpi	r28, 0x01	; 1
    1568:	71 f0       	breq	.+28     	; 0x1586 <UART_Init+0x68>
    156a:	1b c0       	rjmp	.+54     	; 0x15a2 <UART_Init+0x84>
    156c:	bb 27       	eor	r27, r27
    156e:	a7 2f       	mov	r26, r23
    1570:	96 2f       	mov	r25, r22
    1572:	85 2f       	mov	r24, r21
    1574:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
    1578:	49 b9       	out	0x09, r20	; 9
    157a:	88 e1       	ldi	r24, 0x18	; 24
    157c:	8a b9       	out	0x0a, r24	; 10
    157e:	86 e0       	ldi	r24, 0x06	; 6
    1580:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
    1584:	0e c0       	rjmp	.+28     	; 0x15a2 <UART_Init+0x84>
    1586:	bb 27       	eor	r27, r27
    1588:	a7 2f       	mov	r26, r23
    158a:	96 2f       	mov	r25, r22
    158c:	85 2f       	mov	r24, r21
    158e:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
    1592:	40 93 99 00 	sts	0x0099, r20	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
    1596:	88 e1       	ldi	r24, 0x18	; 24
    1598:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
    159c:	86 e0       	ldi	r24, 0x06	; 6
    159e:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    15a2:	cf 91       	pop	r28
    15a4:	08 95       	ret

000015a6 <UART_SendByte>:
    15a6:	88 23       	and	r24, r24
    15a8:	19 f0       	breq	.+6      	; 0x15b0 <UART_SendByte+0xa>
    15aa:	81 30       	cpi	r24, 0x01	; 1
    15ac:	29 f0       	breq	.+10     	; 0x15b8 <UART_SendByte+0x12>
    15ae:	08 95       	ret
    15b0:	5d 9b       	sbis	0x0b, 5	; 11
    15b2:	fe cf       	rjmp	.-4      	; 0x15b0 <UART_SendByte+0xa>
    15b4:	6c b9       	out	0x0c, r22	; 12
    15b6:	08 95       	ret
    15b8:	eb e9       	ldi	r30, 0x9B	; 155
    15ba:	f0 e0       	ldi	r31, 0x00	; 0
    15bc:	80 81       	ld	r24, Z
    15be:	85 ff       	sbrs	r24, 5
    15c0:	fd cf       	rjmp	.-6      	; 0x15bc <UART_SendByte+0x16>
    15c2:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
    15c6:	08 95       	ret

000015c8 <UART_Receive>:
    15c8:	88 23       	and	r24, r24
    15ca:	19 f0       	breq	.+6      	; 0x15d2 <UART_Receive+0xa>
    15cc:	81 30       	cpi	r24, 0x01	; 1
    15ce:	29 f0       	breq	.+10     	; 0x15da <UART_Receive+0x12>
    15d0:	0c c0       	rjmp	.+24     	; 0x15ea <UART_Receive+0x22>
    15d2:	5f 9b       	sbis	0x0b, 7	; 11
    15d4:	fe cf       	rjmp	.-4      	; 0x15d2 <UART_Receive+0xa>
    15d6:	8c b1       	in	r24, 0x0c	; 12
    15d8:	08 95       	ret
    15da:	eb e9       	ldi	r30, 0x9B	; 155
    15dc:	f0 e0       	ldi	r31, 0x00	; 0
    15de:	80 81       	ld	r24, Z
    15e0:	88 23       	and	r24, r24
    15e2:	ec f7       	brge	.-6      	; 0x15de <UART_Receive+0x16>
    15e4:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
    15e8:	08 95       	ret
    15ea:	80 e0       	ldi	r24, 0x00	; 0
    15ec:	08 95       	ret

000015ee <UART_SendString>:
    15ee:	1f 93       	push	r17
    15f0:	cf 93       	push	r28
    15f2:	df 93       	push	r29
    15f4:	eb 01       	movw	r28, r22
    15f6:	68 81       	ld	r22, Y
    15f8:	66 23       	and	r22, r22
    15fa:	39 f0       	breq	.+14     	; 0x160a <UART_SendString+0x1c>
    15fc:	18 2f       	mov	r17, r24
    15fe:	21 96       	adiw	r28, 0x01	; 1
    1600:	81 2f       	mov	r24, r17
    1602:	d1 df       	rcall	.-94     	; 0x15a6 <UART_SendByte>
    1604:	69 91       	ld	r22, Y+
    1606:	61 11       	cpse	r22, r1
    1608:	fb cf       	rjmp	.-10     	; 0x1600 <UART_SendString+0x12>
    160a:	df 91       	pop	r29
    160c:	cf 91       	pop	r28
    160e:	1f 91       	pop	r17
    1610:	08 95       	ret

00001612 <UART_RecieveByte_Unblocked>:
    1612:	88 23       	and	r24, r24
    1614:	19 f0       	breq	.+6      	; 0x161c <UART_RecieveByte_Unblocked+0xa>
    1616:	81 30       	cpi	r24, 0x01	; 1
    1618:	41 f0       	breq	.+16     	; 0x162a <UART_RecieveByte_Unblocked+0x18>
    161a:	11 c0       	rjmp	.+34     	; 0x163e <UART_RecieveByte_Unblocked+0x2c>
    161c:	5f 9b       	sbis	0x0b, 7	; 11
    161e:	11 c0       	rjmp	.+34     	; 0x1642 <UART_RecieveByte_Unblocked+0x30>
    1620:	8c b1       	in	r24, 0x0c	; 12
    1622:	fb 01       	movw	r30, r22
    1624:	80 83       	st	Z, r24
    1626:	81 e0       	ldi	r24, 0x01	; 1
    1628:	08 95       	ret
    162a:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    162e:	88 23       	and	r24, r24
    1630:	54 f4       	brge	.+20     	; 0x1646 <UART_RecieveByte_Unblocked+0x34>
    1632:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
    1636:	fb 01       	movw	r30, r22
    1638:	80 83       	st	Z, r24
    163a:	81 e0       	ldi	r24, 0x01	; 1
    163c:	08 95       	ret
    163e:	80 e0       	ldi	r24, 0x00	; 0
    1640:	08 95       	ret
    1642:	80 e0       	ldi	r24, 0x00	; 0
    1644:	08 95       	ret
    1646:	80 e0       	ldi	r24, 0x00	; 0
    1648:	08 95       	ret

0000164a <__vector_18>:
}

ISR(USART0_RX_vect)
{
    164a:	1f 92       	push	r1
    164c:	0f 92       	push	r0
    164e:	0f b6       	in	r0, 0x3f	; 63
    1650:	0f 92       	push	r0
    1652:	11 24       	eor	r1, r1
    1654:	0b b6       	in	r0, 0x3b	; 59
    1656:	0f 92       	push	r0
    1658:	2f 93       	push	r18
    165a:	3f 93       	push	r19
    165c:	4f 93       	push	r20
    165e:	5f 93       	push	r21
    1660:	6f 93       	push	r22
    1662:	7f 93       	push	r23
    1664:	8f 93       	push	r24
    1666:	9f 93       	push	r25
    1668:	af 93       	push	r26
    166a:	bf 93       	push	r27
    166c:	ef 93       	push	r30
    166e:	ff 93       	push	r31
	ptr_CallList[UART_0]();
    1670:	e0 91 01 0a 	lds	r30, 0x0A01	; 0x800a01 <ptr_CallList>
    1674:	f0 91 02 0a 	lds	r31, 0x0A02	; 0x800a02 <ptr_CallList+0x1>
    1678:	09 95       	icall
}
    167a:	ff 91       	pop	r31
    167c:	ef 91       	pop	r30
    167e:	bf 91       	pop	r27
    1680:	af 91       	pop	r26
    1682:	9f 91       	pop	r25
    1684:	8f 91       	pop	r24
    1686:	7f 91       	pop	r23
    1688:	6f 91       	pop	r22
    168a:	5f 91       	pop	r21
    168c:	4f 91       	pop	r20
    168e:	3f 91       	pop	r19
    1690:	2f 91       	pop	r18
    1692:	0f 90       	pop	r0
    1694:	0b be       	out	0x3b, r0	; 59
    1696:	0f 90       	pop	r0
    1698:	0f be       	out	0x3f, r0	; 63
    169a:	0f 90       	pop	r0
    169c:	1f 90       	pop	r1
    169e:	18 95       	reti

000016a0 <__vector_30>:

ISR(USART1_RX_vect)
{
    16a0:	1f 92       	push	r1
    16a2:	0f 92       	push	r0
    16a4:	0f b6       	in	r0, 0x3f	; 63
    16a6:	0f 92       	push	r0
    16a8:	11 24       	eor	r1, r1
    16aa:	0b b6       	in	r0, 0x3b	; 59
    16ac:	0f 92       	push	r0
    16ae:	2f 93       	push	r18
    16b0:	3f 93       	push	r19
    16b2:	4f 93       	push	r20
    16b4:	5f 93       	push	r21
    16b6:	6f 93       	push	r22
    16b8:	7f 93       	push	r23
    16ba:	8f 93       	push	r24
    16bc:	9f 93       	push	r25
    16be:	af 93       	push	r26
    16c0:	bf 93       	push	r27
    16c2:	ef 93       	push	r30
    16c4:	ff 93       	push	r31
	ptr_CallList[UART_1]();
    16c6:	e0 91 03 0a 	lds	r30, 0x0A03	; 0x800a03 <ptr_CallList+0x2>
    16ca:	f0 91 04 0a 	lds	r31, 0x0A04	; 0x800a04 <ptr_CallList+0x3>
    16ce:	09 95       	icall
	
    16d0:	ff 91       	pop	r31
    16d2:	ef 91       	pop	r30
    16d4:	bf 91       	pop	r27
    16d6:	af 91       	pop	r26
    16d8:	9f 91       	pop	r25
    16da:	8f 91       	pop	r24
    16dc:	7f 91       	pop	r23
    16de:	6f 91       	pop	r22
    16e0:	5f 91       	pop	r21
    16e2:	4f 91       	pop	r20
    16e4:	3f 91       	pop	r19
    16e6:	2f 91       	pop	r18
    16e8:	0f 90       	pop	r0
    16ea:	0b be       	out	0x3b, r0	; 59
    16ec:	0f 90       	pop	r0
    16ee:	0f be       	out	0x3f, r0	; 63
    16f0:	0f 90       	pop	r0
    16f2:	1f 90       	pop	r1
    16f4:	18 95       	reti

000016f6 <MQTT_Init>:
const INT_8U proName[] = "MQTT";
INT_16U  packetidentifier = 1;

void MQTT_Init(void)
{
	UART_Init(UART_0,9600);
    16f6:	40 e8       	ldi	r20, 0x80	; 128
    16f8:	55 e2       	ldi	r21, 0x25	; 37
    16fa:	60 e0       	ldi	r22, 0x00	; 0
    16fc:	70 e0       	ldi	r23, 0x00	; 0
    16fe:	80 e0       	ldi	r24, 0x00	; 0
    1700:	0e cf       	rjmp	.-484    	; 0x151e <UART_Init>
    1702:	08 95       	ret

00001704 <encodeUTFstr>:
	UART_SendString(UART_0,"\\0\r\n");
		
}

void encodeUTFstr(INT_8U* str)
{
    1704:	cf 93       	push	r28
    1706:	df 93       	push	r29
    1708:	ec 01       	movw	r28, r24
	UART_SendByte(UART_0, 0x00);          /* Len high byte  */
    170a:	60 e0       	ldi	r22, 0x00	; 0
    170c:	80 e0       	ldi	r24, 0x00	; 0
    170e:	4b df       	rcall	.-362    	; 0x15a6 <UART_SendByte>
	UART_SendByte(UART_0, strlen(str));   /* Len low byte   */
    1710:	fe 01       	movw	r30, r28
    1712:	01 90       	ld	r0, Z+
    1714:	00 20       	and	r0, r0
    1716:	e9 f7       	brne	.-6      	; 0x1712 <encodeUTFstr+0xe>
    1718:	31 97       	sbiw	r30, 0x01	; 1
    171a:	bf 01       	movw	r22, r30
    171c:	6c 1b       	sub	r22, r28
    171e:	7d 0b       	sbc	r23, r29
    1720:	80 e0       	ldi	r24, 0x00	; 0
    1722:	41 df       	rcall	.-382    	; 0x15a6 <UART_SendByte>
	UART_SendString(UART_0,str);
    1724:	be 01       	movw	r22, r28
    1726:	80 e0       	ldi	r24, 0x00	; 0
    1728:	62 df       	rcall	.-316    	; 0x15ee <UART_SendString>
}
    172a:	df 91       	pop	r29
    172c:	cf 91       	pop	r28
    172e:	08 95       	ret

00001730 <MQTT_connect>:
void MQTT_Init(void)
{
	UART_Init(UART_0,9600);
}
void MQTT_connect(INT_8U* pu8ID)
{
    1730:	0f 93       	push	r16
    1732:	1f 93       	push	r17
    1734:	cf 93       	push	r28
    1736:	8c 01       	movw	r16, r24
	INT_8U remLen = (2 + strlen(proName)) + 1 + 1 + 2 + (2 + strlen(pu8ID));
    1738:	fc 01       	movw	r30, r24
    173a:	01 90       	ld	r0, Z+
    173c:	00 20       	and	r0, r0
    173e:	e9 f7       	brne	.-6      	; 0x173a <MQTT_connect+0xa>
    1740:	e8 1b       	sub	r30, r24
    1742:	cb e0       	ldi	r28, 0x0B	; 11
    1744:	ce 0f       	add	r28, r30
		/*   Wifi sending data command    */
	Wifi_Sendex_Command(remLen + 2);   
    1746:	8c 2f       	mov	r24, r28
    1748:	90 e0       	ldi	r25, 0x00	; 0
    174a:	02 96       	adiw	r24, 0x02	; 2
    174c:	17 dc       	rcall	.-2002   	; 0xf7c <Wifi_Sendex_Command>
	
	UART_SendByte(UART_0,0x10);    /* packet type  */
    174e:	60 e1       	ldi	r22, 0x10	; 16
    1750:	80 e0       	ldi	r24, 0x00	; 0
    1752:	29 df       	rcall	.-430    	; 0x15a6 <UART_SendByte>
	UART_SendByte(UART_0,remLen);  /*   Rem len    */
    1754:	6c 2f       	mov	r22, r28
    1756:	80 e0       	ldi	r24, 0x00	; 0
    1758:	26 df       	rcall	.-436    	; 0x15a6 <UART_SendByte>
    encodeUTFstr(proName);         /*  pro name    */
    175a:	82 e4       	ldi	r24, 0x42	; 66
    175c:	93 e0       	ldi	r25, 0x03	; 3
    175e:	d2 df       	rcall	.-92     	; 0x1704 <encodeUTFstr>
	UART_SendByte(UART_0,0x04);    /*  pro level    */
    1760:	64 e0       	ldi	r22, 0x04	; 4
    1762:	80 e0       	ldi	r24, 0x00	; 0
    1764:	20 df       	rcall	.-448    	; 0x15a6 <UART_SendByte>
	UART_SendByte(UART_0,0x02);    /*    flags     */
    1766:	62 e0       	ldi	r22, 0x02	; 2
    1768:	80 e0       	ldi	r24, 0x00	; 0
    176a:	1d df       	rcall	.-454    	; 0x15a6 <UART_SendByte>
	UART_SendByte(UART_0,0xFF);    /*    KAT MSB   */
    176c:	6f ef       	ldi	r22, 0xFF	; 255
    176e:	80 e0       	ldi	r24, 0x00	; 0
    1770:	1a df       	rcall	.-460    	; 0x15a6 <UART_SendByte>
	UART_SendByte(UART_0,0xFF);    /*    KAT LSB   */
    1772:	6f ef       	ldi	r22, 0xFF	; 255
    1774:	80 e0       	ldi	r24, 0x00	; 0
    1776:	17 df       	rcall	.-466    	; 0x15a6 <UART_SendByte>
	encodeUTFstr(pu8ID);           /*   client ID  */
    1778:	c8 01       	movw	r24, r16
    177a:	c4 df       	rcall	.-120    	; 0x1704 <encodeUTFstr>
    177c:	61 ed       	ldi	r22, 0xD1	; 209
	UART_SendString(UART_0,"\r\n");
    177e:	72 e0       	ldi	r23, 0x02	; 2
    1780:	80 e0       	ldi	r24, 0x00	; 0
    1782:	35 df       	rcall	.-406    	; 0x15ee <UART_SendString>
    1784:	cf 91       	pop	r28
    1786:	1f 91       	pop	r17
	
}
    1788:	0f 91       	pop	r16
    178a:	08 95       	ret

0000178c <MQTT_subscribe>:
    178c:	0f 93       	push	r16
    178e:	1f 93       	push	r17

void MQTT_subscribe(INT_8U* topic)
{
    1790:	cf 93       	push	r28
    1792:	8c 01       	movw	r16, r24
	INT_8U remlen = 2 + (2 + strlen(topic)) + 1;
    1794:	fc 01       	movw	r30, r24
    1796:	01 90       	ld	r0, Z+
    1798:	00 20       	and	r0, r0
    179a:	e9 f7       	brne	.-6      	; 0x1796 <MQTT_subscribe+0xa>
    179c:	e8 1b       	sub	r30, r24
    179e:	c4 e0       	ldi	r28, 0x04	; 4
    17a0:	ce 0f       	add	r28, r30
	Wifi_Sendex_Command(remlen + 2);				/*   Wifi sending data command    */
    17a2:	8c 2f       	mov	r24, r28
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	02 96       	adiw	r24, 0x02	; 2
    17a8:	e9 db       	rcall	.-2094   	; 0xf7c <Wifi_Sendex_Command>
	UART_SendByte(UART_0,0x82);						/* packet type */
    17aa:	62 e8       	ldi	r22, 0x82	; 130
    17ac:	80 e0       	ldi	r24, 0x00	; 0
    17ae:	fb de       	rcall	.-522    	; 0x15a6 <UART_SendByte>
	UART_SendByte(UART_0,remlen);					/* remaining length */
    17b0:	6c 2f       	mov	r22, r28
    17b2:	80 e0       	ldi	r24, 0x00	; 0
    17b4:	f8 de       	rcall	.-528    	; 0x15a6 <UART_SendByte>
	UART_SendByte(UART_0,packetidentifier >> 8);	/* packet ident  MSB */ 
    17b6:	60 91 02 01 	lds	r22, 0x0102	; 0x800102 <packetidentifier+0x1>
    17ba:	80 e0       	ldi	r24, 0x00	; 0
    17bc:	f4 de       	rcall	.-536    	; 0x15a6 <UART_SendByte>
	UART_SendByte(UART_0,packetidentifier);			/* pack identifier LSB */
    17be:	60 91 01 01 	lds	r22, 0x0101	; 0x800101 <packetidentifier>
    17c2:	80 e0       	ldi	r24, 0x00	; 0
    17c4:	f0 de       	rcall	.-544    	; 0x15a6 <UART_SendByte>
    17c6:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <packetidentifier>
	packetidentifier++;								/* sequence number */
    17ca:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <packetidentifier+0x1>
    17ce:	01 96       	adiw	r24, 0x01	; 1
    17d0:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <packetidentifier+0x1>
    17d4:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <packetidentifier>
	encodeUTFstr(topic);							/*  topic name */
    17d8:	c8 01       	movw	r24, r16
    17da:	94 df       	rcall	.-216    	; 0x1704 <encodeUTFstr>
    17dc:	61 e0       	ldi	r22, 0x01	; 1
	UART_SendByte(UART_0,0x01);						/* req. Qos  */
    17de:	80 e0       	ldi	r24, 0x00	; 0
    17e0:	e2 de       	rcall	.-572    	; 0x15a6 <UART_SendByte>
    17e2:	61 ed       	ldi	r22, 0xD1	; 209
	UART_SendString(UART_0,"\r\n");	
    17e4:	72 e0       	ldi	r23, 0x02	; 2
    17e6:	80 e0       	ldi	r24, 0x00	; 0
    17e8:	02 df       	rcall	.-508    	; 0x15ee <UART_SendString>
    17ea:	cf 91       	pop	r28
    17ec:	1f 91       	pop	r17
}
    17ee:	0f 91       	pop	r16
    17f0:	08 95       	ret

000017f2 <MQTT_publish>:
    17f2:	cf 92       	push	r12
    17f4:	df 92       	push	r13

void MQTT_publish(INT_8U* topic, INT_8U* pu8msg , INT_8U msgsize, INT_8U QOS)
{
    17f6:	ef 92       	push	r14
    17f8:	ff 92       	push	r15
    17fa:	0f 93       	push	r16
    17fc:	1f 93       	push	r17
    17fe:	cf 93       	push	r28
    1800:	df 93       	push	r29
    1802:	6c 01       	movw	r12, r24
    1804:	7b 01       	movw	r14, r22
    1806:	14 2f       	mov	r17, r20
    1808:	d2 2f       	mov	r29, r18
	INT_8U remlen = 2 + strlen(topic) + msgsize;
    180a:	fc 01       	movw	r30, r24
    180c:	01 90       	ld	r0, Z+
    180e:	00 20       	and	r0, r0
    1810:	e9 f7       	brne	.-6      	; 0x180c <MQTT_publish+0x1a>
    1812:	31 97       	sbiw	r30, 0x01	; 1
    1814:	e8 1b       	sub	r30, r24
    1816:	f9 0b       	sbc	r31, r25
    1818:	c4 2f       	mov	r28, r20
    181a:	ce 0f       	add	r28, r30
    181c:	02 e0       	ldi	r16, 0x02	; 2
    181e:	0c 0f       	add	r16, r28
	Wifi_Sendex_Command(remlen + 3);			/*  Wifi sending data command    */
    1820:	80 2f       	mov	r24, r16
    1822:	90 e0       	ldi	r25, 0x00	; 0
    1824:	03 96       	adiw	r24, 0x03	; 3
    1826:	aa db       	rcall	.-2220   	; 0xf7c <Wifi_Sendex_Command>
	switch (QOS)
    1828:	dd 23       	and	r29, r29
    182a:	19 f0       	breq	.+6      	; 0x1832 <MQTT_publish+0x40>
    182c:	d1 30       	cpi	r29, 0x01	; 1
    182e:	51 f0       	breq	.+20     	; 0x1844 <MQTT_publish+0x52>
    1830:	13 c0       	rjmp	.+38     	; 0x1858 <MQTT_publish+0x66>
	{
		case 0: 
		UART_SendByte(UART_0,0x30);
    1832:	60 e3       	ldi	r22, 0x30	; 48
    1834:	80 e0       	ldi	r24, 0x00	; 0
    1836:	b7 de       	rcall	.-658    	; 0x15a6 <UART_SendByte>
		UART_SendByte(UART_0,0x32);
		remlen = remlen + 2;
		break;
	}
	
	UART_SendByte(UART_0,remlen);
    1838:	60 2f       	mov	r22, r16
    183a:	80 e0       	ldi	r24, 0x00	; 0
	
	encodeUTFstr(topic);
    183c:	b4 de       	rcall	.-664    	; 0x15a6 <UART_SendByte>
    183e:	c6 01       	movw	r24, r12
    1840:	61 df       	rcall	.-318    	; 0x1704 <encodeUTFstr>
	{
		case 0: 
		UART_SendByte(UART_0,0x30);
		break;
		case 1 :
		UART_SendByte(UART_0,0x32);
    1842:	22 c0       	rjmp	.+68     	; 0x1888 <MQTT_publish+0x96>
    1844:	62 e3       	ldi	r22, 0x32	; 50
    1846:	80 e0       	ldi	r24, 0x00	; 0
		remlen = remlen + 2;
		break;
	}
	
	UART_SendByte(UART_0,remlen);
    1848:	ae de       	rcall	.-676    	; 0x15a6 <UART_SendByte>
    184a:	64 e0       	ldi	r22, 0x04	; 4
    184c:	6c 0f       	add	r22, r28
    184e:	80 e0       	ldi	r24, 0x00	; 0
	
	encodeUTFstr(topic);
    1850:	aa de       	rcall	.-684    	; 0x15a6 <UART_SendByte>
    1852:	c6 01       	movw	r24, r12
    1854:	57 df       	rcall	.-338    	; 0x1704 <encodeUTFstr>
		UART_SendByte(UART_0,0x32);
		remlen = remlen + 2;
		break;
	}
	
	UART_SendByte(UART_0,remlen);
    1856:	07 c0       	rjmp	.+14     	; 0x1866 <MQTT_publish+0x74>
    1858:	60 2f       	mov	r22, r16
    185a:	80 e0       	ldi	r24, 0x00	; 0
	
	encodeUTFstr(topic);
    185c:	a4 de       	rcall	.-696    	; 0x15a6 <UART_SendByte>
    185e:	c6 01       	movw	r24, r12
    1860:	51 df       	rcall	.-350    	; 0x1704 <encodeUTFstr>
	if( QOS == 1)
    1862:	d1 30       	cpi	r29, 0x01	; 1
	{
		UART_SendByte(UART_0,(packetidentifier>>8));
    1864:	89 f4       	brne	.+34     	; 0x1888 <MQTT_publish+0x96>
    1866:	60 91 02 01 	lds	r22, 0x0102	; 0x800102 <packetidentifier+0x1>
    186a:	80 e0       	ldi	r24, 0x00	; 0
    186c:	9c de       	rcall	.-712    	; 0x15a6 <UART_SendByte>
		UART_SendByte(UART_0,packetidentifier);
    186e:	60 91 01 01 	lds	r22, 0x0101	; 0x800101 <packetidentifier>
    1872:	80 e0       	ldi	r24, 0x00	; 0
    1874:	98 de       	rcall	.-720    	; 0x15a6 <UART_SendByte>
    1876:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <packetidentifier>
		packetidentifier++;
    187a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <packetidentifier+0x1>
    187e:	01 96       	adiw	r24, 0x01	; 1
    1880:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <packetidentifier+0x1>
    1884:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <packetidentifier>
    1888:	11 23       	and	r17, r17
	}
	for (INT_8U count = 0; count <msgsize ; count++)
    188a:	71 f0       	breq	.+28     	; 0x18a8 <MQTT_publish+0xb6>
    188c:	e7 01       	movw	r28, r14
    188e:	11 50       	subi	r17, 0x01	; 1
    1890:	01 2f       	mov	r16, r17
    1892:	10 e0       	ldi	r17, 0x00	; 0
    1894:	0f 5f       	subi	r16, 0xFF	; 255
    1896:	1f 4f       	sbci	r17, 0xFF	; 255
    1898:	0e 0d       	add	r16, r14
	{
		UART_SendByte(UART_0,pu8msg[count]);
    189a:	1f 1d       	adc	r17, r15
    189c:	69 91       	ld	r22, Y+
    189e:	80 e0       	ldi	r24, 0x00	; 0
    18a0:	82 de       	rcall	.-764    	; 0x15a6 <UART_SendByte>
	{
		UART_SendByte(UART_0,(packetidentifier>>8));
		UART_SendByte(UART_0,packetidentifier);
		packetidentifier++;
	}
	for (INT_8U count = 0; count <msgsize ; count++)
    18a2:	0c 17       	cp	r16, r28
    18a4:	1d 07       	cpc	r17, r29
    18a6:	d1 f7       	brne	.-12     	; 0x189c <MQTT_publish+0xaa>
	{
		UART_SendByte(UART_0,pu8msg[count]);
	}
	UART_SendString(UART_0,"\\0\r\n");
    18a8:	6e e2       	ldi	r22, 0x2E	; 46
    18aa:	73 e0       	ldi	r23, 0x03	; 3
    18ac:	80 e0       	ldi	r24, 0x00	; 0
    18ae:	9f de       	rcall	.-706    	; 0x15ee <UART_SendString>
    18b0:	df 91       	pop	r29
		
}
    18b2:	cf 91       	pop	r28
    18b4:	1f 91       	pop	r17
    18b6:	0f 91       	pop	r16
    18b8:	ff 90       	pop	r15
    18ba:	ef 90       	pop	r14
    18bc:	df 90       	pop	r13
    18be:	cf 90       	pop	r12
    18c0:	08 95       	ret

000018c2 <MQTT_Ping>:
    18c2:	82 e0       	ldi	r24, 0x02	; 2
	UART_SendString(UART_0,str);
}

void MQTT_Ping(void)
{
	Wifi_Sendex_Command(2);
    18c4:	90 e0       	ldi	r25, 0x00	; 0
    18c6:	5a db       	rcall	.-2380   	; 0xf7c <Wifi_Sendex_Command>
	UART_SendByte(UART_0,0xC0);
    18c8:	60 ec       	ldi	r22, 0xC0	; 192
    18ca:	80 e0       	ldi	r24, 0x00	; 0
    18cc:	6c de       	rcall	.-808    	; 0x15a6 <UART_SendByte>
	UART_SendByte(UART_0,0x00);
    18ce:	60 e0       	ldi	r22, 0x00	; 0
    18d0:	80 e0       	ldi	r24, 0x00	; 0
    18d2:	69 de       	rcall	.-814    	; 0x15a6 <UART_SendByte>
	UART_SendString(UART_0,"\r\n");	
    18d4:	61 ed       	ldi	r22, 0xD1	; 209
    18d6:	72 e0       	ldi	r23, 0x02	; 2
    18d8:	80 e0       	ldi	r24, 0x00	; 0
    18da:	89 ce       	rjmp	.-750    	; 0x15ee <UART_SendString>
    18dc:	08 95       	ret

000018de <xEventGroupCreate>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
    18de:	cf 93       	push	r28
    18e0:	df 93       	push	r29
    18e2:	8b e0       	ldi	r24, 0x0B	; 11
    18e4:	90 e0       	ldi	r25, 0x00	; 0
    18e6:	fc d0       	rcall	.+504    	; 0x1ae0 <pvPortMalloc>
    18e8:	ec 01       	movw	r28, r24
    18ea:	00 97       	sbiw	r24, 0x00	; 0
    18ec:	29 f0       	breq	.+10     	; 0x18f8 <xEventGroupCreate+0x1a>
    18ee:	fc 01       	movw	r30, r24
    18f0:	11 92       	st	Z+, r1
    18f2:	11 92       	st	Z+, r1
    18f4:	cf 01       	movw	r24, r30
    18f6:	28 d1       	rcall	.+592    	; 0x1b48 <vListInitialise>
    18f8:	ce 01       	movw	r24, r28
    18fa:	df 91       	pop	r29
    18fc:	cf 91       	pop	r28
    18fe:	08 95       	ret

00001900 <xEventGroupWaitBits>:
    1900:	af 92       	push	r10
    1902:	bf 92       	push	r11
    1904:	cf 92       	push	r12
    1906:	df 92       	push	r13
    1908:	ef 92       	push	r14
    190a:	ff 92       	push	r15
    190c:	0f 93       	push	r16
    190e:	1f 93       	push	r17
    1910:	cf 93       	push	r28
    1912:	df 93       	push	r29
    1914:	7c 01       	movw	r14, r24
    1916:	6b 01       	movw	r12, r22
    1918:	a4 2e       	mov	r10, r20
    191a:	b2 2e       	mov	r11, r18
    191c:	b4 d6       	rcall	.+3432   	; 0x2686 <vTaskSuspendAll>
    191e:	f7 01       	movw	r30, r14
    1920:	c0 81       	ld	r28, Z
    1922:	d1 81       	ldd	r29, Z+1	; 0x01
    1924:	b1 10       	cpse	r11, r1
    1926:	08 c0       	rjmp	.+16     	; 0x1938 <xEventGroupWaitBits+0x38>
    1928:	81 e0       	ldi	r24, 0x01	; 1
    192a:	9e 01       	movw	r18, r28
    192c:	2c 21       	and	r18, r12
    192e:	3d 21       	and	r19, r13
    1930:	23 2b       	or	r18, r19
    1932:	51 f4       	brne	.+20     	; 0x1948 <xEventGroupWaitBits+0x48>
    1934:	80 e0       	ldi	r24, 0x00	; 0
    1936:	08 c0       	rjmp	.+16     	; 0x1948 <xEventGroupWaitBits+0x48>
    1938:	81 e0       	ldi	r24, 0x01	; 1
    193a:	9e 01       	movw	r18, r28
    193c:	2c 21       	and	r18, r12
    193e:	3d 21       	and	r19, r13
    1940:	2c 15       	cp	r18, r12
    1942:	3d 05       	cpc	r19, r13
    1944:	09 f0       	breq	.+2      	; 0x1948 <xEventGroupWaitBits+0x48>
    1946:	80 e0       	ldi	r24, 0x00	; 0
    1948:	88 23       	and	r24, r24
    194a:	61 f0       	breq	.+24     	; 0x1964 <xEventGroupWaitBits+0x64>
    194c:	aa 20       	and	r10, r10
    194e:	09 f4       	brne	.+2      	; 0x1952 <xEventGroupWaitBits+0x52>
    1950:	4e c0       	rjmp	.+156    	; 0x19ee <xEventGroupWaitBits+0xee>
    1952:	b6 01       	movw	r22, r12
    1954:	60 95       	com	r22
    1956:	70 95       	com	r23
    1958:	6c 23       	and	r22, r28
    195a:	7d 23       	and	r23, r29
    195c:	f7 01       	movw	r30, r14
    195e:	71 83       	std	Z+1, r23	; 0x01
    1960:	60 83       	st	Z, r22
    1962:	45 c0       	rjmp	.+138    	; 0x19ee <xEventGroupWaitBits+0xee>
    1964:	01 15       	cp	r16, r1
    1966:	11 05       	cpc	r17, r1
    1968:	09 f4       	brne	.+2      	; 0x196c <xEventGroupWaitBits+0x6c>
    196a:	41 c0       	rjmp	.+130    	; 0x19ee <xEventGroupWaitBits+0xee>
    196c:	aa 20       	and	r10, r10
    196e:	19 f0       	breq	.+6      	; 0x1976 <xEventGroupWaitBits+0x76>
    1970:	60 e0       	ldi	r22, 0x00	; 0
    1972:	71 e0       	ldi	r23, 0x01	; 1
    1974:	02 c0       	rjmp	.+4      	; 0x197a <xEventGroupWaitBits+0x7a>
    1976:	60 e0       	ldi	r22, 0x00	; 0
    1978:	70 e0       	ldi	r23, 0x00	; 0
    197a:	b1 10       	cpse	r11, r1
    197c:	74 60       	ori	r23, 0x04	; 4
    197e:	6c 29       	or	r22, r12
    1980:	7d 29       	or	r23, r13
    1982:	a8 01       	movw	r20, r16
    1984:	c7 01       	movw	r24, r14
    1986:	02 96       	adiw	r24, 0x02	; 2
    1988:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <vTaskPlaceOnUnorderedEventList>
    198c:	3b d7       	rcall	.+3702   	; 0x2804 <xTaskResumeAll>
    198e:	81 11       	cpse	r24, r1
    1990:	01 c0       	rjmp	.+2      	; 0x1994 <xEventGroupWaitBits+0x94>
    1992:	05 d2       	rcall	.+1034   	; 0x1d9e <vPortYield>
    1994:	0e 94 35 16 	call	0x2c6a	; 0x2c6a <uxTaskResetEventItemValue>
    1998:	91 fd       	sbrc	r25, 1
    199a:	26 c0       	rjmp	.+76     	; 0x19e8 <xEventGroupWaitBits+0xe8>
    199c:	0f b6       	in	r0, 0x3f	; 63
    199e:	f8 94       	cli
    19a0:	0f 92       	push	r0
    19a2:	f7 01       	movw	r30, r14
    19a4:	80 81       	ld	r24, Z
    19a6:	91 81       	ldd	r25, Z+1	; 0x01
    19a8:	b1 10       	cpse	r11, r1
    19aa:	08 c0       	rjmp	.+16     	; 0x19bc <xEventGroupWaitBits+0xbc>
    19ac:	21 e0       	ldi	r18, 0x01	; 1
    19ae:	a6 01       	movw	r20, r12
    19b0:	48 23       	and	r20, r24
    19b2:	59 23       	and	r21, r25
    19b4:	45 2b       	or	r20, r21
    19b6:	51 f4       	brne	.+20     	; 0x19cc <xEventGroupWaitBits+0xcc>
    19b8:	20 e0       	ldi	r18, 0x00	; 0
    19ba:	08 c0       	rjmp	.+16     	; 0x19cc <xEventGroupWaitBits+0xcc>
    19bc:	21 e0       	ldi	r18, 0x01	; 1
    19be:	a6 01       	movw	r20, r12
    19c0:	48 23       	and	r20, r24
    19c2:	59 23       	and	r21, r25
    19c4:	4c 15       	cp	r20, r12
    19c6:	5d 05       	cpc	r21, r13
    19c8:	09 f0       	breq	.+2      	; 0x19cc <xEventGroupWaitBits+0xcc>
    19ca:	20 e0       	ldi	r18, 0x00	; 0
    19cc:	22 23       	and	r18, r18
    19ce:	51 f0       	breq	.+20     	; 0x19e4 <xEventGroupWaitBits+0xe4>
    19d0:	aa 20       	and	r10, r10
    19d2:	41 f0       	breq	.+16     	; 0x19e4 <xEventGroupWaitBits+0xe4>
    19d4:	b6 01       	movw	r22, r12
    19d6:	60 95       	com	r22
    19d8:	70 95       	com	r23
    19da:	68 23       	and	r22, r24
    19dc:	79 23       	and	r23, r25
    19de:	f7 01       	movw	r30, r14
    19e0:	71 83       	std	Z+1, r23	; 0x01
    19e2:	60 83       	st	Z, r22
    19e4:	0f 90       	pop	r0
    19e6:	0f be       	out	0x3f, r0	; 63
    19e8:	ec 01       	movw	r28, r24
    19ea:	dd 27       	eor	r29, r29
    19ec:	01 c0       	rjmp	.+2      	; 0x19f0 <xEventGroupWaitBits+0xf0>
    19ee:	0a d7       	rcall	.+3604   	; 0x2804 <xTaskResumeAll>
    19f0:	ce 01       	movw	r24, r28
    19f2:	df 91       	pop	r29
    19f4:	cf 91       	pop	r28
    19f6:	1f 91       	pop	r17
    19f8:	0f 91       	pop	r16
    19fa:	ff 90       	pop	r15
    19fc:	ef 90       	pop	r14
    19fe:	df 90       	pop	r13
    1a00:	cf 90       	pop	r12
    1a02:	bf 90       	pop	r11
    1a04:	af 90       	pop	r10
    1a06:	08 95       	ret

00001a08 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    1a08:	af 92       	push	r10
    1a0a:	bf 92       	push	r11
    1a0c:	cf 92       	push	r12
    1a0e:	df 92       	push	r13
    1a10:	ef 92       	push	r14
    1a12:	ff 92       	push	r15
    1a14:	0f 93       	push	r16
    1a16:	1f 93       	push	r17
    1a18:	cf 93       	push	r28
    1a1a:	df 93       	push	r29
    1a1c:	7c 01       	movw	r14, r24
    1a1e:	8b 01       	movw	r16, r22
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1a20:	ec 01       	movw	r28, r24
    1a22:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
    1a24:	30 d6       	rcall	.+3168   	; 0x2686 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    1a26:	d7 01       	movw	r26, r14
    1a28:	17 96       	adiw	r26, 0x07	; 7
    1a2a:	ed 91       	ld	r30, X+
    1a2c:	fc 91       	ld	r31, X
    1a2e:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1a30:	8d 91       	ld	r24, X+
    1a32:	9c 91       	ld	r25, X
    1a34:	11 97       	sbiw	r26, 0x01	; 1
    1a36:	08 2b       	or	r16, r24
    1a38:	19 2b       	or	r17, r25
    1a3a:	0d 93       	st	X+, r16
    1a3c:	1c 93       	st	X, r17

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    1a3e:	ce 17       	cp	r28, r30
    1a40:	df 07       	cpc	r29, r31
    1a42:	a1 f1       	breq	.+104    	; 0x1aac <xEventGroupSetBits+0xa4>
    1a44:	00 e0       	ldi	r16, 0x00	; 0
    1a46:	10 e0       	ldi	r17, 0x00	; 0
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
    1a48:	bb 24       	eor	r11, r11
    1a4a:	b3 94       	inc	r11
    1a4c:	a1 2c       	mov	r10, r1
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    1a4e:	c2 80       	ldd	r12, Z+2	; 0x02
    1a50:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1a52:	80 81       	ld	r24, Z
    1a54:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1a56:	9c 01       	movw	r18, r24
    1a58:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1a5a:	92 fd       	sbrc	r25, 2
    1a5c:	0a c0       	rjmp	.+20     	; 0x1a72 <xEventGroupSetBits+0x6a>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
    1a5e:	d7 01       	movw	r26, r14
    1a60:	6d 91       	ld	r22, X+
    1a62:	7c 91       	ld	r23, X
    1a64:	62 23       	and	r22, r18
    1a66:	73 23       	and	r23, r19
    1a68:	4b 2d       	mov	r20, r11
    1a6a:	67 2b       	or	r22, r23
    1a6c:	61 f4       	brne	.+24     	; 0x1a86 <xEventGroupSetBits+0x7e>
    1a6e:	4a 2d       	mov	r20, r10
    1a70:	0a c0       	rjmp	.+20     	; 0x1a86 <xEventGroupSetBits+0x7e>
    1a72:	d7 01       	movw	r26, r14
    1a74:	6d 91       	ld	r22, X+
    1a76:	7c 91       	ld	r23, X
    1a78:	62 23       	and	r22, r18
    1a7a:	73 23       	and	r23, r19
    1a7c:	4b 2d       	mov	r20, r11
    1a7e:	62 17       	cp	r22, r18
    1a80:	73 07       	cpc	r23, r19
    1a82:	09 f0       	breq	.+2      	; 0x1a86 <xEventGroupSetBits+0x7e>
    1a84:	4a 2d       	mov	r20, r10
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    1a86:	44 23       	and	r20, r20
    1a88:	59 f0       	breq	.+22     	; 0x1aa0 <xEventGroupSetBits+0x98>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1a8a:	90 ff       	sbrs	r25, 0
    1a8c:	02 c0       	rjmp	.+4      	; 0x1a92 <xEventGroupSetBits+0x8a>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    1a8e:	02 2b       	or	r16, r18
    1a90:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1a92:	d7 01       	movw	r26, r14
    1a94:	6d 91       	ld	r22, X+
    1a96:	7c 91       	ld	r23, X
    1a98:	72 60       	ori	r23, 0x02	; 2
    1a9a:	cf 01       	movw	r24, r30
    1a9c:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <xTaskRemoveFromUnorderedEventList>
    1aa0:	ec 2d       	mov	r30, r12
    1aa2:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    1aa4:	ce 17       	cp	r28, r30
    1aa6:	df 07       	cpc	r29, r31
    1aa8:	91 f6       	brne	.-92     	; 0x1a4e <xEventGroupSetBits+0x46>
    1aaa:	02 c0       	rjmp	.+4      	; 0x1ab0 <xEventGroupSetBits+0xa8>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1aac:	00 e0       	ldi	r16, 0x00	; 0
    1aae:	10 e0       	ldi	r17, 0x00	; 0
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1ab0:	00 95       	com	r16
    1ab2:	10 95       	com	r17
    1ab4:	f7 01       	movw	r30, r14
    1ab6:	80 81       	ld	r24, Z
    1ab8:	91 81       	ldd	r25, Z+1	; 0x01
    1aba:	08 23       	and	r16, r24
    1abc:	19 23       	and	r17, r25
    1abe:	11 83       	std	Z+1, r17	; 0x01
	}
	( void ) xTaskResumeAll();
    1ac0:	00 83       	st	Z, r16
    1ac2:	a0 d6       	rcall	.+3392   	; 0x2804 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
    1ac4:	d7 01       	movw	r26, r14
    1ac6:	8d 91       	ld	r24, X+
    1ac8:	9c 91       	ld	r25, X
    1aca:	df 91       	pop	r29
    1acc:	cf 91       	pop	r28
    1ace:	1f 91       	pop	r17
    1ad0:	0f 91       	pop	r16
    1ad2:	ff 90       	pop	r15
    1ad4:	ef 90       	pop	r14
    1ad6:	df 90       	pop	r13
    1ad8:	cf 90       	pop	r12
    1ada:	bf 90       	pop	r11
    1adc:	af 90       	pop	r10
    1ade:	08 95       	ret

00001ae0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1ae0:	cf 93       	push	r28
    1ae2:	df 93       	push	r29
    1ae4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1ae6:	cf d5       	rcall	.+2974   	; 0x2686 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1ae8:	80 91 ab 03 	lds	r24, 0x03AB	; 0x8003ab <pucAlignedHeap.1981>
    1aec:	90 91 ac 03 	lds	r25, 0x03AC	; 0x8003ac <pucAlignedHeap.1981+0x1>
    1af0:	89 2b       	or	r24, r25
    1af2:	31 f4       	brne	.+12     	; 0x1b00 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    1af4:	80 eb       	ldi	r24, 0xB0	; 176
    1af6:	93 e0       	ldi	r25, 0x03	; 3
    1af8:	90 93 ac 03 	sts	0x03AC, r25	; 0x8003ac <pucAlignedHeap.1981+0x1>
    1afc:	80 93 ab 03 	sts	0x03AB, r24	; 0x8003ab <pucAlignedHeap.1981>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1b00:	20 91 ad 03 	lds	r18, 0x03AD	; 0x8003ad <xNextFreeByte>
    1b04:	30 91 ae 03 	lds	r19, 0x03AE	; 0x8003ae <xNextFreeByte+0x1>
    1b08:	c9 01       	movw	r24, r18
    1b0a:	8c 0f       	add	r24, r28
    1b0c:	9d 1f       	adc	r25, r29
    1b0e:	8b 3d       	cpi	r24, 0xDB	; 219
    1b10:	45 e0       	ldi	r20, 0x05	; 5
    1b12:	94 07       	cpc	r25, r20
    1b14:	70 f4       	brcc	.+28     	; 0x1b32 <pvPortMalloc+0x52>
    1b16:	28 17       	cp	r18, r24
    1b18:	39 07       	cpc	r19, r25
    1b1a:	70 f4       	brcc	.+28     	; 0x1b38 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1b1c:	c0 91 ab 03 	lds	r28, 0x03AB	; 0x8003ab <pucAlignedHeap.1981>
    1b20:	d0 91 ac 03 	lds	r29, 0x03AC	; 0x8003ac <pucAlignedHeap.1981+0x1>
    1b24:	c2 0f       	add	r28, r18
    1b26:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    1b28:	90 93 ae 03 	sts	0x03AE, r25	; 0x8003ae <xNextFreeByte+0x1>
    1b2c:	80 93 ad 03 	sts	0x03AD, r24	; 0x8003ad <xNextFreeByte>
    1b30:	05 c0       	rjmp	.+10     	; 0x1b3c <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1b32:	c0 e0       	ldi	r28, 0x00	; 0
    1b34:	d0 e0       	ldi	r29, 0x00	; 0
    1b36:	02 c0       	rjmp	.+4      	; 0x1b3c <pvPortMalloc+0x5c>
    1b38:	c0 e0       	ldi	r28, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1b3a:	d0 e0       	ldi	r29, 0x00	; 0
    1b3c:	63 d6       	rcall	.+3270   	; 0x2804 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1b3e:	ce 01       	movw	r24, r28
    1b40:	df 91       	pop	r29
    1b42:	cf 91       	pop	r28
    1b44:	08 95       	ret

00001b46 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1b46:	08 95       	ret

00001b48 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b48:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b4a:	03 96       	adiw	r24, 0x03	; 3
    1b4c:	92 83       	std	Z+2, r25	; 0x02
    1b4e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b50:	2f ef       	ldi	r18, 0xFF	; 255
    1b52:	3f ef       	ldi	r19, 0xFF	; 255
    1b54:	34 83       	std	Z+4, r19	; 0x04
    1b56:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b58:	96 83       	std	Z+6, r25	; 0x06
    1b5a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b5c:	90 87       	std	Z+8, r25	; 0x08
    1b5e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b60:	10 82       	st	Z, r1
    1b62:	08 95       	ret

00001b64 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1b64:	fc 01       	movw	r30, r24
    1b66:	11 86       	std	Z+9, r1	; 0x09
    1b68:	10 86       	std	Z+8, r1	; 0x08
    1b6a:	08 95       	ret

00001b6c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1b6c:	cf 93       	push	r28
    1b6e:	df 93       	push	r29
    1b70:	9c 01       	movw	r18, r24
    1b72:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1b74:	dc 01       	movw	r26, r24
    1b76:	11 96       	adiw	r26, 0x01	; 1
    1b78:	cd 91       	ld	r28, X+
    1b7a:	dc 91       	ld	r29, X
    1b7c:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1b7e:	d3 83       	std	Z+3, r29	; 0x03
    1b80:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1b82:	8c 81       	ldd	r24, Y+4	; 0x04
    1b84:	9d 81       	ldd	r25, Y+5	; 0x05
    1b86:	95 83       	std	Z+5, r25	; 0x05
    1b88:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1b8a:	8c 81       	ldd	r24, Y+4	; 0x04
    1b8c:	9d 81       	ldd	r25, Y+5	; 0x05
    1b8e:	dc 01       	movw	r26, r24
    1b90:	13 96       	adiw	r26, 0x03	; 3
    1b92:	7c 93       	st	X, r23
    1b94:	6e 93       	st	-X, r22
    1b96:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1b98:	7d 83       	std	Y+5, r23	; 0x05
    1b9a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1b9c:	31 87       	std	Z+9, r19	; 0x09
    1b9e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1ba0:	f9 01       	movw	r30, r18
    1ba2:	80 81       	ld	r24, Z
    1ba4:	8f 5f       	subi	r24, 0xFF	; 255
    1ba6:	80 83       	st	Z, r24
}
    1ba8:	df 91       	pop	r29
    1baa:	cf 91       	pop	r28
    1bac:	08 95       	ret

00001bae <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1bae:	cf 93       	push	r28
    1bb0:	df 93       	push	r29
    1bb2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1bb4:	48 81       	ld	r20, Y
    1bb6:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1bb8:	4f 3f       	cpi	r20, 0xFF	; 255
    1bba:	2f ef       	ldi	r18, 0xFF	; 255
    1bbc:	52 07       	cpc	r21, r18
    1bbe:	21 f4       	brne	.+8      	; 0x1bc8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1bc0:	fc 01       	movw	r30, r24
    1bc2:	a7 81       	ldd	r26, Z+7	; 0x07
    1bc4:	b0 85       	ldd	r27, Z+8	; 0x08
    1bc6:	0d c0       	rjmp	.+26     	; 0x1be2 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bc8:	dc 01       	movw	r26, r24
    1bca:	13 96       	adiw	r26, 0x03	; 3
    1bcc:	01 c0       	rjmp	.+2      	; 0x1bd0 <vListInsert+0x22>
    1bce:	df 01       	movw	r26, r30
    1bd0:	12 96       	adiw	r26, 0x02	; 2
    1bd2:	ed 91       	ld	r30, X+
    1bd4:	fc 91       	ld	r31, X
    1bd6:	13 97       	sbiw	r26, 0x03	; 3
    1bd8:	20 81       	ld	r18, Z
    1bda:	31 81       	ldd	r19, Z+1	; 0x01
    1bdc:	42 17       	cp	r20, r18
    1bde:	53 07       	cpc	r21, r19
    1be0:	b0 f7       	brcc	.-20     	; 0x1bce <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1be2:	12 96       	adiw	r26, 0x02	; 2
    1be4:	ed 91       	ld	r30, X+
    1be6:	fc 91       	ld	r31, X
    1be8:	13 97       	sbiw	r26, 0x03	; 3
    1bea:	fb 83       	std	Y+3, r31	; 0x03
    1bec:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1bee:	d5 83       	std	Z+5, r29	; 0x05
    1bf0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1bf2:	bd 83       	std	Y+5, r27	; 0x05
    1bf4:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1bf6:	13 96       	adiw	r26, 0x03	; 3
    1bf8:	dc 93       	st	X, r29
    1bfa:	ce 93       	st	-X, r28
    1bfc:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1bfe:	99 87       	std	Y+9, r25	; 0x09
    1c00:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1c02:	fc 01       	movw	r30, r24
    1c04:	20 81       	ld	r18, Z
    1c06:	2f 5f       	subi	r18, 0xFF	; 255
    1c08:	20 83       	st	Z, r18
}
    1c0a:	df 91       	pop	r29
    1c0c:	cf 91       	pop	r28
    1c0e:	08 95       	ret

00001c10 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c10:	cf 93       	push	r28
    1c12:	df 93       	push	r29
    1c14:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1c16:	a0 85       	ldd	r26, Z+8	; 0x08
    1c18:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c1a:	c2 81       	ldd	r28, Z+2	; 0x02
    1c1c:	d3 81       	ldd	r29, Z+3	; 0x03
    1c1e:	84 81       	ldd	r24, Z+4	; 0x04
    1c20:	95 81       	ldd	r25, Z+5	; 0x05
    1c22:	9d 83       	std	Y+5, r25	; 0x05
    1c24:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c26:	c4 81       	ldd	r28, Z+4	; 0x04
    1c28:	d5 81       	ldd	r29, Z+5	; 0x05
    1c2a:	82 81       	ldd	r24, Z+2	; 0x02
    1c2c:	93 81       	ldd	r25, Z+3	; 0x03
    1c2e:	9b 83       	std	Y+3, r25	; 0x03
    1c30:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c32:	11 96       	adiw	r26, 0x01	; 1
    1c34:	8d 91       	ld	r24, X+
    1c36:	9c 91       	ld	r25, X
    1c38:	12 97       	sbiw	r26, 0x02	; 2
    1c3a:	e8 17       	cp	r30, r24
    1c3c:	f9 07       	cpc	r31, r25
    1c3e:	31 f4       	brne	.+12     	; 0x1c4c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c40:	84 81       	ldd	r24, Z+4	; 0x04
    1c42:	95 81       	ldd	r25, Z+5	; 0x05
    1c44:	12 96       	adiw	r26, 0x02	; 2
    1c46:	9c 93       	st	X, r25
    1c48:	8e 93       	st	-X, r24
    1c4a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1c4c:	11 86       	std	Z+9, r1	; 0x09
    1c4e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1c50:	8c 91       	ld	r24, X
    1c52:	81 50       	subi	r24, 0x01	; 1
    1c54:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1c56:	df 91       	pop	r29
    1c58:	cf 91       	pop	r28
    1c5a:	08 95       	ret

00001c5c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1c5c:	31 e1       	ldi	r19, 0x11	; 17
    1c5e:	fc 01       	movw	r30, r24
    1c60:	30 83       	st	Z, r19
    1c62:	31 97       	sbiw	r30, 0x01	; 1
    1c64:	22 e2       	ldi	r18, 0x22	; 34
    1c66:	20 83       	st	Z, r18
    1c68:	31 97       	sbiw	r30, 0x01	; 1
    1c6a:	a3 e3       	ldi	r26, 0x33	; 51
    1c6c:	a0 83       	st	Z, r26
    1c6e:	31 97       	sbiw	r30, 0x01	; 1
    1c70:	60 83       	st	Z, r22
    1c72:	31 97       	sbiw	r30, 0x01	; 1
    1c74:	70 83       	st	Z, r23
    1c76:	31 97       	sbiw	r30, 0x01	; 1
    1c78:	10 82       	st	Z, r1
    1c7a:	31 97       	sbiw	r30, 0x01	; 1
    1c7c:	60 e8       	ldi	r22, 0x80	; 128
    1c7e:	60 83       	st	Z, r22
    1c80:	31 97       	sbiw	r30, 0x01	; 1
    1c82:	10 82       	st	Z, r1
    1c84:	31 97       	sbiw	r30, 0x01	; 1
    1c86:	62 e0       	ldi	r22, 0x02	; 2
    1c88:	60 83       	st	Z, r22
    1c8a:	31 97       	sbiw	r30, 0x01	; 1
    1c8c:	63 e0       	ldi	r22, 0x03	; 3
    1c8e:	60 83       	st	Z, r22
    1c90:	31 97       	sbiw	r30, 0x01	; 1
    1c92:	64 e0       	ldi	r22, 0x04	; 4
    1c94:	60 83       	st	Z, r22
    1c96:	31 97       	sbiw	r30, 0x01	; 1
    1c98:	65 e0       	ldi	r22, 0x05	; 5
    1c9a:	60 83       	st	Z, r22
    1c9c:	31 97       	sbiw	r30, 0x01	; 1
    1c9e:	66 e0       	ldi	r22, 0x06	; 6
    1ca0:	60 83       	st	Z, r22
    1ca2:	31 97       	sbiw	r30, 0x01	; 1
    1ca4:	67 e0       	ldi	r22, 0x07	; 7
    1ca6:	60 83       	st	Z, r22
    1ca8:	31 97       	sbiw	r30, 0x01	; 1
    1caa:	68 e0       	ldi	r22, 0x08	; 8
    1cac:	60 83       	st	Z, r22
    1cae:	31 97       	sbiw	r30, 0x01	; 1
    1cb0:	69 e0       	ldi	r22, 0x09	; 9
    1cb2:	60 83       	st	Z, r22
    1cb4:	31 97       	sbiw	r30, 0x01	; 1
    1cb6:	60 e1       	ldi	r22, 0x10	; 16
    1cb8:	60 83       	st	Z, r22
    1cba:	31 97       	sbiw	r30, 0x01	; 1
    1cbc:	30 83       	st	Z, r19
    1cbe:	31 97       	sbiw	r30, 0x01	; 1
    1cc0:	32 e1       	ldi	r19, 0x12	; 18
    1cc2:	30 83       	st	Z, r19
    1cc4:	31 97       	sbiw	r30, 0x01	; 1
    1cc6:	33 e1       	ldi	r19, 0x13	; 19
    1cc8:	30 83       	st	Z, r19
    1cca:	31 97       	sbiw	r30, 0x01	; 1
    1ccc:	34 e1       	ldi	r19, 0x14	; 20
    1cce:	30 83       	st	Z, r19
    1cd0:	31 97       	sbiw	r30, 0x01	; 1
    1cd2:	35 e1       	ldi	r19, 0x15	; 21
    1cd4:	30 83       	st	Z, r19
    1cd6:	31 97       	sbiw	r30, 0x01	; 1
    1cd8:	36 e1       	ldi	r19, 0x16	; 22
    1cda:	30 83       	st	Z, r19
    1cdc:	31 97       	sbiw	r30, 0x01	; 1
    1cde:	37 e1       	ldi	r19, 0x17	; 23
    1ce0:	30 83       	st	Z, r19
    1ce2:	31 97       	sbiw	r30, 0x01	; 1
    1ce4:	38 e1       	ldi	r19, 0x18	; 24
    1ce6:	30 83       	st	Z, r19
    1ce8:	31 97       	sbiw	r30, 0x01	; 1
    1cea:	39 e1       	ldi	r19, 0x19	; 25
    1cec:	30 83       	st	Z, r19
    1cee:	31 97       	sbiw	r30, 0x01	; 1
    1cf0:	30 e2       	ldi	r19, 0x20	; 32
    1cf2:	30 83       	st	Z, r19
    1cf4:	31 97       	sbiw	r30, 0x01	; 1
    1cf6:	31 e2       	ldi	r19, 0x21	; 33
    1cf8:	30 83       	st	Z, r19
    1cfa:	31 97       	sbiw	r30, 0x01	; 1
    1cfc:	20 83       	st	Z, r18
    1cfe:	31 97       	sbiw	r30, 0x01	; 1
    1d00:	23 e2       	ldi	r18, 0x23	; 35
    1d02:	20 83       	st	Z, r18
    1d04:	31 97       	sbiw	r30, 0x01	; 1
    1d06:	40 83       	st	Z, r20
    1d08:	31 97       	sbiw	r30, 0x01	; 1
    1d0a:	50 83       	st	Z, r21
    1d0c:	31 97       	sbiw	r30, 0x01	; 1
    1d0e:	26 e2       	ldi	r18, 0x26	; 38
    1d10:	20 83       	st	Z, r18
    1d12:	31 97       	sbiw	r30, 0x01	; 1
    1d14:	27 e2       	ldi	r18, 0x27	; 39
    1d16:	20 83       	st	Z, r18
    1d18:	31 97       	sbiw	r30, 0x01	; 1
    1d1a:	28 e2       	ldi	r18, 0x28	; 40
    1d1c:	20 83       	st	Z, r18
    1d1e:	31 97       	sbiw	r30, 0x01	; 1
    1d20:	29 e2       	ldi	r18, 0x29	; 41
    1d22:	20 83       	st	Z, r18
    1d24:	31 97       	sbiw	r30, 0x01	; 1
    1d26:	20 e3       	ldi	r18, 0x30	; 48
    1d28:	20 83       	st	Z, r18
    1d2a:	31 97       	sbiw	r30, 0x01	; 1
    1d2c:	21 e3       	ldi	r18, 0x31	; 49
    1d2e:	20 83       	st	Z, r18
    1d30:	86 97       	sbiw	r24, 0x26	; 38
    1d32:	08 95       	ret

00001d34 <xPortStartScheduler>:
    1d34:	1b bc       	out	0x2b, r1	; 43
    1d36:	8c e7       	ldi	r24, 0x7C	; 124
    1d38:	8a bd       	out	0x2a, r24	; 42
    1d3a:	8b e0       	ldi	r24, 0x0B	; 11
    1d3c:	8e bd       	out	0x2e, r24	; 46
    1d3e:	87 b7       	in	r24, 0x37	; 55
    1d40:	80 61       	ori	r24, 0x10	; 16
    1d42:	87 bf       	out	0x37, r24	; 55
    1d44:	a0 91 f4 09 	lds	r26, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    1d48:	b0 91 f5 09 	lds	r27, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    1d4c:	cd 91       	ld	r28, X+
    1d4e:	cd bf       	out	0x3d, r28	; 61
    1d50:	dd 91       	ld	r29, X+
    1d52:	de bf       	out	0x3e, r29	; 62
    1d54:	ff 91       	pop	r31
    1d56:	ef 91       	pop	r30
    1d58:	df 91       	pop	r29
    1d5a:	cf 91       	pop	r28
    1d5c:	bf 91       	pop	r27
    1d5e:	af 91       	pop	r26
    1d60:	9f 91       	pop	r25
    1d62:	8f 91       	pop	r24
    1d64:	7f 91       	pop	r23
    1d66:	6f 91       	pop	r22
    1d68:	5f 91       	pop	r21
    1d6a:	4f 91       	pop	r20
    1d6c:	3f 91       	pop	r19
    1d6e:	2f 91       	pop	r18
    1d70:	1f 91       	pop	r17
    1d72:	0f 91       	pop	r16
    1d74:	ff 90       	pop	r15
    1d76:	ef 90       	pop	r14
    1d78:	df 90       	pop	r13
    1d7a:	cf 90       	pop	r12
    1d7c:	bf 90       	pop	r11
    1d7e:	af 90       	pop	r10
    1d80:	9f 90       	pop	r9
    1d82:	8f 90       	pop	r8
    1d84:	7f 90       	pop	r7
    1d86:	6f 90       	pop	r6
    1d88:	5f 90       	pop	r5
    1d8a:	4f 90       	pop	r4
    1d8c:	3f 90       	pop	r3
    1d8e:	2f 90       	pop	r2
    1d90:	1f 90       	pop	r1
    1d92:	0f 90       	pop	r0
    1d94:	0f be       	out	0x3f, r0	; 63
    1d96:	0f 90       	pop	r0
    1d98:	08 95       	ret
    1d9a:	81 e0       	ldi	r24, 0x01	; 1
    1d9c:	08 95       	ret

00001d9e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1d9e:	0f 92       	push	r0
    1da0:	0f b6       	in	r0, 0x3f	; 63
    1da2:	f8 94       	cli
    1da4:	0f 92       	push	r0
    1da6:	1f 92       	push	r1
    1da8:	11 24       	eor	r1, r1
    1daa:	2f 92       	push	r2
    1dac:	3f 92       	push	r3
    1dae:	4f 92       	push	r4
    1db0:	5f 92       	push	r5
    1db2:	6f 92       	push	r6
    1db4:	7f 92       	push	r7
    1db6:	8f 92       	push	r8
    1db8:	9f 92       	push	r9
    1dba:	af 92       	push	r10
    1dbc:	bf 92       	push	r11
    1dbe:	cf 92       	push	r12
    1dc0:	df 92       	push	r13
    1dc2:	ef 92       	push	r14
    1dc4:	ff 92       	push	r15
    1dc6:	0f 93       	push	r16
    1dc8:	1f 93       	push	r17
    1dca:	2f 93       	push	r18
    1dcc:	3f 93       	push	r19
    1dce:	4f 93       	push	r20
    1dd0:	5f 93       	push	r21
    1dd2:	6f 93       	push	r22
    1dd4:	7f 93       	push	r23
    1dd6:	8f 93       	push	r24
    1dd8:	9f 93       	push	r25
    1dda:	af 93       	push	r26
    1ddc:	bf 93       	push	r27
    1dde:	cf 93       	push	r28
    1de0:	df 93       	push	r29
    1de2:	ef 93       	push	r30
    1de4:	ff 93       	push	r31
    1de6:	a0 91 f4 09 	lds	r26, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    1dea:	b0 91 f5 09 	lds	r27, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    1dee:	0d b6       	in	r0, 0x3d	; 61
    1df0:	0d 92       	st	X+, r0
    1df2:	0e b6       	in	r0, 0x3e	; 62
    1df4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1df6:	d5 d5       	rcall	.+2986   	; 0x29a2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1df8:	a0 91 f4 09 	lds	r26, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    1dfc:	b0 91 f5 09 	lds	r27, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    1e00:	cd 91       	ld	r28, X+
    1e02:	cd bf       	out	0x3d, r28	; 61
    1e04:	dd 91       	ld	r29, X+
    1e06:	de bf       	out	0x3e, r29	; 62
    1e08:	ff 91       	pop	r31
    1e0a:	ef 91       	pop	r30
    1e0c:	df 91       	pop	r29
    1e0e:	cf 91       	pop	r28
    1e10:	bf 91       	pop	r27
    1e12:	af 91       	pop	r26
    1e14:	9f 91       	pop	r25
    1e16:	8f 91       	pop	r24
    1e18:	7f 91       	pop	r23
    1e1a:	6f 91       	pop	r22
    1e1c:	5f 91       	pop	r21
    1e1e:	4f 91       	pop	r20
    1e20:	3f 91       	pop	r19
    1e22:	2f 91       	pop	r18
    1e24:	1f 91       	pop	r17
    1e26:	0f 91       	pop	r16
    1e28:	ff 90       	pop	r15
    1e2a:	ef 90       	pop	r14
    1e2c:	df 90       	pop	r13
    1e2e:	cf 90       	pop	r12
    1e30:	bf 90       	pop	r11
    1e32:	af 90       	pop	r10
    1e34:	9f 90       	pop	r9
    1e36:	8f 90       	pop	r8
    1e38:	7f 90       	pop	r7
    1e3a:	6f 90       	pop	r6
    1e3c:	5f 90       	pop	r5
    1e3e:	4f 90       	pop	r4
    1e40:	3f 90       	pop	r3
    1e42:	2f 90       	pop	r2
    1e44:	1f 90       	pop	r1
    1e46:	0f 90       	pop	r0
    1e48:	0f be       	out	0x3f, r0	; 63
    1e4a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1e4c:	08 95       	ret

00001e4e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1e4e:	0f 92       	push	r0
    1e50:	0f b6       	in	r0, 0x3f	; 63
    1e52:	f8 94       	cli
    1e54:	0f 92       	push	r0
    1e56:	1f 92       	push	r1
    1e58:	11 24       	eor	r1, r1
    1e5a:	2f 92       	push	r2
    1e5c:	3f 92       	push	r3
    1e5e:	4f 92       	push	r4
    1e60:	5f 92       	push	r5
    1e62:	6f 92       	push	r6
    1e64:	7f 92       	push	r7
    1e66:	8f 92       	push	r8
    1e68:	9f 92       	push	r9
    1e6a:	af 92       	push	r10
    1e6c:	bf 92       	push	r11
    1e6e:	cf 92       	push	r12
    1e70:	df 92       	push	r13
    1e72:	ef 92       	push	r14
    1e74:	ff 92       	push	r15
    1e76:	0f 93       	push	r16
    1e78:	1f 93       	push	r17
    1e7a:	2f 93       	push	r18
    1e7c:	3f 93       	push	r19
    1e7e:	4f 93       	push	r20
    1e80:	5f 93       	push	r21
    1e82:	6f 93       	push	r22
    1e84:	7f 93       	push	r23
    1e86:	8f 93       	push	r24
    1e88:	9f 93       	push	r25
    1e8a:	af 93       	push	r26
    1e8c:	bf 93       	push	r27
    1e8e:	cf 93       	push	r28
    1e90:	df 93       	push	r29
    1e92:	ef 93       	push	r30
    1e94:	ff 93       	push	r31
    1e96:	a0 91 f4 09 	lds	r26, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    1e9a:	b0 91 f5 09 	lds	r27, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    1e9e:	0d b6       	in	r0, 0x3d	; 61
    1ea0:	0d 92       	st	X+, r0
    1ea2:	0e b6       	in	r0, 0x3e	; 62
    1ea4:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1ea6:	f5 d3       	rcall	.+2026   	; 0x2692 <xTaskIncrementTick>
    1ea8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1eaa:	7b d5       	rcall	.+2806   	; 0x29a2 <vTaskSwitchContext>
    1eac:	a0 91 f4 09 	lds	r26, 0x09F4	; 0x8009f4 <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
    1eb0:	b0 91 f5 09 	lds	r27, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    1eb4:	cd 91       	ld	r28, X+
    1eb6:	cd bf       	out	0x3d, r28	; 61
    1eb8:	dd 91       	ld	r29, X+
    1eba:	de bf       	out	0x3e, r29	; 62
    1ebc:	ff 91       	pop	r31
    1ebe:	ef 91       	pop	r30
    1ec0:	df 91       	pop	r29
    1ec2:	cf 91       	pop	r28
    1ec4:	bf 91       	pop	r27
    1ec6:	af 91       	pop	r26
    1ec8:	9f 91       	pop	r25
    1eca:	8f 91       	pop	r24
    1ecc:	7f 91       	pop	r23
    1ece:	6f 91       	pop	r22
    1ed0:	5f 91       	pop	r21
    1ed2:	4f 91       	pop	r20
    1ed4:	3f 91       	pop	r19
    1ed6:	2f 91       	pop	r18
    1ed8:	1f 91       	pop	r17
    1eda:	0f 91       	pop	r16
    1edc:	ff 90       	pop	r15
    1ede:	ef 90       	pop	r14
    1ee0:	df 90       	pop	r13
    1ee2:	cf 90       	pop	r12
    1ee4:	bf 90       	pop	r11
    1ee6:	af 90       	pop	r10
    1ee8:	9f 90       	pop	r9
    1eea:	8f 90       	pop	r8
    1eec:	7f 90       	pop	r7
    1eee:	6f 90       	pop	r6
    1ef0:	5f 90       	pop	r5
    1ef2:	4f 90       	pop	r4
    1ef4:	3f 90       	pop	r3
    1ef6:	2f 90       	pop	r2
    1ef8:	1f 90       	pop	r1
    1efa:	0f 90       	pop	r0
    1efc:	0f be       	out	0x3f, r0	; 63
    1efe:	0f 90       	pop	r0
    1f00:	08 95       	ret

00001f02 <__vector_12>:

	asm volatile ( "ret" );
    1f02:	a5 df       	rcall	.-182    	; 0x1e4e <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1f04:	18 95       	reti

00001f06 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1f06:	1f 93       	push	r17
    1f08:	cf 93       	push	r28
    1f0a:	df 93       	push	r29
    1f0c:	ec 01       	movw	r28, r24
    1f0e:	14 2f       	mov	r17, r20
    1f10:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1f12:	44 23       	and	r20, r20
    1f14:	d9 f1       	breq	.+118    	; 0x1f8c <prvCopyDataToQueue+0x86>
    1f16:	11 11       	cpse	r17, r1
    1f18:	16 c0       	rjmp	.+44     	; 0x1f46 <prvCopyDataToQueue+0x40>
    1f1a:	50 e0       	ldi	r21, 0x00	; 0
    1f1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f1e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f20:	0e 94 0c 18 	call	0x3018	; 0x3018 <memcpy>
    1f24:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1f26:	8c 81       	ldd	r24, Y+4	; 0x04
    1f28:	9d 81       	ldd	r25, Y+5	; 0x05
    1f2a:	82 0f       	add	r24, r18
    1f2c:	91 1d       	adc	r25, r1
    1f2e:	9d 83       	std	Y+5, r25	; 0x05
    1f30:	8c 83       	std	Y+4, r24	; 0x04
    1f32:	2a 81       	ldd	r18, Y+2	; 0x02
    1f34:	3b 81       	ldd	r19, Y+3	; 0x03
    1f36:	82 17       	cp	r24, r18
    1f38:	93 07       	cpc	r25, r19
    1f3a:	40 f1       	brcs	.+80     	; 0x1f8c <prvCopyDataToQueue+0x86>
    1f3c:	88 81       	ld	r24, Y
    1f3e:	99 81       	ldd	r25, Y+1	; 0x01
    1f40:	9d 83       	std	Y+5, r25	; 0x05
    1f42:	8c 83       	std	Y+4, r24	; 0x04
    1f44:	23 c0       	rjmp	.+70     	; 0x1f8c <prvCopyDataToQueue+0x86>
    1f46:	50 e0       	ldi	r21, 0x00	; 0
    1f48:	8e 81       	ldd	r24, Y+6	; 0x06
    1f4a:	9f 81       	ldd	r25, Y+7	; 0x07
    1f4c:	0e 94 0c 18 	call	0x3018	; 0x3018 <memcpy>
    1f50:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1f52:	90 e0       	ldi	r25, 0x00	; 0
    1f54:	91 95       	neg	r25
    1f56:	81 95       	neg	r24
    1f58:	91 09       	sbc	r25, r1
    1f5a:	2e 81       	ldd	r18, Y+6	; 0x06
    1f5c:	3f 81       	ldd	r19, Y+7	; 0x07
    1f5e:	28 0f       	add	r18, r24
    1f60:	39 1f       	adc	r19, r25
    1f62:	3f 83       	std	Y+7, r19	; 0x07
    1f64:	2e 83       	std	Y+6, r18	; 0x06
    1f66:	48 81       	ld	r20, Y
    1f68:	59 81       	ldd	r21, Y+1	; 0x01
    1f6a:	24 17       	cp	r18, r20
    1f6c:	35 07       	cpc	r19, r21
    1f6e:	30 f4       	brcc	.+12     	; 0x1f7c <prvCopyDataToQueue+0x76>
    1f70:	2a 81       	ldd	r18, Y+2	; 0x02
    1f72:	3b 81       	ldd	r19, Y+3	; 0x03
    1f74:	82 0f       	add	r24, r18
    1f76:	93 1f       	adc	r25, r19
    1f78:	9f 83       	std	Y+7, r25	; 0x07
    1f7a:	8e 83       	std	Y+6, r24	; 0x06
    1f7c:	12 30       	cpi	r17, 0x02	; 2
    1f7e:	31 f4       	brne	.+12     	; 0x1f8c <prvCopyDataToQueue+0x86>
    1f80:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f82:	88 23       	and	r24, r24
    1f84:	19 f0       	breq	.+6      	; 0x1f8c <prvCopyDataToQueue+0x86>
    1f86:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f88:	81 50       	subi	r24, 0x01	; 1
    1f8a:	8a 8f       	std	Y+26, r24	; 0x1a
    1f8c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f8e:	8f 5f       	subi	r24, 0xFF	; 255
    1f90:	8a 8f       	std	Y+26, r24	; 0x1a
    1f92:	80 e0       	ldi	r24, 0x00	; 0
    1f94:	df 91       	pop	r29
    1f96:	cf 91       	pop	r28
    1f98:	1f 91       	pop	r17
    1f9a:	08 95       	ret

00001f9c <prvCopyDataFromQueue>:
    1f9c:	fc 01       	movw	r30, r24
    1f9e:	44 8d       	ldd	r20, Z+28	; 0x1c
    1fa0:	44 23       	and	r20, r20
    1fa2:	a9 f0       	breq	.+42     	; 0x1fce <prvCopyDataFromQueue+0x32>
    1fa4:	50 e0       	ldi	r21, 0x00	; 0
    1fa6:	26 81       	ldd	r18, Z+6	; 0x06
    1fa8:	37 81       	ldd	r19, Z+7	; 0x07
    1faa:	24 0f       	add	r18, r20
    1fac:	35 1f       	adc	r19, r21
    1fae:	37 83       	std	Z+7, r19	; 0x07
    1fb0:	26 83       	std	Z+6, r18	; 0x06
    1fb2:	82 81       	ldd	r24, Z+2	; 0x02
    1fb4:	93 81       	ldd	r25, Z+3	; 0x03
    1fb6:	28 17       	cp	r18, r24
    1fb8:	39 07       	cpc	r19, r25
    1fba:	20 f0       	brcs	.+8      	; 0x1fc4 <prvCopyDataFromQueue+0x28>
    1fbc:	80 81       	ld	r24, Z
    1fbe:	91 81       	ldd	r25, Z+1	; 0x01
    1fc0:	97 83       	std	Z+7, r25	; 0x07
    1fc2:	86 83       	std	Z+6, r24	; 0x06
    1fc4:	cb 01       	movw	r24, r22
    1fc6:	66 81       	ldd	r22, Z+6	; 0x06
    1fc8:	77 81       	ldd	r23, Z+7	; 0x07
    1fca:	0c 94 0c 18 	jmp	0x3018	; 0x3018 <memcpy>
    1fce:	08 95       	ret

00001fd0 <prvUnlockQueue>:
    1fd0:	0f 93       	push	r16
    1fd2:	1f 93       	push	r17
    1fd4:	cf 93       	push	r28
    1fd6:	df 93       	push	r29
    1fd8:	ec 01       	movw	r28, r24
    1fda:	0f b6       	in	r0, 0x3f	; 63
    1fdc:	f8 94       	cli
    1fde:	0f 92       	push	r0
    1fe0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1fe2:	18 16       	cp	r1, r24
    1fe4:	ac f4       	brge	.+42     	; 0x2010 <prvUnlockQueue+0x40>
    1fe6:	89 89       	ldd	r24, Y+17	; 0x11
    1fe8:	81 11       	cpse	r24, r1
    1fea:	05 c0       	rjmp	.+10     	; 0x1ff6 <prvUnlockQueue+0x26>
    1fec:	11 c0       	rjmp	.+34     	; 0x2010 <prvUnlockQueue+0x40>
    1fee:	89 89       	ldd	r24, Y+17	; 0x11
    1ff0:	81 11       	cpse	r24, r1
    1ff2:	04 c0       	rjmp	.+8      	; 0x1ffc <prvUnlockQueue+0x2c>
    1ff4:	0d c0       	rjmp	.+26     	; 0x2010 <prvUnlockQueue+0x40>
    1ff6:	8e 01       	movw	r16, r28
    1ff8:	0f 5e       	subi	r16, 0xEF	; 239
    1ffa:	1f 4f       	sbci	r17, 0xFF	; 255
    1ffc:	c8 01       	movw	r24, r16
    1ffe:	79 d5       	rcall	.+2802   	; 0x2af2 <xTaskRemoveFromEventList>
    2000:	81 11       	cpse	r24, r1
    2002:	2f d6       	rcall	.+3166   	; 0x2c62 <vTaskMissedYield>
    2004:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2006:	81 50       	subi	r24, 0x01	; 1
    2008:	8e 8f       	std	Y+30, r24	; 0x1e
    200a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    200c:	18 16       	cp	r1, r24
    200e:	7c f3       	brlt	.-34     	; 0x1fee <prvUnlockQueue+0x1e>
    2010:	8f ef       	ldi	r24, 0xFF	; 255
    2012:	8e 8f       	std	Y+30, r24	; 0x1e
    2014:	0f 90       	pop	r0
    2016:	0f be       	out	0x3f, r0	; 63
    2018:	0f b6       	in	r0, 0x3f	; 63
    201a:	f8 94       	cli
    201c:	0f 92       	push	r0
    201e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2020:	18 16       	cp	r1, r24
    2022:	ac f4       	brge	.+42     	; 0x204e <prvUnlockQueue+0x7e>
    2024:	88 85       	ldd	r24, Y+8	; 0x08
    2026:	81 11       	cpse	r24, r1
    2028:	05 c0       	rjmp	.+10     	; 0x2034 <prvUnlockQueue+0x64>
    202a:	11 c0       	rjmp	.+34     	; 0x204e <prvUnlockQueue+0x7e>
    202c:	88 85       	ldd	r24, Y+8	; 0x08
    202e:	81 11       	cpse	r24, r1
    2030:	04 c0       	rjmp	.+8      	; 0x203a <prvUnlockQueue+0x6a>
    2032:	0d c0       	rjmp	.+26     	; 0x204e <prvUnlockQueue+0x7e>
    2034:	8e 01       	movw	r16, r28
    2036:	08 5f       	subi	r16, 0xF8	; 248
    2038:	1f 4f       	sbci	r17, 0xFF	; 255
    203a:	c8 01       	movw	r24, r16
    203c:	5a d5       	rcall	.+2740   	; 0x2af2 <xTaskRemoveFromEventList>
    203e:	81 11       	cpse	r24, r1
    2040:	10 d6       	rcall	.+3104   	; 0x2c62 <vTaskMissedYield>
    2042:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2044:	81 50       	subi	r24, 0x01	; 1
    2046:	8d 8f       	std	Y+29, r24	; 0x1d
    2048:	8d 8d       	ldd	r24, Y+29	; 0x1d
    204a:	18 16       	cp	r1, r24
    204c:	7c f3       	brlt	.-34     	; 0x202c <prvUnlockQueue+0x5c>
    204e:	8f ef       	ldi	r24, 0xFF	; 255
    2050:	8d 8f       	std	Y+29, r24	; 0x1d
    2052:	0f 90       	pop	r0
    2054:	0f be       	out	0x3f, r0	; 63
    2056:	df 91       	pop	r29
    2058:	cf 91       	pop	r28
    205a:	1f 91       	pop	r17
    205c:	0f 91       	pop	r16
    205e:	08 95       	ret

00002060 <xQueueGenericReset>:
    2060:	cf 93       	push	r28
    2062:	df 93       	push	r29
    2064:	ec 01       	movw	r28, r24
    2066:	0f b6       	in	r0, 0x3f	; 63
    2068:	f8 94       	cli
    206a:	0f 92       	push	r0
    206c:	48 81       	ld	r20, Y
    206e:	59 81       	ldd	r21, Y+1	; 0x01
    2070:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2072:	30 e0       	ldi	r19, 0x00	; 0
    2074:	7b 8d       	ldd	r23, Y+27	; 0x1b
    2076:	72 9f       	mul	r23, r18
    2078:	c0 01       	movw	r24, r0
    207a:	73 9f       	mul	r23, r19
    207c:	90 0d       	add	r25, r0
    207e:	11 24       	eor	r1, r1
    2080:	fa 01       	movw	r30, r20
    2082:	e8 0f       	add	r30, r24
    2084:	f9 1f       	adc	r31, r25
    2086:	fb 83       	std	Y+3, r31	; 0x03
    2088:	ea 83       	std	Y+2, r30	; 0x02
    208a:	1a 8e       	std	Y+26, r1	; 0x1a
    208c:	5d 83       	std	Y+5, r21	; 0x05
    208e:	4c 83       	std	Y+4, r20	; 0x04
    2090:	82 1b       	sub	r24, r18
    2092:	93 0b       	sbc	r25, r19
    2094:	84 0f       	add	r24, r20
    2096:	95 1f       	adc	r25, r21
    2098:	9f 83       	std	Y+7, r25	; 0x07
    209a:	8e 83       	std	Y+6, r24	; 0x06
    209c:	8f ef       	ldi	r24, 0xFF	; 255
    209e:	8d 8f       	std	Y+29, r24	; 0x1d
    20a0:	8e 8f       	std	Y+30, r24	; 0x1e
    20a2:	61 11       	cpse	r22, r1
    20a4:	0a c0       	rjmp	.+20     	; 0x20ba <xQueueGenericReset+0x5a>
    20a6:	88 85       	ldd	r24, Y+8	; 0x08
    20a8:	88 23       	and	r24, r24
    20aa:	69 f0       	breq	.+26     	; 0x20c6 <xQueueGenericReset+0x66>
    20ac:	ce 01       	movw	r24, r28
    20ae:	08 96       	adiw	r24, 0x08	; 8
    20b0:	20 d5       	rcall	.+2624   	; 0x2af2 <xTaskRemoveFromEventList>
    20b2:	81 30       	cpi	r24, 0x01	; 1
    20b4:	41 f4       	brne	.+16     	; 0x20c6 <xQueueGenericReset+0x66>
    20b6:	73 de       	rcall	.-794    	; 0x1d9e <vPortYield>
    20b8:	06 c0       	rjmp	.+12     	; 0x20c6 <xQueueGenericReset+0x66>
    20ba:	ce 01       	movw	r24, r28
    20bc:	08 96       	adiw	r24, 0x08	; 8
    20be:	44 dd       	rcall	.-1400   	; 0x1b48 <vListInitialise>
    20c0:	ce 01       	movw	r24, r28
    20c2:	41 96       	adiw	r24, 0x11	; 17
    20c4:	41 dd       	rcall	.-1406   	; 0x1b48 <vListInitialise>
    20c6:	0f 90       	pop	r0
    20c8:	0f be       	out	0x3f, r0	; 63
    20ca:	81 e0       	ldi	r24, 0x01	; 1
    20cc:	df 91       	pop	r29
    20ce:	cf 91       	pop	r28
    20d0:	08 95       	ret

000020d2 <xQueueGenericCreate>:
    20d2:	0f 93       	push	r16
    20d4:	1f 93       	push	r17
    20d6:	cf 93       	push	r28
    20d8:	df 93       	push	r29
    20da:	88 23       	and	r24, r24
    20dc:	e1 f0       	breq	.+56     	; 0x2116 <xQueueGenericCreate+0x44>
    20de:	06 2f       	mov	r16, r22
    20e0:	18 2f       	mov	r17, r24
    20e2:	8f e1       	ldi	r24, 0x1F	; 31
    20e4:	90 e0       	ldi	r25, 0x00	; 0
    20e6:	fc dc       	rcall	.-1544   	; 0x1ae0 <pvPortMalloc>
    20e8:	ec 01       	movw	r28, r24
    20ea:	89 2b       	or	r24, r25
    20ec:	b1 f0       	breq	.+44     	; 0x211a <xQueueGenericCreate+0x48>
    20ee:	10 9f       	mul	r17, r16
    20f0:	c0 01       	movw	r24, r0
    20f2:	11 24       	eor	r1, r1
    20f4:	01 96       	adiw	r24, 0x01	; 1
    20f6:	f4 dc       	rcall	.-1560   	; 0x1ae0 <pvPortMalloc>
    20f8:	99 83       	std	Y+1, r25	; 0x01
    20fa:	88 83       	st	Y, r24
    20fc:	89 2b       	or	r24, r25
    20fe:	31 f0       	breq	.+12     	; 0x210c <xQueueGenericCreate+0x3a>
    2100:	1b 8f       	std	Y+27, r17	; 0x1b
    2102:	0c 8f       	std	Y+28, r16	; 0x1c
    2104:	61 e0       	ldi	r22, 0x01	; 1
    2106:	ce 01       	movw	r24, r28
    2108:	ab df       	rcall	.-170    	; 0x2060 <xQueueGenericReset>
    210a:	07 c0       	rjmp	.+14     	; 0x211a <xQueueGenericCreate+0x48>
    210c:	ce 01       	movw	r24, r28
    210e:	1b dd       	rcall	.-1482   	; 0x1b46 <vPortFree>
    2110:	c0 e0       	ldi	r28, 0x00	; 0
    2112:	d0 e0       	ldi	r29, 0x00	; 0
    2114:	02 c0       	rjmp	.+4      	; 0x211a <xQueueGenericCreate+0x48>
    2116:	c0 e0       	ldi	r28, 0x00	; 0
    2118:	d0 e0       	ldi	r29, 0x00	; 0
    211a:	ce 01       	movw	r24, r28
    211c:	df 91       	pop	r29
    211e:	cf 91       	pop	r28
    2120:	1f 91       	pop	r17
    2122:	0f 91       	pop	r16
    2124:	08 95       	ret

00002126 <xQueueGenericSend>:
    2126:	9f 92       	push	r9
    2128:	af 92       	push	r10
    212a:	bf 92       	push	r11
    212c:	cf 92       	push	r12
    212e:	df 92       	push	r13
    2130:	ef 92       	push	r14
    2132:	ff 92       	push	r15
    2134:	0f 93       	push	r16
    2136:	1f 93       	push	r17
    2138:	cf 93       	push	r28
    213a:	df 93       	push	r29
    213c:	00 d0       	rcall	.+0      	; 0x213e <xQueueGenericSend+0x18>
    213e:	00 d0       	rcall	.+0      	; 0x2140 <xQueueGenericSend+0x1a>
    2140:	1f 92       	push	r1
    2142:	cd b7       	in	r28, 0x3d	; 61
    2144:	de b7       	in	r29, 0x3e	; 62
    2146:	8c 01       	movw	r16, r24
    2148:	6b 01       	movw	r12, r22
    214a:	5d 83       	std	Y+5, r21	; 0x05
    214c:	4c 83       	std	Y+4, r20	; 0x04
    214e:	a2 2e       	mov	r10, r18
    2150:	b1 2c       	mov	r11, r1
    2152:	99 24       	eor	r9, r9
    2154:	93 94       	inc	r9
    2156:	7c 01       	movw	r14, r24
    2158:	88 e0       	ldi	r24, 0x08	; 8
    215a:	e8 0e       	add	r14, r24
    215c:	f1 1c       	adc	r15, r1
    215e:	0f b6       	in	r0, 0x3f	; 63
    2160:	f8 94       	cli
    2162:	0f 92       	push	r0
    2164:	f8 01       	movw	r30, r16
    2166:	92 8d       	ldd	r25, Z+26	; 0x1a
    2168:	83 8d       	ldd	r24, Z+27	; 0x1b
    216a:	98 17       	cp	r25, r24
    216c:	18 f0       	brcs	.+6      	; 0x2174 <xQueueGenericSend+0x4e>
    216e:	f2 e0       	ldi	r31, 0x02	; 2
    2170:	af 12       	cpse	r10, r31
    2172:	15 c0       	rjmp	.+42     	; 0x219e <xQueueGenericSend+0x78>
    2174:	4a 2d       	mov	r20, r10
    2176:	b6 01       	movw	r22, r12
    2178:	c8 01       	movw	r24, r16
    217a:	c5 de       	rcall	.-630    	; 0x1f06 <prvCopyDataToQueue>
    217c:	f8 01       	movw	r30, r16
    217e:	91 89       	ldd	r25, Z+17	; 0x11
    2180:	99 23       	and	r25, r25
    2182:	39 f0       	breq	.+14     	; 0x2192 <xQueueGenericSend+0x6c>
    2184:	c8 01       	movw	r24, r16
    2186:	41 96       	adiw	r24, 0x11	; 17
    2188:	b4 d4       	rcall	.+2408   	; 0x2af2 <xTaskRemoveFromEventList>
    218a:	81 30       	cpi	r24, 0x01	; 1
    218c:	21 f4       	brne	.+8      	; 0x2196 <xQueueGenericSend+0x70>
    218e:	07 de       	rcall	.-1010   	; 0x1d9e <vPortYield>
    2190:	02 c0       	rjmp	.+4      	; 0x2196 <xQueueGenericSend+0x70>
    2192:	81 11       	cpse	r24, r1
    2194:	04 de       	rcall	.-1016   	; 0x1d9e <vPortYield>
    2196:	0f 90       	pop	r0
    2198:	0f be       	out	0x3f, r0	; 63
    219a:	81 e0       	ldi	r24, 0x01	; 1
    219c:	45 c0       	rjmp	.+138    	; 0x2228 <xQueueGenericSend+0x102>
    219e:	8c 81       	ldd	r24, Y+4	; 0x04
    21a0:	9d 81       	ldd	r25, Y+5	; 0x05
    21a2:	89 2b       	or	r24, r25
    21a4:	21 f4       	brne	.+8      	; 0x21ae <xQueueGenericSend+0x88>
    21a6:	0f 90       	pop	r0
    21a8:	0f be       	out	0x3f, r0	; 63
    21aa:	80 e0       	ldi	r24, 0x00	; 0
    21ac:	3d c0       	rjmp	.+122    	; 0x2228 <xQueueGenericSend+0x102>
    21ae:	b1 10       	cpse	r11, r1
    21b0:	04 c0       	rjmp	.+8      	; 0x21ba <xQueueGenericSend+0x94>
    21b2:	ce 01       	movw	r24, r28
    21b4:	01 96       	adiw	r24, 0x01	; 1
    21b6:	19 d5       	rcall	.+2610   	; 0x2bea <vTaskSetTimeOutState>
    21b8:	b9 2c       	mov	r11, r9
    21ba:	0f 90       	pop	r0
    21bc:	0f be       	out	0x3f, r0	; 63
    21be:	63 d2       	rcall	.+1222   	; 0x2686 <vTaskSuspendAll>
    21c0:	0f b6       	in	r0, 0x3f	; 63
    21c2:	f8 94       	cli
    21c4:	0f 92       	push	r0
    21c6:	f8 01       	movw	r30, r16
    21c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    21ca:	8f 3f       	cpi	r24, 0xFF	; 255
    21cc:	09 f4       	brne	.+2      	; 0x21d0 <xQueueGenericSend+0xaa>
    21ce:	15 8e       	std	Z+29, r1	; 0x1d
    21d0:	f8 01       	movw	r30, r16
    21d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    21d4:	8f 3f       	cpi	r24, 0xFF	; 255
    21d6:	09 f4       	brne	.+2      	; 0x21da <xQueueGenericSend+0xb4>
    21d8:	16 8e       	std	Z+30, r1	; 0x1e
    21da:	0f 90       	pop	r0
    21dc:	0f be       	out	0x3f, r0	; 63
    21de:	be 01       	movw	r22, r28
    21e0:	6c 5f       	subi	r22, 0xFC	; 252
    21e2:	7f 4f       	sbci	r23, 0xFF	; 255
    21e4:	ce 01       	movw	r24, r28
    21e6:	01 96       	adiw	r24, 0x01	; 1
    21e8:	0b d5       	rcall	.+2582   	; 0x2c00 <xTaskCheckForTimeOut>
    21ea:	81 11       	cpse	r24, r1
    21ec:	19 c0       	rjmp	.+50     	; 0x2220 <xQueueGenericSend+0xfa>
    21ee:	0f b6       	in	r0, 0x3f	; 63
    21f0:	f8 94       	cli
    21f2:	0f 92       	push	r0
    21f4:	f8 01       	movw	r30, r16
    21f6:	92 8d       	ldd	r25, Z+26	; 0x1a
    21f8:	0f 90       	pop	r0
    21fa:	0f be       	out	0x3f, r0	; 63
    21fc:	83 8d       	ldd	r24, Z+27	; 0x1b
    21fe:	98 13       	cpse	r25, r24
    2200:	0b c0       	rjmp	.+22     	; 0x2218 <xQueueGenericSend+0xf2>
    2202:	6c 81       	ldd	r22, Y+4	; 0x04
    2204:	7d 81       	ldd	r23, Y+5	; 0x05
    2206:	c7 01       	movw	r24, r14
    2208:	39 d4       	rcall	.+2162   	; 0x2a7c <vTaskPlaceOnEventList>
    220a:	c8 01       	movw	r24, r16
    220c:	e1 de       	rcall	.-574    	; 0x1fd0 <prvUnlockQueue>
    220e:	fa d2       	rcall	.+1524   	; 0x2804 <xTaskResumeAll>
    2210:	81 11       	cpse	r24, r1
    2212:	a5 cf       	rjmp	.-182    	; 0x215e <xQueueGenericSend+0x38>
    2214:	c4 dd       	rcall	.-1144   	; 0x1d9e <vPortYield>
    2216:	a3 cf       	rjmp	.-186    	; 0x215e <xQueueGenericSend+0x38>
    2218:	c8 01       	movw	r24, r16
    221a:	da de       	rcall	.-588    	; 0x1fd0 <prvUnlockQueue>
    221c:	f3 d2       	rcall	.+1510   	; 0x2804 <xTaskResumeAll>
    221e:	9f cf       	rjmp	.-194    	; 0x215e <xQueueGenericSend+0x38>
    2220:	c8 01       	movw	r24, r16
    2222:	d6 de       	rcall	.-596    	; 0x1fd0 <prvUnlockQueue>
    2224:	ef d2       	rcall	.+1502   	; 0x2804 <xTaskResumeAll>
    2226:	80 e0       	ldi	r24, 0x00	; 0
    2228:	0f 90       	pop	r0
    222a:	0f 90       	pop	r0
    222c:	0f 90       	pop	r0
    222e:	0f 90       	pop	r0
    2230:	0f 90       	pop	r0
    2232:	df 91       	pop	r29
    2234:	cf 91       	pop	r28
    2236:	1f 91       	pop	r17
    2238:	0f 91       	pop	r16
    223a:	ff 90       	pop	r15
    223c:	ef 90       	pop	r14
    223e:	df 90       	pop	r13
    2240:	cf 90       	pop	r12
    2242:	bf 90       	pop	r11
    2244:	af 90       	pop	r10
    2246:	9f 90       	pop	r9
    2248:	08 95       	ret

0000224a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    224a:	9f 92       	push	r9
    224c:	af 92       	push	r10
    224e:	bf 92       	push	r11
    2250:	cf 92       	push	r12
    2252:	df 92       	push	r13
    2254:	ef 92       	push	r14
    2256:	ff 92       	push	r15
    2258:	0f 93       	push	r16
    225a:	1f 93       	push	r17
    225c:	cf 93       	push	r28
    225e:	df 93       	push	r29
    2260:	00 d0       	rcall	.+0      	; 0x2262 <xQueueGenericReceive+0x18>
    2262:	00 d0       	rcall	.+0      	; 0x2264 <xQueueGenericReceive+0x1a>
    2264:	1f 92       	push	r1
    2266:	cd b7       	in	r28, 0x3d	; 61
    2268:	de b7       	in	r29, 0x3e	; 62
    226a:	8c 01       	movw	r16, r24
    226c:	6b 01       	movw	r12, r22
    226e:	5d 83       	std	Y+5, r21	; 0x05
    2270:	4c 83       	std	Y+4, r20	; 0x04
    2272:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE;
    2274:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2276:	aa 24       	eor	r10, r10
    2278:	a3 94       	inc	r10
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    227a:	7c 01       	movw	r14, r24
    227c:	81 e1       	ldi	r24, 0x11	; 17
    227e:	e8 0e       	add	r14, r24
    2280:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2282:	0f b6       	in	r0, 0x3f	; 63
    2284:	f8 94       	cli
    2286:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2288:	f8 01       	movw	r30, r16
    228a:	82 8d       	ldd	r24, Z+26	; 0x1a
    228c:	88 23       	and	r24, r24
    228e:	21 f1       	breq	.+72     	; 0x22d8 <xQueueGenericReceive+0x8e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2290:	e6 80       	ldd	r14, Z+6	; 0x06
    2292:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2294:	b6 01       	movw	r22, r12
    2296:	c8 01       	movw	r24, r16
    2298:	81 de       	rcall	.-766    	; 0x1f9c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    229a:	91 10       	cpse	r9, r1
    229c:	0e c0       	rjmp	.+28     	; 0x22ba <xQueueGenericReceive+0x70>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    229e:	f8 01       	movw	r30, r16
    22a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    22a2:	81 50       	subi	r24, 0x01	; 1
    22a4:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22a6:	80 85       	ldd	r24, Z+8	; 0x08
    22a8:	88 23       	and	r24, r24
    22aa:	91 f0       	breq	.+36     	; 0x22d0 <xQueueGenericReceive+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    22ac:	c8 01       	movw	r24, r16
    22ae:	08 96       	adiw	r24, 0x08	; 8
    22b0:	20 d4       	rcall	.+2112   	; 0x2af2 <xTaskRemoveFromEventList>
    22b2:	81 30       	cpi	r24, 0x01	; 1
						{
							queueYIELD_IF_USING_PREEMPTION();
    22b4:	69 f4       	brne	.+26     	; 0x22d0 <xQueueGenericReceive+0x86>
    22b6:	73 dd       	rcall	.-1306   	; 0x1d9e <vPortYield>
    22b8:	0b c0       	rjmp	.+22     	; 0x22d0 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    22ba:	f8 01       	movw	r30, r16
    22bc:	f7 82       	std	Z+7, r15	; 0x07
    22be:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22c0:	81 89       	ldd	r24, Z+17	; 0x11
    22c2:	88 23       	and	r24, r24
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22c4:	29 f0       	breq	.+10     	; 0x22d0 <xQueueGenericReceive+0x86>
    22c6:	c8 01       	movw	r24, r16
    22c8:	41 96       	adiw	r24, 0x11	; 17
    22ca:	13 d4       	rcall	.+2086   	; 0x2af2 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    22cc:	81 11       	cpse	r24, r1
    22ce:	67 dd       	rcall	.-1330   	; 0x1d9e <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    22d0:	0f 90       	pop	r0
    22d2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    22d4:	81 e0       	ldi	r24, 0x01	; 1
    22d6:	44 c0       	rjmp	.+136    	; 0x2360 <xQueueGenericReceive+0x116>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    22d8:	8c 81       	ldd	r24, Y+4	; 0x04
    22da:	9d 81       	ldd	r25, Y+5	; 0x05
    22dc:	89 2b       	or	r24, r25
    22de:	21 f4       	brne	.+8      	; 0x22e8 <xQueueGenericReceive+0x9e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    22e0:	0f 90       	pop	r0
    22e2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    22e4:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
    22e6:	3c c0       	rjmp	.+120    	; 0x2360 <xQueueGenericReceive+0x116>
    22e8:	b1 10       	cpse	r11, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    22ea:	04 c0       	rjmp	.+8      	; 0x22f4 <xQueueGenericReceive+0xaa>
    22ec:	ce 01       	movw	r24, r28
    22ee:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
    22f0:	7c d4       	rcall	.+2296   	; 0x2bea <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    22f2:	ba 2c       	mov	r11, r10
    22f4:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    22f6:	0f be       	out	0x3f, r0	; 63
    22f8:	c6 d1       	rcall	.+908    	; 0x2686 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    22fa:	0f b6       	in	r0, 0x3f	; 63
    22fc:	f8 94       	cli
    22fe:	0f 92       	push	r0
    2300:	f8 01       	movw	r30, r16
    2302:	85 8d       	ldd	r24, Z+29	; 0x1d
    2304:	8f 3f       	cpi	r24, 0xFF	; 255
    2306:	09 f4       	brne	.+2      	; 0x230a <xQueueGenericReceive+0xc0>
    2308:	15 8e       	std	Z+29, r1	; 0x1d
    230a:	f8 01       	movw	r30, r16
    230c:	86 8d       	ldd	r24, Z+30	; 0x1e
    230e:	8f 3f       	cpi	r24, 0xFF	; 255
    2310:	09 f4       	brne	.+2      	; 0x2314 <xQueueGenericReceive+0xca>
    2312:	16 8e       	std	Z+30, r1	; 0x1e
    2314:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2316:	0f be       	out	0x3f, r0	; 63
    2318:	be 01       	movw	r22, r28
    231a:	6c 5f       	subi	r22, 0xFC	; 252
    231c:	7f 4f       	sbci	r23, 0xFF	; 255
    231e:	ce 01       	movw	r24, r28
    2320:	01 96       	adiw	r24, 0x01	; 1
    2322:	6e d4       	rcall	.+2268   	; 0x2c00 <xTaskCheckForTimeOut>
    2324:	81 11       	cpse	r24, r1
    2326:	18 c0       	rjmp	.+48     	; 0x2358 <xQueueGenericReceive+0x10e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2328:	0f b6       	in	r0, 0x3f	; 63
    232a:	f8 94       	cli
    232c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    232e:	f8 01       	movw	r30, r16
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2330:	82 8d       	ldd	r24, Z+26	; 0x1a
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2332:	0f 90       	pop	r0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2334:	0f be       	out	0x3f, r0	; 63
    2336:	81 11       	cpse	r24, r1
    2338:	0b c0       	rjmp	.+22     	; 0x2350 <xQueueGenericReceive+0x106>
    233a:	6c 81       	ldd	r22, Y+4	; 0x04
				prvUnlockQueue( pxQueue );
    233c:	7d 81       	ldd	r23, Y+5	; 0x05
    233e:	c7 01       	movw	r24, r14
				if( xTaskResumeAll() == pdFALSE )
    2340:	9d d3       	rcall	.+1850   	; 0x2a7c <vTaskPlaceOnEventList>
    2342:	c8 01       	movw	r24, r16
				{
					portYIELD_WITHIN_API();
    2344:	45 de       	rcall	.-886    	; 0x1fd0 <prvUnlockQueue>
    2346:	5e d2       	rcall	.+1212   	; 0x2804 <xTaskResumeAll>
    2348:	81 11       	cpse	r24, r1
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    234a:	9b cf       	rjmp	.-202    	; 0x2282 <xQueueGenericReceive+0x38>
    234c:	28 dd       	rcall	.-1456   	; 0x1d9e <vPortYield>
    234e:	99 cf       	rjmp	.-206    	; 0x2282 <xQueueGenericReceive+0x38>
				( void ) xTaskResumeAll();
    2350:	c8 01       	movw	r24, r16
    2352:	3e de       	rcall	.-900    	; 0x1fd0 <prvUnlockQueue>
    2354:	57 d2       	rcall	.+1198   	; 0x2804 <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2356:	95 cf       	rjmp	.-214    	; 0x2282 <xQueueGenericReceive+0x38>
    2358:	c8 01       	movw	r24, r16
    235a:	3a de       	rcall	.-908    	; 0x1fd0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    235c:	53 d2       	rcall	.+1190   	; 0x2804 <xTaskResumeAll>
    235e:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2360:	0f 90       	pop	r0
		}
	}
}
    2362:	0f 90       	pop	r0
    2364:	0f 90       	pop	r0
    2366:	0f 90       	pop	r0
    2368:	0f 90       	pop	r0
    236a:	df 91       	pop	r29
    236c:	cf 91       	pop	r28
    236e:	1f 91       	pop	r17
    2370:	0f 91       	pop	r16
    2372:	ff 90       	pop	r15
    2374:	ef 90       	pop	r14
    2376:	df 90       	pop	r13
    2378:	cf 90       	pop	r12
    237a:	bf 90       	pop	r11
    237c:	af 90       	pop	r10
    237e:	9f 90       	pop	r9
    2380:	08 95       	ret

00002382 <prvResetNextTaskUnblockTime>:
    2382:	e0 91 aa 09 	lds	r30, 0x09AA	; 0x8009aa <pxDelayedTaskList>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2386:	f0 91 ab 09 	lds	r31, 0x09AB	; 0x8009ab <pxDelayedTaskList+0x1>
    238a:	80 81       	ld	r24, Z
    238c:	81 11       	cpse	r24, r1
    238e:	07 c0       	rjmp	.+14     	; 0x239e <prvResetNextTaskUnblockTime+0x1c>
    2390:	8f ef       	ldi	r24, 0xFF	; 255
    2392:	9f ef       	ldi	r25, 0xFF	; 255
    2394:	90 93 04 01 	sts	0x0104, r25	; 0x800104 <xNextTaskUnblockTime+0x1>
    2398:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <xNextTaskUnblockTime>
    239c:	08 95       	ret
    239e:	e0 91 aa 09 	lds	r30, 0x09AA	; 0x8009aa <pxDelayedTaskList>
    23a2:	f0 91 ab 09 	lds	r31, 0x09AB	; 0x8009ab <pxDelayedTaskList+0x1>
    23a6:	05 80       	ldd	r0, Z+5	; 0x05
    23a8:	f6 81       	ldd	r31, Z+6	; 0x06
    23aa:	e0 2d       	mov	r30, r0
    23ac:	06 80       	ldd	r0, Z+6	; 0x06
    23ae:	f7 81       	ldd	r31, Z+7	; 0x07
    23b0:	e0 2d       	mov	r30, r0
    23b2:	82 81       	ldd	r24, Z+2	; 0x02
    23b4:	93 81       	ldd	r25, Z+3	; 0x03
    23b6:	90 93 04 01 	sts	0x0104, r25	; 0x800104 <xNextTaskUnblockTime+0x1>
    23ba:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <xNextTaskUnblockTime>
    23be:	08 95       	ret

000023c0 <prvAddCurrentTaskToDelayedList>:
    23c0:	cf 93       	push	r28
    23c2:	df 93       	push	r29
    23c4:	ec 01       	movw	r28, r24
    23c6:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    23ca:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    23ce:	93 83       	std	Z+3, r25	; 0x03
    23d0:	82 83       	std	Z+2, r24	; 0x02
    23d2:	80 91 92 09 	lds	r24, 0x0992	; 0x800992 <xTickCount>
    23d6:	90 91 93 09 	lds	r25, 0x0993	; 0x800993 <xTickCount+0x1>
    23da:	c8 17       	cp	r28, r24
    23dc:	d9 07       	cpc	r29, r25
    23de:	60 f4       	brcc	.+24     	; 0x23f8 <prvAddCurrentTaskToDelayedList+0x38>
    23e0:	60 91 f4 09 	lds	r22, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    23e4:	70 91 f5 09 	lds	r23, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    23e8:	80 91 a8 09 	lds	r24, 0x09A8	; 0x8009a8 <pxOverflowDelayedTaskList>
    23ec:	90 91 a9 09 	lds	r25, 0x09A9	; 0x8009a9 <pxOverflowDelayedTaskList+0x1>
    23f0:	6e 5f       	subi	r22, 0xFE	; 254
    23f2:	7f 4f       	sbci	r23, 0xFF	; 255
    23f4:	dc db       	rcall	.-2120   	; 0x1bae <vListInsert>
    23f6:	16 c0       	rjmp	.+44     	; 0x2424 <prvAddCurrentTaskToDelayedList+0x64>
    23f8:	60 91 f4 09 	lds	r22, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    23fc:	70 91 f5 09 	lds	r23, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2400:	80 91 aa 09 	lds	r24, 0x09AA	; 0x8009aa <pxDelayedTaskList>
    2404:	90 91 ab 09 	lds	r25, 0x09AB	; 0x8009ab <pxDelayedTaskList+0x1>
    2408:	6e 5f       	subi	r22, 0xFE	; 254
    240a:	7f 4f       	sbci	r23, 0xFF	; 255
    240c:	d0 db       	rcall	.-2144   	; 0x1bae <vListInsert>
    240e:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <xNextTaskUnblockTime>
    2412:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <xNextTaskUnblockTime+0x1>
    2416:	c8 17       	cp	r28, r24
    2418:	d9 07       	cpc	r29, r25
    241a:	20 f4       	brcc	.+8      	; 0x2424 <prvAddCurrentTaskToDelayedList+0x64>
    241c:	d0 93 04 01 	sts	0x0104, r29	; 0x800104 <xNextTaskUnblockTime+0x1>
    2420:	c0 93 03 01 	sts	0x0103, r28	; 0x800103 <xNextTaskUnblockTime>
    2424:	df 91       	pop	r29
    2426:	cf 91       	pop	r28
    2428:	08 95       	ret

0000242a <xTaskGenericCreate>:
    242a:	4f 92       	push	r4
    242c:	5f 92       	push	r5
    242e:	6f 92       	push	r6
    2430:	7f 92       	push	r7
    2432:	8f 92       	push	r8
    2434:	9f 92       	push	r9
    2436:	af 92       	push	r10
    2438:	bf 92       	push	r11
    243a:	cf 92       	push	r12
    243c:	df 92       	push	r13
    243e:	ef 92       	push	r14
    2440:	ff 92       	push	r15
    2442:	0f 93       	push	r16
    2444:	1f 93       	push	r17
    2446:	cf 93       	push	r28
    2448:	df 93       	push	r29
    244a:	4c 01       	movw	r8, r24
    244c:	eb 01       	movw	r28, r22
    244e:	5a 01       	movw	r10, r20
    2450:	29 01       	movw	r4, r18
    2452:	87 e3       	ldi	r24, 0x37	; 55
    2454:	90 e0       	ldi	r25, 0x00	; 0
    2456:	44 db       	rcall	.-2424   	; 0x1ae0 <pvPortMalloc>
    2458:	3c 01       	movw	r6, r24
    245a:	00 97       	sbiw	r24, 0x00	; 0
    245c:	09 f4       	brne	.+2      	; 0x2460 <xTaskGenericCreate+0x36>
    245e:	d8 c0       	rjmp	.+432    	; 0x2610 <xTaskGenericCreate+0x1e6>
    2460:	c1 14       	cp	r12, r1
    2462:	d1 04       	cpc	r13, r1
    2464:	09 f0       	breq	.+2      	; 0x2468 <xTaskGenericCreate+0x3e>
    2466:	d0 c0       	rjmp	.+416    	; 0x2608 <xTaskGenericCreate+0x1de>
    2468:	c5 01       	movw	r24, r10
    246a:	3a db       	rcall	.-2444   	; 0x1ae0 <pvPortMalloc>
    246c:	f3 01       	movw	r30, r6
    246e:	90 8f       	std	Z+24, r25	; 0x18
    2470:	87 8b       	std	Z+23, r24	; 0x17
    2472:	89 2b       	or	r24, r25
    2474:	19 f4       	brne	.+6      	; 0x247c <xTaskGenericCreate+0x52>
    2476:	c3 01       	movw	r24, r6
    2478:	66 db       	rcall	.-2356   	; 0x1b46 <vPortFree>
    247a:	ca c0       	rjmp	.+404    	; 0x2610 <xTaskGenericCreate+0x1e6>
    247c:	f1 e0       	ldi	r31, 0x01	; 1
    247e:	af 1a       	sub	r10, r31
    2480:	b1 08       	sbc	r11, r1
    2482:	f3 01       	movw	r30, r6
    2484:	87 89       	ldd	r24, Z+23	; 0x17
    2486:	90 8d       	ldd	r25, Z+24	; 0x18
    2488:	a8 0e       	add	r10, r24
    248a:	b9 1e       	adc	r11, r25
    248c:	88 81       	ld	r24, Y
    248e:	81 8f       	std	Z+25, r24	; 0x19
    2490:	88 81       	ld	r24, Y
    2492:	88 23       	and	r24, r24
    2494:	81 f0       	breq	.+32     	; 0x24b6 <xTaskGenericCreate+0x8c>
    2496:	d3 01       	movw	r26, r6
    2498:	5a 96       	adiw	r26, 0x1a	; 26
    249a:	fe 01       	movw	r30, r28
    249c:	31 96       	adiw	r30, 0x01	; 1
    249e:	9e 01       	movw	r18, r28
    24a0:	22 5e       	subi	r18, 0xE2	; 226
    24a2:	3f 4f       	sbci	r19, 0xFF	; 255
    24a4:	ef 01       	movw	r28, r30
    24a6:	81 91       	ld	r24, Z+
    24a8:	8d 93       	st	X+, r24
    24aa:	88 81       	ld	r24, Y
    24ac:	88 23       	and	r24, r24
    24ae:	19 f0       	breq	.+6      	; 0x24b6 <xTaskGenericCreate+0x8c>
    24b0:	2e 17       	cp	r18, r30
    24b2:	3f 07       	cpc	r19, r31
    24b4:	b9 f7       	brne	.-18     	; 0x24a4 <xTaskGenericCreate+0x7a>
    24b6:	f3 01       	movw	r30, r6
    24b8:	16 aa       	std	Z+54, r1	; 0x36
    24ba:	10 2f       	mov	r17, r16
    24bc:	06 30       	cpi	r16, 0x06	; 6
    24be:	08 f0       	brcs	.+2      	; 0x24c2 <xTaskGenericCreate+0x98>
    24c0:	15 e0       	ldi	r17, 0x05	; 5
    24c2:	f3 01       	movw	r30, r6
    24c4:	16 8b       	std	Z+22, r17	; 0x16
    24c6:	e3 01       	movw	r28, r6
    24c8:	22 96       	adiw	r28, 0x02	; 2
    24ca:	ce 01       	movw	r24, r28
    24cc:	4b db       	rcall	.-2410   	; 0x1b64 <vListInitialiseItem>
    24ce:	c3 01       	movw	r24, r6
    24d0:	0c 96       	adiw	r24, 0x0c	; 12
    24d2:	48 db       	rcall	.-2416   	; 0x1b64 <vListInitialiseItem>
    24d4:	f3 01       	movw	r30, r6
    24d6:	71 86       	std	Z+9, r7	; 0x09
    24d8:	60 86       	std	Z+8, r6	; 0x08
    24da:	86 e0       	ldi	r24, 0x06	; 6
    24dc:	90 e0       	ldi	r25, 0x00	; 0
    24de:	81 1b       	sub	r24, r17
    24e0:	91 09       	sbc	r25, r1
    24e2:	95 87       	std	Z+13, r25	; 0x0d
    24e4:	84 87       	std	Z+12, r24	; 0x0c
    24e6:	73 8a       	std	Z+19, r7	; 0x13
    24e8:	62 8a       	std	Z+18, r6	; 0x12
    24ea:	a2 01       	movw	r20, r4
    24ec:	b4 01       	movw	r22, r8
    24ee:	c5 01       	movw	r24, r10
    24f0:	b5 db       	rcall	.-2198   	; 0x1c5c <pxPortInitialiseStack>
    24f2:	f3 01       	movw	r30, r6
    24f4:	91 83       	std	Z+1, r25	; 0x01
    24f6:	80 83       	st	Z, r24
    24f8:	e1 14       	cp	r14, r1
    24fa:	f1 04       	cpc	r15, r1
    24fc:	19 f0       	breq	.+6      	; 0x2504 <xTaskGenericCreate+0xda>
    24fe:	f7 01       	movw	r30, r14
    2500:	71 82       	std	Z+1, r7	; 0x01
    2502:	60 82       	st	Z, r6
    2504:	0f b6       	in	r0, 0x3f	; 63
    2506:	f8 94       	cli
    2508:	0f 92       	push	r0
    250a:	80 91 94 09 	lds	r24, 0x0994	; 0x800994 <uxCurrentNumberOfTasks>
    250e:	8f 5f       	subi	r24, 0xFF	; 255
    2510:	80 93 94 09 	sts	0x0994, r24	; 0x800994 <uxCurrentNumberOfTasks>
    2514:	80 91 f4 09 	lds	r24, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2518:	90 91 f5 09 	lds	r25, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    251c:	89 2b       	or	r24, r25
    251e:	b1 f5       	brne	.+108    	; 0x258c <xTaskGenericCreate+0x162>
    2520:	70 92 f5 09 	sts	0x09F5, r7	; 0x8009f5 <pxCurrentTCB+0x1>
    2524:	60 92 f4 09 	sts	0x09F4, r6	; 0x8009f4 <pxCurrentTCB>
    2528:	80 91 94 09 	lds	r24, 0x0994	; 0x800994 <uxCurrentNumberOfTasks>
    252c:	81 30       	cpi	r24, 0x01	; 1
    252e:	09 f0       	breq	.+2      	; 0x2532 <xTaskGenericCreate+0x108>
    2530:	3c c0       	rjmp	.+120    	; 0x25aa <xTaskGenericCreate+0x180>
    2532:	0f 2e       	mov	r0, r31
    2534:	fe eb       	ldi	r31, 0xBE	; 190
    2536:	ef 2e       	mov	r14, r31
    2538:	f9 e0       	ldi	r31, 0x09	; 9
    253a:	ff 2e       	mov	r15, r31
    253c:	f0 2d       	mov	r31, r0
    253e:	0f 2e       	mov	r0, r31
    2540:	f4 ef       	ldi	r31, 0xF4	; 244
    2542:	cf 2e       	mov	r12, r31
    2544:	f9 e0       	ldi	r31, 0x09	; 9
    2546:	df 2e       	mov	r13, r31
    2548:	f0 2d       	mov	r31, r0
    254a:	c7 01       	movw	r24, r14
    254c:	fd da       	rcall	.-2566   	; 0x1b48 <vListInitialise>
    254e:	f9 e0       	ldi	r31, 0x09	; 9
    2550:	ef 0e       	add	r14, r31
    2552:	f1 1c       	adc	r15, r1
    2554:	ce 14       	cp	r12, r14
    2556:	df 04       	cpc	r13, r15
    2558:	c1 f7       	brne	.-16     	; 0x254a <xTaskGenericCreate+0x120>
    255a:	85 eb       	ldi	r24, 0xB5	; 181
    255c:	99 e0       	ldi	r25, 0x09	; 9
    255e:	f4 da       	rcall	.-2584   	; 0x1b48 <vListInitialise>
    2560:	8c ea       	ldi	r24, 0xAC	; 172
    2562:	99 e0       	ldi	r25, 0x09	; 9
    2564:	f1 da       	rcall	.-2590   	; 0x1b48 <vListInitialise>
    2566:	8f e9       	ldi	r24, 0x9F	; 159
    2568:	99 e0       	ldi	r25, 0x09	; 9
    256a:	ee da       	rcall	.-2596   	; 0x1b48 <vListInitialise>
    256c:	86 e9       	ldi	r24, 0x96	; 150
    256e:	99 e0       	ldi	r25, 0x09	; 9
    2570:	eb da       	rcall	.-2602   	; 0x1b48 <vListInitialise>
    2572:	85 eb       	ldi	r24, 0xB5	; 181
    2574:	99 e0       	ldi	r25, 0x09	; 9
    2576:	90 93 ab 09 	sts	0x09AB, r25	; 0x8009ab <pxDelayedTaskList+0x1>
    257a:	80 93 aa 09 	sts	0x09AA, r24	; 0x8009aa <pxDelayedTaskList>
    257e:	8c ea       	ldi	r24, 0xAC	; 172
    2580:	99 e0       	ldi	r25, 0x09	; 9
    2582:	90 93 a9 09 	sts	0x09A9, r25	; 0x8009a9 <pxOverflowDelayedTaskList+0x1>
    2586:	80 93 a8 09 	sts	0x09A8, r24	; 0x8009a8 <pxOverflowDelayedTaskList>
    258a:	0f c0       	rjmp	.+30     	; 0x25aa <xTaskGenericCreate+0x180>
    258c:	80 91 90 09 	lds	r24, 0x0990	; 0x800990 <xSchedulerRunning>
    2590:	81 11       	cpse	r24, r1
    2592:	0b c0       	rjmp	.+22     	; 0x25aa <xTaskGenericCreate+0x180>
    2594:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2598:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    259c:	86 89       	ldd	r24, Z+22	; 0x16
    259e:	08 17       	cp	r16, r24
    25a0:	20 f0       	brcs	.+8      	; 0x25aa <xTaskGenericCreate+0x180>
    25a2:	70 92 f5 09 	sts	0x09F5, r7	; 0x8009f5 <pxCurrentTCB+0x1>
    25a6:	60 92 f4 09 	sts	0x09F4, r6	; 0x8009f4 <pxCurrentTCB>
    25aa:	80 91 8c 09 	lds	r24, 0x098C	; 0x80098c <uxTaskNumber>
    25ae:	8f 5f       	subi	r24, 0xFF	; 255
    25b0:	80 93 8c 09 	sts	0x098C, r24	; 0x80098c <uxTaskNumber>
    25b4:	f3 01       	movw	r30, r6
    25b6:	86 89       	ldd	r24, Z+22	; 0x16
    25b8:	90 91 91 09 	lds	r25, 0x0991	; 0x800991 <uxTopReadyPriority>
    25bc:	98 17       	cp	r25, r24
    25be:	10 f4       	brcc	.+4      	; 0x25c4 <xTaskGenericCreate+0x19a>
    25c0:	80 93 91 09 	sts	0x0991, r24	; 0x800991 <uxTopReadyPriority>
    25c4:	90 e0       	ldi	r25, 0x00	; 0
    25c6:	9c 01       	movw	r18, r24
    25c8:	22 0f       	add	r18, r18
    25ca:	33 1f       	adc	r19, r19
    25cc:	22 0f       	add	r18, r18
    25ce:	33 1f       	adc	r19, r19
    25d0:	22 0f       	add	r18, r18
    25d2:	33 1f       	adc	r19, r19
    25d4:	82 0f       	add	r24, r18
    25d6:	93 1f       	adc	r25, r19
    25d8:	be 01       	movw	r22, r28
    25da:	82 54       	subi	r24, 0x42	; 66
    25dc:	96 4f       	sbci	r25, 0xF6	; 246
    25de:	c6 da       	rcall	.-2676   	; 0x1b6c <vListInsertEnd>
    25e0:	0f 90       	pop	r0
    25e2:	0f be       	out	0x3f, r0	; 63
    25e4:	80 91 90 09 	lds	r24, 0x0990	; 0x800990 <xSchedulerRunning>
    25e8:	88 23       	and	r24, r24
    25ea:	51 f0       	breq	.+20     	; 0x2600 <xTaskGenericCreate+0x1d6>
    25ec:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    25f0:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    25f4:	86 89       	ldd	r24, Z+22	; 0x16
    25f6:	80 17       	cp	r24, r16
    25f8:	28 f4       	brcc	.+10     	; 0x2604 <xTaskGenericCreate+0x1da>
    25fa:	d1 db       	rcall	.-2142   	; 0x1d9e <vPortYield>
    25fc:	81 e0       	ldi	r24, 0x01	; 1
    25fe:	09 c0       	rjmp	.+18     	; 0x2612 <xTaskGenericCreate+0x1e8>
    2600:	81 e0       	ldi	r24, 0x01	; 1
    2602:	07 c0       	rjmp	.+14     	; 0x2612 <xTaskGenericCreate+0x1e8>
    2604:	81 e0       	ldi	r24, 0x01	; 1
    2606:	05 c0       	rjmp	.+10     	; 0x2612 <xTaskGenericCreate+0x1e8>
    2608:	fc 01       	movw	r30, r24
    260a:	d0 8e       	std	Z+24, r13	; 0x18
    260c:	c7 8a       	std	Z+23, r12	; 0x17
    260e:	36 cf       	rjmp	.-404    	; 0x247c <xTaskGenericCreate+0x52>
    2610:	8f ef       	ldi	r24, 0xFF	; 255
    2612:	df 91       	pop	r29
    2614:	cf 91       	pop	r28
    2616:	1f 91       	pop	r17
    2618:	0f 91       	pop	r16
    261a:	ff 90       	pop	r15
    261c:	ef 90       	pop	r14
    261e:	df 90       	pop	r13
    2620:	cf 90       	pop	r12
    2622:	bf 90       	pop	r11
    2624:	af 90       	pop	r10
    2626:	9f 90       	pop	r9
    2628:	8f 90       	pop	r8
    262a:	7f 90       	pop	r7
    262c:	6f 90       	pop	r6
    262e:	5f 90       	pop	r5
    2630:	4f 90       	pop	r4
    2632:	08 95       	ret

00002634 <vTaskStartScheduler>:
    2634:	af 92       	push	r10
    2636:	bf 92       	push	r11
    2638:	cf 92       	push	r12
    263a:	df 92       	push	r13
    263c:	ef 92       	push	r14
    263e:	ff 92       	push	r15
    2640:	0f 93       	push	r16
    2642:	a1 2c       	mov	r10, r1
    2644:	b1 2c       	mov	r11, r1
    2646:	c1 2c       	mov	r12, r1
    2648:	d1 2c       	mov	r13, r1
    264a:	e1 2c       	mov	r14, r1
    264c:	f1 2c       	mov	r15, r1
    264e:	00 e0       	ldi	r16, 0x00	; 0
    2650:	20 e0       	ldi	r18, 0x00	; 0
    2652:	30 e0       	ldi	r19, 0x00	; 0
    2654:	45 e5       	ldi	r20, 0x55	; 85
    2656:	50 e0       	ldi	r21, 0x00	; 0
    2658:	67 e4       	ldi	r22, 0x47	; 71
    265a:	73 e0       	ldi	r23, 0x03	; 3
    265c:	8a e9       	ldi	r24, 0x9A	; 154
    265e:	94 e1       	ldi	r25, 0x14	; 20
    2660:	e4 de       	rcall	.-568    	; 0x242a <xTaskGenericCreate>
    2662:	81 30       	cpi	r24, 0x01	; 1
    2664:	41 f4       	brne	.+16     	; 0x2676 <vTaskStartScheduler+0x42>
    2666:	f8 94       	cli
    2668:	80 93 90 09 	sts	0x0990, r24	; 0x800990 <xSchedulerRunning>
    266c:	10 92 93 09 	sts	0x0993, r1	; 0x800993 <xTickCount+0x1>
    2670:	10 92 92 09 	sts	0x0992, r1	; 0x800992 <xTickCount>
    2674:	5f db       	rcall	.-2370   	; 0x1d34 <xPortStartScheduler>
    2676:	0f 91       	pop	r16
    2678:	ff 90       	pop	r15
    267a:	ef 90       	pop	r14
    267c:	df 90       	pop	r13
    267e:	cf 90       	pop	r12
    2680:	bf 90       	pop	r11
    2682:	af 90       	pop	r10
    2684:	08 95       	ret

00002686 <vTaskSuspendAll>:
    2686:	80 91 8b 09 	lds	r24, 0x098B	; 0x80098b <uxSchedulerSuspended>
    268a:	8f 5f       	subi	r24, 0xFF	; 255
    268c:	80 93 8b 09 	sts	0x098B, r24	; 0x80098b <uxSchedulerSuspended>
    2690:	08 95       	ret

00002692 <xTaskIncrementTick>:
    2692:	cf 92       	push	r12
    2694:	df 92       	push	r13
    2696:	ef 92       	push	r14
    2698:	ff 92       	push	r15
    269a:	0f 93       	push	r16
    269c:	1f 93       	push	r17
    269e:	cf 93       	push	r28
    26a0:	df 93       	push	r29
    26a2:	80 91 8b 09 	lds	r24, 0x098B	; 0x80098b <uxSchedulerSuspended>
    26a6:	81 11       	cpse	r24, r1
    26a8:	97 c0       	rjmp	.+302    	; 0x27d8 <xTaskIncrementTick+0x146>
    26aa:	80 91 92 09 	lds	r24, 0x0992	; 0x800992 <xTickCount>
    26ae:	90 91 93 09 	lds	r25, 0x0993	; 0x800993 <xTickCount+0x1>
    26b2:	01 96       	adiw	r24, 0x01	; 1
    26b4:	90 93 93 09 	sts	0x0993, r25	; 0x800993 <xTickCount+0x1>
    26b8:	80 93 92 09 	sts	0x0992, r24	; 0x800992 <xTickCount>
    26bc:	e0 90 92 09 	lds	r14, 0x0992	; 0x800992 <xTickCount>
    26c0:	f0 90 93 09 	lds	r15, 0x0993	; 0x800993 <xTickCount+0x1>
    26c4:	e1 14       	cp	r14, r1
    26c6:	f1 04       	cpc	r15, r1
    26c8:	b1 f4       	brne	.+44     	; 0x26f6 <xTaskIncrementTick+0x64>
    26ca:	80 91 aa 09 	lds	r24, 0x09AA	; 0x8009aa <pxDelayedTaskList>
    26ce:	90 91 ab 09 	lds	r25, 0x09AB	; 0x8009ab <pxDelayedTaskList+0x1>
    26d2:	20 91 a8 09 	lds	r18, 0x09A8	; 0x8009a8 <pxOverflowDelayedTaskList>
    26d6:	30 91 a9 09 	lds	r19, 0x09A9	; 0x8009a9 <pxOverflowDelayedTaskList+0x1>
    26da:	30 93 ab 09 	sts	0x09AB, r19	; 0x8009ab <pxDelayedTaskList+0x1>
    26de:	20 93 aa 09 	sts	0x09AA, r18	; 0x8009aa <pxDelayedTaskList>
    26e2:	90 93 a9 09 	sts	0x09A9, r25	; 0x8009a9 <pxOverflowDelayedTaskList+0x1>
    26e6:	80 93 a8 09 	sts	0x09A8, r24	; 0x8009a8 <pxOverflowDelayedTaskList>
    26ea:	80 91 8d 09 	lds	r24, 0x098D	; 0x80098d <xNumOfOverflows>
    26ee:	8f 5f       	subi	r24, 0xFF	; 255
    26f0:	80 93 8d 09 	sts	0x098D, r24	; 0x80098d <xNumOfOverflows>
    26f4:	46 de       	rcall	.-884    	; 0x2382 <prvResetNextTaskUnblockTime>
    26f6:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <xNextTaskUnblockTime>
    26fa:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <xNextTaskUnblockTime+0x1>
    26fe:	e8 16       	cp	r14, r24
    2700:	f9 06       	cpc	r15, r25
    2702:	10 f4       	brcc	.+4      	; 0x2708 <xTaskIncrementTick+0x76>
    2704:	d1 2c       	mov	r13, r1
    2706:	50 c0       	rjmp	.+160    	; 0x27a8 <xTaskIncrementTick+0x116>
    2708:	d1 2c       	mov	r13, r1
    270a:	cc 24       	eor	r12, r12
    270c:	c3 94       	inc	r12
    270e:	e0 91 aa 09 	lds	r30, 0x09AA	; 0x8009aa <pxDelayedTaskList>
    2712:	f0 91 ab 09 	lds	r31, 0x09AB	; 0x8009ab <pxDelayedTaskList+0x1>
    2716:	80 81       	ld	r24, Z
    2718:	81 11       	cpse	r24, r1
    271a:	07 c0       	rjmp	.+14     	; 0x272a <xTaskIncrementTick+0x98>
    271c:	8f ef       	ldi	r24, 0xFF	; 255
    271e:	9f ef       	ldi	r25, 0xFF	; 255
    2720:	90 93 04 01 	sts	0x0104, r25	; 0x800104 <xNextTaskUnblockTime+0x1>
    2724:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <xNextTaskUnblockTime>
    2728:	3f c0       	rjmp	.+126    	; 0x27a8 <xTaskIncrementTick+0x116>
    272a:	e0 91 aa 09 	lds	r30, 0x09AA	; 0x8009aa <pxDelayedTaskList>
    272e:	f0 91 ab 09 	lds	r31, 0x09AB	; 0x8009ab <pxDelayedTaskList+0x1>
    2732:	05 80       	ldd	r0, Z+5	; 0x05
    2734:	f6 81       	ldd	r31, Z+6	; 0x06
    2736:	e0 2d       	mov	r30, r0
    2738:	c6 81       	ldd	r28, Z+6	; 0x06
    273a:	d7 81       	ldd	r29, Z+7	; 0x07
    273c:	8a 81       	ldd	r24, Y+2	; 0x02
    273e:	9b 81       	ldd	r25, Y+3	; 0x03
    2740:	e8 16       	cp	r14, r24
    2742:	f9 06       	cpc	r15, r25
    2744:	28 f4       	brcc	.+10     	; 0x2750 <xTaskIncrementTick+0xbe>
    2746:	90 93 04 01 	sts	0x0104, r25	; 0x800104 <xNextTaskUnblockTime+0x1>
    274a:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <xNextTaskUnblockTime>
    274e:	2c c0       	rjmp	.+88     	; 0x27a8 <xTaskIncrementTick+0x116>
    2750:	8e 01       	movw	r16, r28
    2752:	0e 5f       	subi	r16, 0xFE	; 254
    2754:	1f 4f       	sbci	r17, 0xFF	; 255
    2756:	c8 01       	movw	r24, r16
    2758:	5b da       	rcall	.-2890   	; 0x1c10 <uxListRemove>
    275a:	8c 89       	ldd	r24, Y+20	; 0x14
    275c:	9d 89       	ldd	r25, Y+21	; 0x15
    275e:	89 2b       	or	r24, r25
    2760:	19 f0       	breq	.+6      	; 0x2768 <xTaskIncrementTick+0xd6>
    2762:	ce 01       	movw	r24, r28
    2764:	0c 96       	adiw	r24, 0x0c	; 12
    2766:	54 da       	rcall	.-2904   	; 0x1c10 <uxListRemove>
    2768:	8e 89       	ldd	r24, Y+22	; 0x16
    276a:	90 91 91 09 	lds	r25, 0x0991	; 0x800991 <uxTopReadyPriority>
    276e:	98 17       	cp	r25, r24
    2770:	10 f4       	brcc	.+4      	; 0x2776 <xTaskIncrementTick+0xe4>
    2772:	80 93 91 09 	sts	0x0991, r24	; 0x800991 <uxTopReadyPriority>
    2776:	90 e0       	ldi	r25, 0x00	; 0
    2778:	9c 01       	movw	r18, r24
    277a:	22 0f       	add	r18, r18
    277c:	33 1f       	adc	r19, r19
    277e:	22 0f       	add	r18, r18
    2780:	33 1f       	adc	r19, r19
    2782:	22 0f       	add	r18, r18
    2784:	33 1f       	adc	r19, r19
    2786:	82 0f       	add	r24, r18
    2788:	93 1f       	adc	r25, r19
    278a:	b8 01       	movw	r22, r16
    278c:	82 54       	subi	r24, 0x42	; 66
    278e:	96 4f       	sbci	r25, 0xF6	; 246
    2790:	ed d9       	rcall	.-3110   	; 0x1b6c <vListInsertEnd>
    2792:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2796:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    279a:	9e 89       	ldd	r25, Y+22	; 0x16
    279c:	86 89       	ldd	r24, Z+22	; 0x16
    279e:	98 17       	cp	r25, r24
    27a0:	08 f4       	brcc	.+2      	; 0x27a4 <xTaskIncrementTick+0x112>
    27a2:	b5 cf       	rjmp	.-150    	; 0x270e <xTaskIncrementTick+0x7c>
    27a4:	dc 2c       	mov	r13, r12
    27a6:	b3 cf       	rjmp	.-154    	; 0x270e <xTaskIncrementTick+0x7c>
    27a8:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    27ac:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    27b0:	86 89       	ldd	r24, Z+22	; 0x16
    27b2:	90 e0       	ldi	r25, 0x00	; 0
    27b4:	fc 01       	movw	r30, r24
    27b6:	ee 0f       	add	r30, r30
    27b8:	ff 1f       	adc	r31, r31
    27ba:	ee 0f       	add	r30, r30
    27bc:	ff 1f       	adc	r31, r31
    27be:	ee 0f       	add	r30, r30
    27c0:	ff 1f       	adc	r31, r31
    27c2:	8e 0f       	add	r24, r30
    27c4:	9f 1f       	adc	r25, r31
    27c6:	fc 01       	movw	r30, r24
    27c8:	e2 54       	subi	r30, 0x42	; 66
    27ca:	f6 4f       	sbci	r31, 0xF6	; 246
    27cc:	80 81       	ld	r24, Z
    27ce:	82 30       	cpi	r24, 0x02	; 2
    27d0:	48 f0       	brcs	.+18     	; 0x27e4 <xTaskIncrementTick+0x152>
    27d2:	dd 24       	eor	r13, r13
    27d4:	d3 94       	inc	r13
    27d6:	06 c0       	rjmp	.+12     	; 0x27e4 <xTaskIncrementTick+0x152>
    27d8:	80 91 8f 09 	lds	r24, 0x098F	; 0x80098f <uxPendedTicks>
    27dc:	8f 5f       	subi	r24, 0xFF	; 255
    27de:	80 93 8f 09 	sts	0x098F, r24	; 0x80098f <uxPendedTicks>
    27e2:	d1 2c       	mov	r13, r1
    27e4:	80 91 8e 09 	lds	r24, 0x098E	; 0x80098e <xYieldPending>
    27e8:	88 23       	and	r24, r24
    27ea:	11 f0       	breq	.+4      	; 0x27f0 <xTaskIncrementTick+0x15e>
    27ec:	dd 24       	eor	r13, r13
    27ee:	d3 94       	inc	r13
    27f0:	8d 2d       	mov	r24, r13
    27f2:	df 91       	pop	r29
    27f4:	cf 91       	pop	r28
    27f6:	1f 91       	pop	r17
    27f8:	0f 91       	pop	r16
    27fa:	ff 90       	pop	r15
    27fc:	ef 90       	pop	r14
    27fe:	df 90       	pop	r13
    2800:	cf 90       	pop	r12
    2802:	08 95       	ret

00002804 <xTaskResumeAll>:
    2804:	df 92       	push	r13
    2806:	ef 92       	push	r14
    2808:	ff 92       	push	r15
    280a:	0f 93       	push	r16
    280c:	1f 93       	push	r17
    280e:	cf 93       	push	r28
    2810:	df 93       	push	r29
    2812:	0f b6       	in	r0, 0x3f	; 63
    2814:	f8 94       	cli
    2816:	0f 92       	push	r0
    2818:	80 91 8b 09 	lds	r24, 0x098B	; 0x80098b <uxSchedulerSuspended>
    281c:	81 50       	subi	r24, 0x01	; 1
    281e:	80 93 8b 09 	sts	0x098B, r24	; 0x80098b <uxSchedulerSuspended>
    2822:	80 91 8b 09 	lds	r24, 0x098B	; 0x80098b <uxSchedulerSuspended>
    2826:	81 11       	cpse	r24, r1
    2828:	5d c0       	rjmp	.+186    	; 0x28e4 <xTaskResumeAll+0xe0>
    282a:	80 91 94 09 	lds	r24, 0x0994	; 0x800994 <uxCurrentNumberOfTasks>
    282e:	81 11       	cpse	r24, r1
    2830:	30 c0       	rjmp	.+96     	; 0x2892 <xTaskResumeAll+0x8e>
    2832:	5b c0       	rjmp	.+182    	; 0x28ea <xTaskResumeAll+0xe6>
    2834:	d7 01       	movw	r26, r14
    2836:	15 96       	adiw	r26, 0x05	; 5
    2838:	ed 91       	ld	r30, X+
    283a:	fc 91       	ld	r31, X
    283c:	16 97       	sbiw	r26, 0x06	; 6
    283e:	c6 81       	ldd	r28, Z+6	; 0x06
    2840:	d7 81       	ldd	r29, Z+7	; 0x07
    2842:	ce 01       	movw	r24, r28
    2844:	0c 96       	adiw	r24, 0x0c	; 12
    2846:	e4 d9       	rcall	.-3128   	; 0x1c10 <uxListRemove>
    2848:	8e 01       	movw	r16, r28
    284a:	0e 5f       	subi	r16, 0xFE	; 254
    284c:	1f 4f       	sbci	r17, 0xFF	; 255
    284e:	c8 01       	movw	r24, r16
    2850:	df d9       	rcall	.-3138   	; 0x1c10 <uxListRemove>
    2852:	8e 89       	ldd	r24, Y+22	; 0x16
    2854:	90 91 91 09 	lds	r25, 0x0991	; 0x800991 <uxTopReadyPriority>
    2858:	98 17       	cp	r25, r24
    285a:	10 f4       	brcc	.+4      	; 0x2860 <xTaskResumeAll+0x5c>
    285c:	80 93 91 09 	sts	0x0991, r24	; 0x800991 <uxTopReadyPriority>
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	9c 01       	movw	r18, r24
    2864:	22 0f       	add	r18, r18
    2866:	33 1f       	adc	r19, r19
    2868:	22 0f       	add	r18, r18
    286a:	33 1f       	adc	r19, r19
    286c:	22 0f       	add	r18, r18
    286e:	33 1f       	adc	r19, r19
    2870:	82 0f       	add	r24, r18
    2872:	93 1f       	adc	r25, r19
    2874:	b8 01       	movw	r22, r16
    2876:	82 54       	subi	r24, 0x42	; 66
    2878:	96 4f       	sbci	r25, 0xF6	; 246
    287a:	78 d9       	rcall	.-3344   	; 0x1b6c <vListInsertEnd>
    287c:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2880:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2884:	9e 89       	ldd	r25, Y+22	; 0x16
    2886:	86 89       	ldd	r24, Z+22	; 0x16
    2888:	98 17       	cp	r25, r24
    288a:	58 f0       	brcs	.+22     	; 0x28a2 <xTaskResumeAll+0x9e>
    288c:	d0 92 8e 09 	sts	0x098E, r13	; 0x80098e <xYieldPending>
    2890:	08 c0       	rjmp	.+16     	; 0x28a2 <xTaskResumeAll+0x9e>
    2892:	0f 2e       	mov	r0, r31
    2894:	ff e9       	ldi	r31, 0x9F	; 159
    2896:	ef 2e       	mov	r14, r31
    2898:	f9 e0       	ldi	r31, 0x09	; 9
    289a:	ff 2e       	mov	r15, r31
    289c:	f0 2d       	mov	r31, r0
    289e:	dd 24       	eor	r13, r13
    28a0:	d3 94       	inc	r13
    28a2:	f7 01       	movw	r30, r14
    28a4:	80 81       	ld	r24, Z
    28a6:	81 11       	cpse	r24, r1
    28a8:	c5 cf       	rjmp	.-118    	; 0x2834 <xTaskResumeAll+0x30>
    28aa:	80 91 8f 09 	lds	r24, 0x098F	; 0x80098f <uxPendedTicks>
    28ae:	88 23       	and	r24, r24
    28b0:	91 f0       	breq	.+36     	; 0x28d6 <xTaskResumeAll+0xd2>
    28b2:	80 91 8f 09 	lds	r24, 0x098F	; 0x80098f <uxPendedTicks>
    28b6:	88 23       	and	r24, r24
    28b8:	71 f0       	breq	.+28     	; 0x28d6 <xTaskResumeAll+0xd2>
    28ba:	c1 e0       	ldi	r28, 0x01	; 1
    28bc:	ea de       	rcall	.-556    	; 0x2692 <xTaskIncrementTick>
    28be:	81 11       	cpse	r24, r1
    28c0:	c0 93 8e 09 	sts	0x098E, r28	; 0x80098e <xYieldPending>
    28c4:	80 91 8f 09 	lds	r24, 0x098F	; 0x80098f <uxPendedTicks>
    28c8:	81 50       	subi	r24, 0x01	; 1
    28ca:	80 93 8f 09 	sts	0x098F, r24	; 0x80098f <uxPendedTicks>
    28ce:	80 91 8f 09 	lds	r24, 0x098F	; 0x80098f <uxPendedTicks>
    28d2:	81 11       	cpse	r24, r1
    28d4:	f3 cf       	rjmp	.-26     	; 0x28bc <xTaskResumeAll+0xb8>
    28d6:	80 91 8e 09 	lds	r24, 0x098E	; 0x80098e <xYieldPending>
    28da:	81 30       	cpi	r24, 0x01	; 1
    28dc:	29 f4       	brne	.+10     	; 0x28e8 <xTaskResumeAll+0xe4>
    28de:	5f da       	rcall	.-2882   	; 0x1d9e <vPortYield>
    28e0:	81 e0       	ldi	r24, 0x01	; 1
    28e2:	03 c0       	rjmp	.+6      	; 0x28ea <xTaskResumeAll+0xe6>
    28e4:	80 e0       	ldi	r24, 0x00	; 0
    28e6:	01 c0       	rjmp	.+2      	; 0x28ea <xTaskResumeAll+0xe6>
    28e8:	80 e0       	ldi	r24, 0x00	; 0
    28ea:	0f 90       	pop	r0
    28ec:	0f be       	out	0x3f, r0	; 63
    28ee:	df 91       	pop	r29
    28f0:	cf 91       	pop	r28
    28f2:	1f 91       	pop	r17
    28f4:	0f 91       	pop	r16
    28f6:	ff 90       	pop	r15
    28f8:	ef 90       	pop	r14
    28fa:	df 90       	pop	r13
    28fc:	08 95       	ret

000028fe <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    28fe:	cf 93       	push	r28
    2900:	df 93       	push	r29
    2902:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2904:	89 2b       	or	r24, r25
    2906:	91 f0       	breq	.+36     	; 0x292c <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2908:	be de       	rcall	.-644    	; 0x2686 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    290a:	80 91 92 09 	lds	r24, 0x0992	; 0x800992 <xTickCount>
    290e:	90 91 93 09 	lds	r25, 0x0993	; 0x800993 <xTickCount+0x1>
    2912:	c8 0f       	add	r28, r24
    2914:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2916:	80 91 f4 09 	lds	r24, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    291a:	90 91 f5 09 	lds	r25, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    291e:	02 96       	adiw	r24, 0x02	; 2
    2920:	77 d9       	rcall	.-3346   	; 0x1c10 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2922:	ce 01       	movw	r24, r28
    2924:	4d dd       	rcall	.-1382   	; 0x23c0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2926:	6e df       	rcall	.-292    	; 0x2804 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2928:	81 11       	cpse	r24, r1
    292a:	01 c0       	rjmp	.+2      	; 0x292e <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    292c:	38 da       	rcall	.-2960   	; 0x1d9e <vPortYield>
    292e:	df 91       	pop	r29
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2930:	cf 91       	pop	r28
    2932:	08 95       	ret

00002934 <prvIdleTask>:
    2934:	06 e9       	ldi	r16, 0x96	; 150
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2936:	19 e0       	ldi	r17, 0x09	; 9

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2938:	0f 2e       	mov	r0, r31
    293a:	fe eb       	ldi	r31, 0xBE	; 190
    293c:	ef 2e       	mov	r14, r31
    293e:	f9 e0       	ldi	r31, 0x09	; 9
    2940:	ff 2e       	mov	r15, r31
    2942:	f0 2d       	mov	r31, r0
    2944:	24 c0       	rjmp	.+72     	; 0x298e <prvIdleTask+0x5a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    2946:	9f de       	rcall	.-706    	; 0x2686 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2948:	d8 01       	movw	r26, r16
			}
			( void ) xTaskResumeAll();
    294a:	cc 91       	ld	r28, X
    294c:	5b df       	rcall	.-330    	; 0x2804 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    294e:	cc 23       	and	r28, r28
    2950:	f1 f0       	breq	.+60     	; 0x298e <prvIdleTask+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2952:	0f b6       	in	r0, 0x3f	; 63
    2954:	f8 94       	cli
    2956:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    2958:	d8 01       	movw	r26, r16
    295a:	15 96       	adiw	r26, 0x05	; 5
    295c:	ed 91       	ld	r30, X+
    295e:	fc 91       	ld	r31, X
    2960:	16 97       	sbiw	r26, 0x06	; 6
    2962:	c6 81       	ldd	r28, Z+6	; 0x06
    2964:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2966:	ce 01       	movw	r24, r28
    2968:	02 96       	adiw	r24, 0x02	; 2
    296a:	52 d9       	rcall	.-3420   	; 0x1c10 <uxListRemove>
					--uxCurrentNumberOfTasks;
    296c:	80 91 94 09 	lds	r24, 0x0994	; 0x800994 <uxCurrentNumberOfTasks>
    2970:	81 50       	subi	r24, 0x01	; 1
    2972:	80 93 94 09 	sts	0x0994, r24	; 0x800994 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    2976:	80 91 95 09 	lds	r24, 0x0995	; 0x800995 <uxTasksDeleted>
    297a:	81 50       	subi	r24, 0x01	; 1
    297c:	80 93 95 09 	sts	0x0995, r24	; 0x800995 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    2980:	0f 90       	pop	r0
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    2982:	0f be       	out	0x3f, r0	; 63
    2984:	8f 89       	ldd	r24, Y+23	; 0x17
    2986:	98 8d       	ldd	r25, Y+24	; 0x18
		vPortFree( pxTCB );
    2988:	de d8       	rcall	.-3652   	; 0x1b46 <vPortFree>
    298a:	ce 01       	movw	r24, r28
    298c:	dc d8       	rcall	.-3656   	; 0x1b46 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    298e:	80 91 95 09 	lds	r24, 0x0995	; 0x800995 <uxTasksDeleted>
    2992:	81 11       	cpse	r24, r1
    2994:	d8 cf       	rjmp	.-80     	; 0x2946 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2996:	f7 01       	movw	r30, r14
    2998:	80 81       	ld	r24, Z
    299a:	82 30       	cpi	r24, 0x02	; 2
			{
				taskYIELD();
    299c:	c0 f3       	brcs	.-16     	; 0x298e <prvIdleTask+0x5a>
    299e:	ff d9       	rcall	.-3074   	; 0x1d9e <vPortYield>
    29a0:	f6 cf       	rjmp	.-20     	; 0x298e <prvIdleTask+0x5a>

000029a2 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    29a2:	80 91 8b 09 	lds	r24, 0x098B	; 0x80098b <uxSchedulerSuspended>
    29a6:	88 23       	and	r24, r24
    29a8:	21 f0       	breq	.+8      	; 0x29b2 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    29aa:	81 e0       	ldi	r24, 0x01	; 1
    29ac:	80 93 8e 09 	sts	0x098E, r24	; 0x80098e <xYieldPending>
    29b0:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    29b2:	10 92 8e 09 	sts	0x098E, r1	; 0x80098e <xYieldPending>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    29b6:	80 91 91 09 	lds	r24, 0x0991	; 0x800991 <uxTopReadyPriority>
    29ba:	90 e0       	ldi	r25, 0x00	; 0
    29bc:	fc 01       	movw	r30, r24
    29be:	ee 0f       	add	r30, r30
    29c0:	ff 1f       	adc	r31, r31
    29c2:	ee 0f       	add	r30, r30
    29c4:	ff 1f       	adc	r31, r31
    29c6:	ee 0f       	add	r30, r30
    29c8:	ff 1f       	adc	r31, r31
    29ca:	8e 0f       	add	r24, r30
    29cc:	9f 1f       	adc	r25, r31
    29ce:	fc 01       	movw	r30, r24
    29d0:	e2 54       	subi	r30, 0x42	; 66
    29d2:	f6 4f       	sbci	r31, 0xF6	; 246
    29d4:	80 81       	ld	r24, Z
    29d6:	81 11       	cpse	r24, r1
    29d8:	17 c0       	rjmp	.+46     	; 0x2a08 <vTaskSwitchContext+0x66>
    29da:	80 91 91 09 	lds	r24, 0x0991	; 0x800991 <uxTopReadyPriority>
    29de:	81 50       	subi	r24, 0x01	; 1
    29e0:	80 93 91 09 	sts	0x0991, r24	; 0x800991 <uxTopReadyPriority>
    29e4:	80 91 91 09 	lds	r24, 0x0991	; 0x800991 <uxTopReadyPriority>
    29e8:	90 e0       	ldi	r25, 0x00	; 0
    29ea:	fc 01       	movw	r30, r24
    29ec:	ee 0f       	add	r30, r30
    29ee:	ff 1f       	adc	r31, r31
    29f0:	ee 0f       	add	r30, r30
    29f2:	ff 1f       	adc	r31, r31
    29f4:	ee 0f       	add	r30, r30
    29f6:	ff 1f       	adc	r31, r31
    29f8:	8e 0f       	add	r24, r30
    29fa:	9f 1f       	adc	r25, r31
    29fc:	fc 01       	movw	r30, r24
    29fe:	e2 54       	subi	r30, 0x42	; 66
    2a00:	f6 4f       	sbci	r31, 0xF6	; 246
    2a02:	80 81       	ld	r24, Z
    2a04:	88 23       	and	r24, r24
    2a06:	49 f3       	breq	.-46     	; 0x29da <vTaskSwitchContext+0x38>
    2a08:	80 91 91 09 	lds	r24, 0x0991	; 0x800991 <uxTopReadyPriority>
    2a0c:	90 e0       	ldi	r25, 0x00	; 0
    2a0e:	9c 01       	movw	r18, r24
    2a10:	22 0f       	add	r18, r18
    2a12:	33 1f       	adc	r19, r19
    2a14:	22 0f       	add	r18, r18
    2a16:	33 1f       	adc	r19, r19
    2a18:	22 0f       	add	r18, r18
    2a1a:	33 1f       	adc	r19, r19
    2a1c:	28 0f       	add	r18, r24
    2a1e:	39 1f       	adc	r19, r25
    2a20:	d9 01       	movw	r26, r18
    2a22:	a2 54       	subi	r26, 0x42	; 66
    2a24:	b6 4f       	sbci	r27, 0xF6	; 246
    2a26:	11 96       	adiw	r26, 0x01	; 1
    2a28:	ed 91       	ld	r30, X+
    2a2a:	fc 91       	ld	r31, X
    2a2c:	12 97       	sbiw	r26, 0x02	; 2
    2a2e:	02 80       	ldd	r0, Z+2	; 0x02
    2a30:	f3 81       	ldd	r31, Z+3	; 0x03
    2a32:	e0 2d       	mov	r30, r0
    2a34:	12 96       	adiw	r26, 0x02	; 2
    2a36:	fc 93       	st	X, r31
    2a38:	ee 93       	st	-X, r30
    2a3a:	11 97       	sbiw	r26, 0x01	; 1
    2a3c:	2f 53       	subi	r18, 0x3F	; 63
    2a3e:	36 4f       	sbci	r19, 0xF6	; 246
    2a40:	e2 17       	cp	r30, r18
    2a42:	f3 07       	cpc	r31, r19
    2a44:	29 f4       	brne	.+10     	; 0x2a50 <vTaskSwitchContext+0xae>
    2a46:	22 81       	ldd	r18, Z+2	; 0x02
    2a48:	33 81       	ldd	r19, Z+3	; 0x03
    2a4a:	fd 01       	movw	r30, r26
    2a4c:	32 83       	std	Z+2, r19	; 0x02
    2a4e:	21 83       	std	Z+1, r18	; 0x01
    2a50:	fc 01       	movw	r30, r24
    2a52:	ee 0f       	add	r30, r30
    2a54:	ff 1f       	adc	r31, r31
    2a56:	ee 0f       	add	r30, r30
    2a58:	ff 1f       	adc	r31, r31
    2a5a:	ee 0f       	add	r30, r30
    2a5c:	ff 1f       	adc	r31, r31
    2a5e:	8e 0f       	add	r24, r30
    2a60:	9f 1f       	adc	r25, r31
    2a62:	fc 01       	movw	r30, r24
    2a64:	e2 54       	subi	r30, 0x42	; 66
    2a66:	f6 4f       	sbci	r31, 0xF6	; 246
    2a68:	01 80       	ldd	r0, Z+1	; 0x01
    2a6a:	f2 81       	ldd	r31, Z+2	; 0x02
    2a6c:	e0 2d       	mov	r30, r0
    2a6e:	86 81       	ldd	r24, Z+6	; 0x06
    2a70:	97 81       	ldd	r25, Z+7	; 0x07
    2a72:	90 93 f5 09 	sts	0x09F5, r25	; 0x8009f5 <pxCurrentTCB+0x1>
    2a76:	80 93 f4 09 	sts	0x09F4, r24	; 0x8009f4 <pxCurrentTCB>
    2a7a:	08 95       	ret

00002a7c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2a7c:	cf 93       	push	r28
    2a7e:	df 93       	push	r29
    2a80:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2a82:	60 91 f4 09 	lds	r22, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2a86:	70 91 f5 09 	lds	r23, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2a8a:	64 5f       	subi	r22, 0xF4	; 244
    2a8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a8e:	8f d8       	rcall	.-3810   	; 0x1bae <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2a90:	80 91 f4 09 	lds	r24, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2a94:	90 91 f5 09 	lds	r25, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2a98:	02 96       	adiw	r24, 0x02	; 2
    2a9a:	ba d8       	rcall	.-3724   	; 0x1c10 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    2a9c:	80 91 92 09 	lds	r24, 0x0992	; 0x800992 <xTickCount>
    2aa0:	90 91 93 09 	lds	r25, 0x0993	; 0x800993 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2aa4:	8c 0f       	add	r24, r28
    2aa6:	9d 1f       	adc	r25, r29
    2aa8:	8b dc       	rcall	.-1770   	; 0x23c0 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2aaa:	df 91       	pop	r29
    2aac:	cf 91       	pop	r28
    2aae:	08 95       	ret

00002ab0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    2ab0:	cf 93       	push	r28
    2ab2:	df 93       	push	r29
    2ab4:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2ab6:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2aba:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2abe:	70 68       	ori	r23, 0x80	; 128
    2ac0:	75 87       	std	Z+13, r23	; 0x0d
    2ac2:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2ac4:	60 91 f4 09 	lds	r22, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2ac8:	70 91 f5 09 	lds	r23, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2acc:	64 5f       	subi	r22, 0xF4	; 244
    2ace:	7f 4f       	sbci	r23, 0xFF	; 255
    2ad0:	4d d8       	rcall	.-3942   	; 0x1b6c <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2ad2:	80 91 f4 09 	lds	r24, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2ad6:	90 91 f5 09 	lds	r25, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2ada:	02 96       	adiw	r24, 0x02	; 2
    2adc:	99 d8       	rcall	.-3790   	; 0x1c10 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    2ade:	80 91 92 09 	lds	r24, 0x0992	; 0x800992 <xTickCount>
    2ae2:	90 91 93 09 	lds	r25, 0x0993	; 0x800993 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ae6:	8c 0f       	add	r24, r28
    2ae8:	9d 1f       	adc	r25, r29
    2aea:	6a dc       	rcall	.-1836   	; 0x23c0 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2aec:	df 91       	pop	r29
    2aee:	cf 91       	pop	r28
    2af0:	08 95       	ret

00002af2 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2af2:	0f 93       	push	r16
    2af4:	1f 93       	push	r17
    2af6:	cf 93       	push	r28
    2af8:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2afa:	dc 01       	movw	r26, r24
    2afc:	15 96       	adiw	r26, 0x05	; 5
    2afe:	ed 91       	ld	r30, X+
    2b00:	fc 91       	ld	r31, X
    2b02:	16 97       	sbiw	r26, 0x06	; 6
    2b04:	c6 81       	ldd	r28, Z+6	; 0x06
    2b06:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2b08:	8e 01       	movw	r16, r28
    2b0a:	04 5f       	subi	r16, 0xF4	; 244
    2b0c:	1f 4f       	sbci	r17, 0xFF	; 255
    2b0e:	c8 01       	movw	r24, r16
    2b10:	7f d8       	rcall	.-3842   	; 0x1c10 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2b12:	80 91 8b 09 	lds	r24, 0x098B	; 0x80098b <uxSchedulerSuspended>
    2b16:	81 11       	cpse	r24, r1
    2b18:	1a c0       	rjmp	.+52     	; 0x2b4e <xTaskRemoveFromEventList+0x5c>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2b1a:	0a 50       	subi	r16, 0x0A	; 10
    2b1c:	11 09       	sbc	r17, r1
    2b1e:	c8 01       	movw	r24, r16
    2b20:	77 d8       	rcall	.-3858   	; 0x1c10 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    2b22:	8e 89       	ldd	r24, Y+22	; 0x16
    2b24:	90 91 91 09 	lds	r25, 0x0991	; 0x800991 <uxTopReadyPriority>
    2b28:	98 17       	cp	r25, r24
    2b2a:	10 f4       	brcc	.+4      	; 0x2b30 <xTaskRemoveFromEventList+0x3e>
    2b2c:	80 93 91 09 	sts	0x0991, r24	; 0x800991 <uxTopReadyPriority>
    2b30:	90 e0       	ldi	r25, 0x00	; 0
    2b32:	9c 01       	movw	r18, r24
    2b34:	22 0f       	add	r18, r18
    2b36:	33 1f       	adc	r19, r19
    2b38:	22 0f       	add	r18, r18
    2b3a:	33 1f       	adc	r19, r19
    2b3c:	22 0f       	add	r18, r18
    2b3e:	33 1f       	adc	r19, r19
    2b40:	82 0f       	add	r24, r18
    2b42:	93 1f       	adc	r25, r19
    2b44:	b8 01       	movw	r22, r16
    2b46:	82 54       	subi	r24, 0x42	; 66
    2b48:	96 4f       	sbci	r25, 0xF6	; 246
    2b4a:	10 d8       	rcall	.-4064   	; 0x1b6c <vListInsertEnd>
    2b4c:	04 c0       	rjmp	.+8      	; 0x2b56 <xTaskRemoveFromEventList+0x64>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2b4e:	b8 01       	movw	r22, r16
    2b50:	8f e9       	ldi	r24, 0x9F	; 159
    2b52:	99 e0       	ldi	r25, 0x09	; 9
    2b54:	0b d8       	rcall	.-4074   	; 0x1b6c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2b56:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2b5a:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2b5e:	9e 89       	ldd	r25, Y+22	; 0x16
    2b60:	86 89       	ldd	r24, Z+22	; 0x16
    2b62:	89 17       	cp	r24, r25
    2b64:	20 f4       	brcc	.+8      	; 0x2b6e <xTaskRemoveFromEventList+0x7c>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2b66:	81 e0       	ldi	r24, 0x01	; 1
    2b68:	80 93 8e 09 	sts	0x098E, r24	; 0x80098e <xYieldPending>
    2b6c:	01 c0       	rjmp	.+2      	; 0x2b70 <xTaskRemoveFromEventList+0x7e>
	}
	else
	{
		xReturn = pdFALSE;
    2b6e:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    2b70:	df 91       	pop	r29
    2b72:	cf 91       	pop	r28
    2b74:	1f 91       	pop	r17
    2b76:	0f 91       	pop	r16
    2b78:	08 95       	ret

00002b7a <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    2b7a:	0f 93       	push	r16
    2b7c:	1f 93       	push	r17
    2b7e:	cf 93       	push	r28
    2b80:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2b82:	70 68       	ori	r23, 0x80	; 128
    2b84:	fc 01       	movw	r30, r24
    2b86:	71 83       	std	Z+1, r23	; 0x01
    2b88:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    2b8a:	c6 81       	ldd	r28, Z+6	; 0x06
    2b8c:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2b8e:	40 d8       	rcall	.-3968   	; 0x1c10 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2b90:	8e 01       	movw	r16, r28
    2b92:	0e 5f       	subi	r16, 0xFE	; 254
    2b94:	1f 4f       	sbci	r17, 0xFF	; 255
    2b96:	c8 01       	movw	r24, r16
    2b98:	3b d8       	rcall	.-3978   	; 0x1c10 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2b9a:	8e 89       	ldd	r24, Y+22	; 0x16
    2b9c:	90 91 91 09 	lds	r25, 0x0991	; 0x800991 <uxTopReadyPriority>
    2ba0:	98 17       	cp	r25, r24
    2ba2:	10 f4       	brcc	.+4      	; 0x2ba8 <xTaskRemoveFromUnorderedEventList+0x2e>
    2ba4:	80 93 91 09 	sts	0x0991, r24	; 0x800991 <uxTopReadyPriority>
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	9c 01       	movw	r18, r24
    2bac:	22 0f       	add	r18, r18
    2bae:	33 1f       	adc	r19, r19
    2bb0:	22 0f       	add	r18, r18
    2bb2:	33 1f       	adc	r19, r19
    2bb4:	22 0f       	add	r18, r18
    2bb6:	33 1f       	adc	r19, r19
    2bb8:	82 0f       	add	r24, r18
    2bba:	93 1f       	adc	r25, r19
    2bbc:	b8 01       	movw	r22, r16
    2bbe:	82 54       	subi	r24, 0x42	; 66
    2bc0:	96 4f       	sbci	r25, 0xF6	; 246
    2bc2:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2bc6:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2bca:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2bce:	9e 89       	ldd	r25, Y+22	; 0x16
    2bd0:	86 89       	ldd	r24, Z+22	; 0x16
    2bd2:	89 17       	cp	r24, r25
    2bd4:	20 f4       	brcc	.+8      	; 0x2bde <xTaskRemoveFromUnorderedEventList+0x64>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2bd6:	81 e0       	ldi	r24, 0x01	; 1
    2bd8:	80 93 8e 09 	sts	0x098E, r24	; 0x80098e <xYieldPending>
    2bdc:	01 c0       	rjmp	.+2      	; 0x2be0 <xTaskRemoveFromUnorderedEventList+0x66>
	}
	else
	{
		xReturn = pdFALSE;
    2bde:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    2be0:	df 91       	pop	r29
    2be2:	cf 91       	pop	r28
    2be4:	1f 91       	pop	r17
    2be6:	0f 91       	pop	r16
    2be8:	08 95       	ret

00002bea <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2bea:	20 91 8d 09 	lds	r18, 0x098D	; 0x80098d <xNumOfOverflows>
    2bee:	fc 01       	movw	r30, r24
    2bf0:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2bf2:	20 91 92 09 	lds	r18, 0x0992	; 0x800992 <xTickCount>
    2bf6:	30 91 93 09 	lds	r19, 0x0993	; 0x800993 <xTickCount+0x1>
    2bfa:	32 83       	std	Z+2, r19	; 0x02
    2bfc:	21 83       	std	Z+1, r18	; 0x01
    2bfe:	08 95       	ret

00002c00 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2c00:	cf 93       	push	r28
    2c02:	df 93       	push	r29
    2c04:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2c06:	0f b6       	in	r0, 0x3f	; 63
    2c08:	f8 94       	cli
    2c0a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2c0c:	20 91 92 09 	lds	r18, 0x0992	; 0x800992 <xTickCount>
    2c10:	30 91 93 09 	lds	r19, 0x0993	; 0x800993 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2c14:	80 91 8d 09 	lds	r24, 0x098D	; 0x80098d <xNumOfOverflows>
    2c18:	90 81       	ld	r25, Z
    2c1a:	98 17       	cp	r25, r24
    2c1c:	29 f0       	breq	.+10     	; 0x2c28 <xTaskCheckForTimeOut+0x28>
    2c1e:	81 81       	ldd	r24, Z+1	; 0x01
    2c20:	92 81       	ldd	r25, Z+2	; 0x02
    2c22:	28 17       	cp	r18, r24
    2c24:	39 07       	cpc	r19, r25
    2c26:	a8 f4       	brcc	.+42     	; 0x2c52 <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2c28:	a1 81       	ldd	r26, Z+1	; 0x01
    2c2a:	b2 81       	ldd	r27, Z+2	; 0x02
    2c2c:	eb 01       	movw	r28, r22
    2c2e:	48 81       	ld	r20, Y
    2c30:	59 81       	ldd	r21, Y+1	; 0x01
    2c32:	c9 01       	movw	r24, r18
    2c34:	8a 1b       	sub	r24, r26
    2c36:	9b 0b       	sbc	r25, r27
    2c38:	84 17       	cp	r24, r20
    2c3a:	95 07       	cpc	r25, r21
    2c3c:	60 f4       	brcc	.+24     	; 0x2c56 <xTaskCheckForTimeOut+0x56>
    2c3e:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2c40:	a2 1b       	sub	r26, r18
    2c42:	b3 0b       	sbc	r27, r19
    2c44:	4a 0f       	add	r20, r26
    2c46:	5b 1f       	adc	r21, r27
    2c48:	59 83       	std	Y+1, r21	; 0x01
    2c4a:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    2c4c:	ce df       	rcall	.-100    	; 0x2bea <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2c4e:	80 e0       	ldi	r24, 0x00	; 0
    2c50:	03 c0       	rjmp	.+6      	; 0x2c58 <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2c52:	81 e0       	ldi	r24, 0x01	; 1
    2c54:	01 c0       	rjmp	.+2      	; 0x2c58 <xTaskCheckForTimeOut+0x58>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2c56:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2c58:	0f 90       	pop	r0
    2c5a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2c5c:	df 91       	pop	r29
    2c5e:	cf 91       	pop	r28
    2c60:	08 95       	ret

00002c62 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2c62:	81 e0       	ldi	r24, 0x01	; 1
    2c64:	80 93 8e 09 	sts	0x098E, r24	; 0x80098e <xYieldPending>
    2c68:	08 95       	ret

00002c6a <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2c6a:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2c6e:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2c72:	84 85       	ldd	r24, Z+12	; 0x0c
    2c74:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2c76:	e0 91 f4 09 	lds	r30, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2c7a:	f0 91 f5 09 	lds	r31, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2c7e:	a0 91 f4 09 	lds	r26, 0x09F4	; 0x8009f4 <pxCurrentTCB>
    2c82:	b0 91 f5 09 	lds	r27, 0x09F5	; 0x8009f5 <pxCurrentTCB+0x1>
    2c86:	56 96       	adiw	r26, 0x16	; 22
    2c88:	4c 91       	ld	r20, X
    2c8a:	26 e0       	ldi	r18, 0x06	; 6
    2c8c:	30 e0       	ldi	r19, 0x00	; 0
    2c8e:	24 1b       	sub	r18, r20
    2c90:	31 09       	sbc	r19, r1
    2c92:	35 87       	std	Z+13, r19	; 0x0d
    2c94:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    2c96:	08 95       	ret

00002c98 <__divsf3>:
    2c98:	0c d0       	rcall	.+24     	; 0x2cb2 <__divsf3x>
    2c9a:	e6 c0       	rjmp	.+460    	; 0x2e68 <__fp_round>
    2c9c:	de d0       	rcall	.+444    	; 0x2e5a <__fp_pscB>
    2c9e:	40 f0       	brcs	.+16     	; 0x2cb0 <__divsf3+0x18>
    2ca0:	d5 d0       	rcall	.+426    	; 0x2e4c <__fp_pscA>
    2ca2:	30 f0       	brcs	.+12     	; 0x2cb0 <__divsf3+0x18>
    2ca4:	21 f4       	brne	.+8      	; 0x2cae <__divsf3+0x16>
    2ca6:	5f 3f       	cpi	r21, 0xFF	; 255
    2ca8:	19 f0       	breq	.+6      	; 0x2cb0 <__divsf3+0x18>
    2caa:	c7 c0       	rjmp	.+398    	; 0x2e3a <__fp_inf>
    2cac:	51 11       	cpse	r21, r1
    2cae:	10 c1       	rjmp	.+544    	; 0x2ed0 <__fp_szero>
    2cb0:	ca c0       	rjmp	.+404    	; 0x2e46 <__fp_nan>

00002cb2 <__divsf3x>:
    2cb2:	eb d0       	rcall	.+470    	; 0x2e8a <__fp_split3>
    2cb4:	98 f3       	brcs	.-26     	; 0x2c9c <__divsf3+0x4>

00002cb6 <__divsf3_pse>:
    2cb6:	99 23       	and	r25, r25
    2cb8:	c9 f3       	breq	.-14     	; 0x2cac <__divsf3+0x14>
    2cba:	55 23       	and	r21, r21
    2cbc:	b1 f3       	breq	.-20     	; 0x2caa <__divsf3+0x12>
    2cbe:	95 1b       	sub	r25, r21
    2cc0:	55 0b       	sbc	r21, r21
    2cc2:	bb 27       	eor	r27, r27
    2cc4:	aa 27       	eor	r26, r26
    2cc6:	62 17       	cp	r22, r18
    2cc8:	73 07       	cpc	r23, r19
    2cca:	84 07       	cpc	r24, r20
    2ccc:	38 f0       	brcs	.+14     	; 0x2cdc <__divsf3_pse+0x26>
    2cce:	9f 5f       	subi	r25, 0xFF	; 255
    2cd0:	5f 4f       	sbci	r21, 0xFF	; 255
    2cd2:	22 0f       	add	r18, r18
    2cd4:	33 1f       	adc	r19, r19
    2cd6:	44 1f       	adc	r20, r20
    2cd8:	aa 1f       	adc	r26, r26
    2cda:	a9 f3       	breq	.-22     	; 0x2cc6 <__divsf3_pse+0x10>
    2cdc:	33 d0       	rcall	.+102    	; 0x2d44 <__divsf3_pse+0x8e>
    2cde:	0e 2e       	mov	r0, r30
    2ce0:	3a f0       	brmi	.+14     	; 0x2cf0 <__divsf3_pse+0x3a>
    2ce2:	e0 e8       	ldi	r30, 0x80	; 128
    2ce4:	30 d0       	rcall	.+96     	; 0x2d46 <__divsf3_pse+0x90>
    2ce6:	91 50       	subi	r25, 0x01	; 1
    2ce8:	50 40       	sbci	r21, 0x00	; 0
    2cea:	e6 95       	lsr	r30
    2cec:	00 1c       	adc	r0, r0
    2cee:	ca f7       	brpl	.-14     	; 0x2ce2 <__divsf3_pse+0x2c>
    2cf0:	29 d0       	rcall	.+82     	; 0x2d44 <__divsf3_pse+0x8e>
    2cf2:	fe 2f       	mov	r31, r30
    2cf4:	27 d0       	rcall	.+78     	; 0x2d44 <__divsf3_pse+0x8e>
    2cf6:	66 0f       	add	r22, r22
    2cf8:	77 1f       	adc	r23, r23
    2cfa:	88 1f       	adc	r24, r24
    2cfc:	bb 1f       	adc	r27, r27
    2cfe:	26 17       	cp	r18, r22
    2d00:	37 07       	cpc	r19, r23
    2d02:	48 07       	cpc	r20, r24
    2d04:	ab 07       	cpc	r26, r27
    2d06:	b0 e8       	ldi	r27, 0x80	; 128
    2d08:	09 f0       	breq	.+2      	; 0x2d0c <__divsf3_pse+0x56>
    2d0a:	bb 0b       	sbc	r27, r27
    2d0c:	80 2d       	mov	r24, r0
    2d0e:	bf 01       	movw	r22, r30
    2d10:	ff 27       	eor	r31, r31
    2d12:	93 58       	subi	r25, 0x83	; 131
    2d14:	5f 4f       	sbci	r21, 0xFF	; 255
    2d16:	2a f0       	brmi	.+10     	; 0x2d22 <__divsf3_pse+0x6c>
    2d18:	9e 3f       	cpi	r25, 0xFE	; 254
    2d1a:	51 05       	cpc	r21, r1
    2d1c:	68 f0       	brcs	.+26     	; 0x2d38 <__divsf3_pse+0x82>
    2d1e:	8d c0       	rjmp	.+282    	; 0x2e3a <__fp_inf>
    2d20:	d7 c0       	rjmp	.+430    	; 0x2ed0 <__fp_szero>
    2d22:	5f 3f       	cpi	r21, 0xFF	; 255
    2d24:	ec f3       	brlt	.-6      	; 0x2d20 <__divsf3_pse+0x6a>
    2d26:	98 3e       	cpi	r25, 0xE8	; 232
    2d28:	dc f3       	brlt	.-10     	; 0x2d20 <__divsf3_pse+0x6a>
    2d2a:	86 95       	lsr	r24
    2d2c:	77 95       	ror	r23
    2d2e:	67 95       	ror	r22
    2d30:	b7 95       	ror	r27
    2d32:	f7 95       	ror	r31
    2d34:	9f 5f       	subi	r25, 0xFF	; 255
    2d36:	c9 f7       	brne	.-14     	; 0x2d2a <__divsf3_pse+0x74>
    2d38:	88 0f       	add	r24, r24
    2d3a:	91 1d       	adc	r25, r1
    2d3c:	96 95       	lsr	r25
    2d3e:	87 95       	ror	r24
    2d40:	97 f9       	bld	r25, 7
    2d42:	08 95       	ret
    2d44:	e1 e0       	ldi	r30, 0x01	; 1
    2d46:	66 0f       	add	r22, r22
    2d48:	77 1f       	adc	r23, r23
    2d4a:	88 1f       	adc	r24, r24
    2d4c:	bb 1f       	adc	r27, r27
    2d4e:	62 17       	cp	r22, r18
    2d50:	73 07       	cpc	r23, r19
    2d52:	84 07       	cpc	r24, r20
    2d54:	ba 07       	cpc	r27, r26
    2d56:	20 f0       	brcs	.+8      	; 0x2d60 <__divsf3_pse+0xaa>
    2d58:	62 1b       	sub	r22, r18
    2d5a:	73 0b       	sbc	r23, r19
    2d5c:	84 0b       	sbc	r24, r20
    2d5e:	ba 0b       	sbc	r27, r26
    2d60:	ee 1f       	adc	r30, r30
    2d62:	88 f7       	brcc	.-30     	; 0x2d46 <__divsf3_pse+0x90>
    2d64:	e0 95       	com	r30
    2d66:	08 95       	ret

00002d68 <__fixunssfsi>:
    2d68:	98 d0       	rcall	.+304    	; 0x2e9a <__fp_splitA>
    2d6a:	88 f0       	brcs	.+34     	; 0x2d8e <__fixunssfsi+0x26>
    2d6c:	9f 57       	subi	r25, 0x7F	; 127
    2d6e:	90 f0       	brcs	.+36     	; 0x2d94 <__fixunssfsi+0x2c>
    2d70:	b9 2f       	mov	r27, r25
    2d72:	99 27       	eor	r25, r25
    2d74:	b7 51       	subi	r27, 0x17	; 23
    2d76:	a0 f0       	brcs	.+40     	; 0x2da0 <__fixunssfsi+0x38>
    2d78:	d1 f0       	breq	.+52     	; 0x2dae <__fixunssfsi+0x46>
    2d7a:	66 0f       	add	r22, r22
    2d7c:	77 1f       	adc	r23, r23
    2d7e:	88 1f       	adc	r24, r24
    2d80:	99 1f       	adc	r25, r25
    2d82:	1a f0       	brmi	.+6      	; 0x2d8a <__fixunssfsi+0x22>
    2d84:	ba 95       	dec	r27
    2d86:	c9 f7       	brne	.-14     	; 0x2d7a <__fixunssfsi+0x12>
    2d88:	12 c0       	rjmp	.+36     	; 0x2dae <__fixunssfsi+0x46>
    2d8a:	b1 30       	cpi	r27, 0x01	; 1
    2d8c:	81 f0       	breq	.+32     	; 0x2dae <__fixunssfsi+0x46>
    2d8e:	9f d0       	rcall	.+318    	; 0x2ece <__fp_zero>
    2d90:	b1 e0       	ldi	r27, 0x01	; 1
    2d92:	08 95       	ret
    2d94:	9c c0       	rjmp	.+312    	; 0x2ece <__fp_zero>
    2d96:	67 2f       	mov	r22, r23
    2d98:	78 2f       	mov	r23, r24
    2d9a:	88 27       	eor	r24, r24
    2d9c:	b8 5f       	subi	r27, 0xF8	; 248
    2d9e:	39 f0       	breq	.+14     	; 0x2dae <__fixunssfsi+0x46>
    2da0:	b9 3f       	cpi	r27, 0xF9	; 249
    2da2:	cc f3       	brlt	.-14     	; 0x2d96 <__fixunssfsi+0x2e>
    2da4:	86 95       	lsr	r24
    2da6:	77 95       	ror	r23
    2da8:	67 95       	ror	r22
    2daa:	b3 95       	inc	r27
    2dac:	d9 f7       	brne	.-10     	; 0x2da4 <__fixunssfsi+0x3c>
    2dae:	3e f4       	brtc	.+14     	; 0x2dbe <__fixunssfsi+0x56>
    2db0:	90 95       	com	r25
    2db2:	80 95       	com	r24
    2db4:	70 95       	com	r23
    2db6:	61 95       	neg	r22
    2db8:	7f 4f       	sbci	r23, 0xFF	; 255
    2dba:	8f 4f       	sbci	r24, 0xFF	; 255
    2dbc:	9f 4f       	sbci	r25, 0xFF	; 255
    2dbe:	08 95       	ret

00002dc0 <__floatunsisf>:
    2dc0:	e8 94       	clt
    2dc2:	09 c0       	rjmp	.+18     	; 0x2dd6 <__floatsisf+0x12>

00002dc4 <__floatsisf>:
    2dc4:	97 fb       	bst	r25, 7
    2dc6:	3e f4       	brtc	.+14     	; 0x2dd6 <__floatsisf+0x12>
    2dc8:	90 95       	com	r25
    2dca:	80 95       	com	r24
    2dcc:	70 95       	com	r23
    2dce:	61 95       	neg	r22
    2dd0:	7f 4f       	sbci	r23, 0xFF	; 255
    2dd2:	8f 4f       	sbci	r24, 0xFF	; 255
    2dd4:	9f 4f       	sbci	r25, 0xFF	; 255
    2dd6:	99 23       	and	r25, r25
    2dd8:	a9 f0       	breq	.+42     	; 0x2e04 <__floatsisf+0x40>
    2dda:	f9 2f       	mov	r31, r25
    2ddc:	96 e9       	ldi	r25, 0x96	; 150
    2dde:	bb 27       	eor	r27, r27
    2de0:	93 95       	inc	r25
    2de2:	f6 95       	lsr	r31
    2de4:	87 95       	ror	r24
    2de6:	77 95       	ror	r23
    2de8:	67 95       	ror	r22
    2dea:	b7 95       	ror	r27
    2dec:	f1 11       	cpse	r31, r1
    2dee:	f8 cf       	rjmp	.-16     	; 0x2de0 <__floatsisf+0x1c>
    2df0:	fa f4       	brpl	.+62     	; 0x2e30 <__floatsisf+0x6c>
    2df2:	bb 0f       	add	r27, r27
    2df4:	11 f4       	brne	.+4      	; 0x2dfa <__floatsisf+0x36>
    2df6:	60 ff       	sbrs	r22, 0
    2df8:	1b c0       	rjmp	.+54     	; 0x2e30 <__floatsisf+0x6c>
    2dfa:	6f 5f       	subi	r22, 0xFF	; 255
    2dfc:	7f 4f       	sbci	r23, 0xFF	; 255
    2dfe:	8f 4f       	sbci	r24, 0xFF	; 255
    2e00:	9f 4f       	sbci	r25, 0xFF	; 255
    2e02:	16 c0       	rjmp	.+44     	; 0x2e30 <__floatsisf+0x6c>
    2e04:	88 23       	and	r24, r24
    2e06:	11 f0       	breq	.+4      	; 0x2e0c <__floatsisf+0x48>
    2e08:	96 e9       	ldi	r25, 0x96	; 150
    2e0a:	11 c0       	rjmp	.+34     	; 0x2e2e <__floatsisf+0x6a>
    2e0c:	77 23       	and	r23, r23
    2e0e:	21 f0       	breq	.+8      	; 0x2e18 <__floatsisf+0x54>
    2e10:	9e e8       	ldi	r25, 0x8E	; 142
    2e12:	87 2f       	mov	r24, r23
    2e14:	76 2f       	mov	r23, r22
    2e16:	05 c0       	rjmp	.+10     	; 0x2e22 <__floatsisf+0x5e>
    2e18:	66 23       	and	r22, r22
    2e1a:	71 f0       	breq	.+28     	; 0x2e38 <__floatsisf+0x74>
    2e1c:	96 e8       	ldi	r25, 0x86	; 134
    2e1e:	86 2f       	mov	r24, r22
    2e20:	70 e0       	ldi	r23, 0x00	; 0
    2e22:	60 e0       	ldi	r22, 0x00	; 0
    2e24:	2a f0       	brmi	.+10     	; 0x2e30 <__floatsisf+0x6c>
    2e26:	9a 95       	dec	r25
    2e28:	66 0f       	add	r22, r22
    2e2a:	77 1f       	adc	r23, r23
    2e2c:	88 1f       	adc	r24, r24
    2e2e:	da f7       	brpl	.-10     	; 0x2e26 <__floatsisf+0x62>
    2e30:	88 0f       	add	r24, r24
    2e32:	96 95       	lsr	r25
    2e34:	87 95       	ror	r24
    2e36:	97 f9       	bld	r25, 7
    2e38:	08 95       	ret

00002e3a <__fp_inf>:
    2e3a:	97 f9       	bld	r25, 7
    2e3c:	9f 67       	ori	r25, 0x7F	; 127
    2e3e:	80 e8       	ldi	r24, 0x80	; 128
    2e40:	70 e0       	ldi	r23, 0x00	; 0
    2e42:	60 e0       	ldi	r22, 0x00	; 0
    2e44:	08 95       	ret

00002e46 <__fp_nan>:
    2e46:	9f ef       	ldi	r25, 0xFF	; 255
    2e48:	80 ec       	ldi	r24, 0xC0	; 192
    2e4a:	08 95       	ret

00002e4c <__fp_pscA>:
    2e4c:	00 24       	eor	r0, r0
    2e4e:	0a 94       	dec	r0
    2e50:	16 16       	cp	r1, r22
    2e52:	17 06       	cpc	r1, r23
    2e54:	18 06       	cpc	r1, r24
    2e56:	09 06       	cpc	r0, r25
    2e58:	08 95       	ret

00002e5a <__fp_pscB>:
    2e5a:	00 24       	eor	r0, r0
    2e5c:	0a 94       	dec	r0
    2e5e:	12 16       	cp	r1, r18
    2e60:	13 06       	cpc	r1, r19
    2e62:	14 06       	cpc	r1, r20
    2e64:	05 06       	cpc	r0, r21
    2e66:	08 95       	ret

00002e68 <__fp_round>:
    2e68:	09 2e       	mov	r0, r25
    2e6a:	03 94       	inc	r0
    2e6c:	00 0c       	add	r0, r0
    2e6e:	11 f4       	brne	.+4      	; 0x2e74 <__fp_round+0xc>
    2e70:	88 23       	and	r24, r24
    2e72:	52 f0       	brmi	.+20     	; 0x2e88 <__fp_round+0x20>
    2e74:	bb 0f       	add	r27, r27
    2e76:	40 f4       	brcc	.+16     	; 0x2e88 <__fp_round+0x20>
    2e78:	bf 2b       	or	r27, r31
    2e7a:	11 f4       	brne	.+4      	; 0x2e80 <__fp_round+0x18>
    2e7c:	60 ff       	sbrs	r22, 0
    2e7e:	04 c0       	rjmp	.+8      	; 0x2e88 <__fp_round+0x20>
    2e80:	6f 5f       	subi	r22, 0xFF	; 255
    2e82:	7f 4f       	sbci	r23, 0xFF	; 255
    2e84:	8f 4f       	sbci	r24, 0xFF	; 255
    2e86:	9f 4f       	sbci	r25, 0xFF	; 255
    2e88:	08 95       	ret

00002e8a <__fp_split3>:
    2e8a:	57 fd       	sbrc	r21, 7
    2e8c:	90 58       	subi	r25, 0x80	; 128
    2e8e:	44 0f       	add	r20, r20
    2e90:	55 1f       	adc	r21, r21
    2e92:	59 f0       	breq	.+22     	; 0x2eaa <__fp_splitA+0x10>
    2e94:	5f 3f       	cpi	r21, 0xFF	; 255
    2e96:	71 f0       	breq	.+28     	; 0x2eb4 <__fp_splitA+0x1a>
    2e98:	47 95       	ror	r20

00002e9a <__fp_splitA>:
    2e9a:	88 0f       	add	r24, r24
    2e9c:	97 fb       	bst	r25, 7
    2e9e:	99 1f       	adc	r25, r25
    2ea0:	61 f0       	breq	.+24     	; 0x2eba <__fp_splitA+0x20>
    2ea2:	9f 3f       	cpi	r25, 0xFF	; 255
    2ea4:	79 f0       	breq	.+30     	; 0x2ec4 <__fp_splitA+0x2a>
    2ea6:	87 95       	ror	r24
    2ea8:	08 95       	ret
    2eaa:	12 16       	cp	r1, r18
    2eac:	13 06       	cpc	r1, r19
    2eae:	14 06       	cpc	r1, r20
    2eb0:	55 1f       	adc	r21, r21
    2eb2:	f2 cf       	rjmp	.-28     	; 0x2e98 <__fp_split3+0xe>
    2eb4:	46 95       	lsr	r20
    2eb6:	f1 df       	rcall	.-30     	; 0x2e9a <__fp_splitA>
    2eb8:	08 c0       	rjmp	.+16     	; 0x2eca <__fp_splitA+0x30>
    2eba:	16 16       	cp	r1, r22
    2ebc:	17 06       	cpc	r1, r23
    2ebe:	18 06       	cpc	r1, r24
    2ec0:	99 1f       	adc	r25, r25
    2ec2:	f1 cf       	rjmp	.-30     	; 0x2ea6 <__fp_splitA+0xc>
    2ec4:	86 95       	lsr	r24
    2ec6:	71 05       	cpc	r23, r1
    2ec8:	61 05       	cpc	r22, r1
    2eca:	08 94       	sec
    2ecc:	08 95       	ret

00002ece <__fp_zero>:
    2ece:	e8 94       	clt

00002ed0 <__fp_szero>:
    2ed0:	bb 27       	eor	r27, r27
    2ed2:	66 27       	eor	r22, r22
    2ed4:	77 27       	eor	r23, r23
    2ed6:	cb 01       	movw	r24, r22
    2ed8:	97 f9       	bld	r25, 7
    2eda:	08 95       	ret

00002edc <__mulsf3>:
    2edc:	0b d0       	rcall	.+22     	; 0x2ef4 <__mulsf3x>
    2ede:	c4 cf       	rjmp	.-120    	; 0x2e68 <__fp_round>
    2ee0:	b5 df       	rcall	.-150    	; 0x2e4c <__fp_pscA>
    2ee2:	28 f0       	brcs	.+10     	; 0x2eee <__mulsf3+0x12>
    2ee4:	ba df       	rcall	.-140    	; 0x2e5a <__fp_pscB>
    2ee6:	18 f0       	brcs	.+6      	; 0x2eee <__mulsf3+0x12>
    2ee8:	95 23       	and	r25, r21
    2eea:	09 f0       	breq	.+2      	; 0x2eee <__mulsf3+0x12>
    2eec:	a6 cf       	rjmp	.-180    	; 0x2e3a <__fp_inf>
    2eee:	ab cf       	rjmp	.-170    	; 0x2e46 <__fp_nan>
    2ef0:	11 24       	eor	r1, r1
    2ef2:	ee cf       	rjmp	.-36     	; 0x2ed0 <__fp_szero>

00002ef4 <__mulsf3x>:
    2ef4:	ca df       	rcall	.-108    	; 0x2e8a <__fp_split3>
    2ef6:	a0 f3       	brcs	.-24     	; 0x2ee0 <__mulsf3+0x4>

00002ef8 <__mulsf3_pse>:
    2ef8:	95 9f       	mul	r25, r21
    2efa:	d1 f3       	breq	.-12     	; 0x2ef0 <__mulsf3+0x14>
    2efc:	95 0f       	add	r25, r21
    2efe:	50 e0       	ldi	r21, 0x00	; 0
    2f00:	55 1f       	adc	r21, r21
    2f02:	62 9f       	mul	r22, r18
    2f04:	f0 01       	movw	r30, r0
    2f06:	72 9f       	mul	r23, r18
    2f08:	bb 27       	eor	r27, r27
    2f0a:	f0 0d       	add	r31, r0
    2f0c:	b1 1d       	adc	r27, r1
    2f0e:	63 9f       	mul	r22, r19
    2f10:	aa 27       	eor	r26, r26
    2f12:	f0 0d       	add	r31, r0
    2f14:	b1 1d       	adc	r27, r1
    2f16:	aa 1f       	adc	r26, r26
    2f18:	64 9f       	mul	r22, r20
    2f1a:	66 27       	eor	r22, r22
    2f1c:	b0 0d       	add	r27, r0
    2f1e:	a1 1d       	adc	r26, r1
    2f20:	66 1f       	adc	r22, r22
    2f22:	82 9f       	mul	r24, r18
    2f24:	22 27       	eor	r18, r18
    2f26:	b0 0d       	add	r27, r0
    2f28:	a1 1d       	adc	r26, r1
    2f2a:	62 1f       	adc	r22, r18
    2f2c:	73 9f       	mul	r23, r19
    2f2e:	b0 0d       	add	r27, r0
    2f30:	a1 1d       	adc	r26, r1
    2f32:	62 1f       	adc	r22, r18
    2f34:	83 9f       	mul	r24, r19
    2f36:	a0 0d       	add	r26, r0
    2f38:	61 1d       	adc	r22, r1
    2f3a:	22 1f       	adc	r18, r18
    2f3c:	74 9f       	mul	r23, r20
    2f3e:	33 27       	eor	r19, r19
    2f40:	a0 0d       	add	r26, r0
    2f42:	61 1d       	adc	r22, r1
    2f44:	23 1f       	adc	r18, r19
    2f46:	84 9f       	mul	r24, r20
    2f48:	60 0d       	add	r22, r0
    2f4a:	21 1d       	adc	r18, r1
    2f4c:	82 2f       	mov	r24, r18
    2f4e:	76 2f       	mov	r23, r22
    2f50:	6a 2f       	mov	r22, r26
    2f52:	11 24       	eor	r1, r1
    2f54:	9f 57       	subi	r25, 0x7F	; 127
    2f56:	50 40       	sbci	r21, 0x00	; 0
    2f58:	8a f0       	brmi	.+34     	; 0x2f7c <__mulsf3_pse+0x84>
    2f5a:	e1 f0       	breq	.+56     	; 0x2f94 <__mulsf3_pse+0x9c>
    2f5c:	88 23       	and	r24, r24
    2f5e:	4a f0       	brmi	.+18     	; 0x2f72 <__mulsf3_pse+0x7a>
    2f60:	ee 0f       	add	r30, r30
    2f62:	ff 1f       	adc	r31, r31
    2f64:	bb 1f       	adc	r27, r27
    2f66:	66 1f       	adc	r22, r22
    2f68:	77 1f       	adc	r23, r23
    2f6a:	88 1f       	adc	r24, r24
    2f6c:	91 50       	subi	r25, 0x01	; 1
    2f6e:	50 40       	sbci	r21, 0x00	; 0
    2f70:	a9 f7       	brne	.-22     	; 0x2f5c <__mulsf3_pse+0x64>
    2f72:	9e 3f       	cpi	r25, 0xFE	; 254
    2f74:	51 05       	cpc	r21, r1
    2f76:	70 f0       	brcs	.+28     	; 0x2f94 <__mulsf3_pse+0x9c>
    2f78:	60 cf       	rjmp	.-320    	; 0x2e3a <__fp_inf>
    2f7a:	aa cf       	rjmp	.-172    	; 0x2ed0 <__fp_szero>
    2f7c:	5f 3f       	cpi	r21, 0xFF	; 255
    2f7e:	ec f3       	brlt	.-6      	; 0x2f7a <__mulsf3_pse+0x82>
    2f80:	98 3e       	cpi	r25, 0xE8	; 232
    2f82:	dc f3       	brlt	.-10     	; 0x2f7a <__mulsf3_pse+0x82>
    2f84:	86 95       	lsr	r24
    2f86:	77 95       	ror	r23
    2f88:	67 95       	ror	r22
    2f8a:	b7 95       	ror	r27
    2f8c:	f7 95       	ror	r31
    2f8e:	e7 95       	ror	r30
    2f90:	9f 5f       	subi	r25, 0xFF	; 255
    2f92:	c1 f7       	brne	.-16     	; 0x2f84 <__mulsf3_pse+0x8c>
    2f94:	fe 2b       	or	r31, r30
    2f96:	88 0f       	add	r24, r24
    2f98:	91 1d       	adc	r25, r1
    2f9a:	96 95       	lsr	r25
    2f9c:	87 95       	ror	r24
    2f9e:	97 f9       	bld	r25, 7
    2fa0:	08 95       	ret

00002fa2 <__udivmodsi4>:
    2fa2:	a1 e2       	ldi	r26, 0x21	; 33
    2fa4:	1a 2e       	mov	r1, r26
    2fa6:	aa 1b       	sub	r26, r26
    2fa8:	bb 1b       	sub	r27, r27
    2faa:	fd 01       	movw	r30, r26
    2fac:	0d c0       	rjmp	.+26     	; 0x2fc8 <__udivmodsi4_ep>

00002fae <__udivmodsi4_loop>:
    2fae:	aa 1f       	adc	r26, r26
    2fb0:	bb 1f       	adc	r27, r27
    2fb2:	ee 1f       	adc	r30, r30
    2fb4:	ff 1f       	adc	r31, r31
    2fb6:	a2 17       	cp	r26, r18
    2fb8:	b3 07       	cpc	r27, r19
    2fba:	e4 07       	cpc	r30, r20
    2fbc:	f5 07       	cpc	r31, r21
    2fbe:	20 f0       	brcs	.+8      	; 0x2fc8 <__udivmodsi4_ep>
    2fc0:	a2 1b       	sub	r26, r18
    2fc2:	b3 0b       	sbc	r27, r19
    2fc4:	e4 0b       	sbc	r30, r20
    2fc6:	f5 0b       	sbc	r31, r21

00002fc8 <__udivmodsi4_ep>:
    2fc8:	66 1f       	adc	r22, r22
    2fca:	77 1f       	adc	r23, r23
    2fcc:	88 1f       	adc	r24, r24
    2fce:	99 1f       	adc	r25, r25
    2fd0:	1a 94       	dec	r1
    2fd2:	69 f7       	brne	.-38     	; 0x2fae <__udivmodsi4_loop>
    2fd4:	60 95       	com	r22
    2fd6:	70 95       	com	r23
    2fd8:	80 95       	com	r24
    2fda:	90 95       	com	r25
    2fdc:	9b 01       	movw	r18, r22
    2fde:	ac 01       	movw	r20, r24
    2fe0:	bd 01       	movw	r22, r26
    2fe2:	cf 01       	movw	r24, r30
    2fe4:	08 95       	ret

00002fe6 <__umulhisi3>:
    2fe6:	a2 9f       	mul	r26, r18
    2fe8:	b0 01       	movw	r22, r0
    2fea:	b3 9f       	mul	r27, r19
    2fec:	c0 01       	movw	r24, r0
    2fee:	a3 9f       	mul	r26, r19
    2ff0:	70 0d       	add	r23, r0
    2ff2:	81 1d       	adc	r24, r1
    2ff4:	11 24       	eor	r1, r1
    2ff6:	91 1d       	adc	r25, r1
    2ff8:	b2 9f       	mul	r27, r18
    2ffa:	70 0d       	add	r23, r0
    2ffc:	81 1d       	adc	r24, r1
    2ffe:	11 24       	eor	r1, r1
    3000:	91 1d       	adc	r25, r1
    3002:	08 95       	ret

00003004 <__muluhisi3>:
    3004:	f0 df       	rcall	.-32     	; 0x2fe6 <__umulhisi3>
    3006:	a5 9f       	mul	r26, r21
    3008:	90 0d       	add	r25, r0
    300a:	b4 9f       	mul	r27, r20
    300c:	90 0d       	add	r25, r0
    300e:	a4 9f       	mul	r26, r20
    3010:	80 0d       	add	r24, r0
    3012:	91 1d       	adc	r25, r1
    3014:	11 24       	eor	r1, r1
    3016:	08 95       	ret

00003018 <memcpy>:
    3018:	fb 01       	movw	r30, r22
    301a:	dc 01       	movw	r26, r24
    301c:	02 c0       	rjmp	.+4      	; 0x3022 <memcpy+0xa>
    301e:	01 90       	ld	r0, Z+
    3020:	0d 92       	st	X+, r0
    3022:	41 50       	subi	r20, 0x01	; 1
    3024:	50 40       	sbci	r21, 0x00	; 0
    3026:	d8 f7       	brcc	.-10     	; 0x301e <memcpy+0x6>
    3028:	08 95       	ret

0000302a <strcmp>:
    302a:	fb 01       	movw	r30, r22
    302c:	dc 01       	movw	r26, r24
    302e:	8d 91       	ld	r24, X+
    3030:	01 90       	ld	r0, Z+
    3032:	80 19       	sub	r24, r0
    3034:	01 10       	cpse	r0, r1
    3036:	d9 f3       	breq	.-10     	; 0x302e <strcmp+0x4>
    3038:	99 0b       	sbc	r25, r25
    303a:	08 95       	ret

0000303c <sprintf>:
    303c:	0f 93       	push	r16
    303e:	1f 93       	push	r17
    3040:	cf 93       	push	r28
    3042:	df 93       	push	r29
    3044:	cd b7       	in	r28, 0x3d	; 61
    3046:	de b7       	in	r29, 0x3e	; 62
    3048:	2e 97       	sbiw	r28, 0x0e	; 14
    304a:	0f b6       	in	r0, 0x3f	; 63
    304c:	f8 94       	cli
    304e:	de bf       	out	0x3e, r29	; 62
    3050:	0f be       	out	0x3f, r0	; 63
    3052:	cd bf       	out	0x3d, r28	; 61
    3054:	0d 89       	ldd	r16, Y+21	; 0x15
    3056:	1e 89       	ldd	r17, Y+22	; 0x16
    3058:	86 e0       	ldi	r24, 0x06	; 6
    305a:	8c 83       	std	Y+4, r24	; 0x04
    305c:	1a 83       	std	Y+2, r17	; 0x02
    305e:	09 83       	std	Y+1, r16	; 0x01
    3060:	8f ef       	ldi	r24, 0xFF	; 255
    3062:	9f e7       	ldi	r25, 0x7F	; 127
    3064:	9e 83       	std	Y+6, r25	; 0x06
    3066:	8d 83       	std	Y+5, r24	; 0x05
    3068:	ae 01       	movw	r20, r28
    306a:	47 5e       	subi	r20, 0xE7	; 231
    306c:	5f 4f       	sbci	r21, 0xFF	; 255
    306e:	6f 89       	ldd	r22, Y+23	; 0x17
    3070:	78 8d       	ldd	r23, Y+24	; 0x18
    3072:	ce 01       	movw	r24, r28
    3074:	01 96       	adiw	r24, 0x01	; 1
    3076:	10 d0       	rcall	.+32     	; 0x3098 <vfprintf>
    3078:	ef 81       	ldd	r30, Y+7	; 0x07
    307a:	f8 85       	ldd	r31, Y+8	; 0x08
    307c:	e0 0f       	add	r30, r16
    307e:	f1 1f       	adc	r31, r17
    3080:	10 82       	st	Z, r1
    3082:	2e 96       	adiw	r28, 0x0e	; 14
    3084:	0f b6       	in	r0, 0x3f	; 63
    3086:	f8 94       	cli
    3088:	de bf       	out	0x3e, r29	; 62
    308a:	0f be       	out	0x3f, r0	; 63
    308c:	cd bf       	out	0x3d, r28	; 61
    308e:	df 91       	pop	r29
    3090:	cf 91       	pop	r28
    3092:	1f 91       	pop	r17
    3094:	0f 91       	pop	r16
    3096:	08 95       	ret

00003098 <vfprintf>:
    3098:	2f 92       	push	r2
    309a:	3f 92       	push	r3
    309c:	4f 92       	push	r4
    309e:	5f 92       	push	r5
    30a0:	6f 92       	push	r6
    30a2:	7f 92       	push	r7
    30a4:	8f 92       	push	r8
    30a6:	9f 92       	push	r9
    30a8:	af 92       	push	r10
    30aa:	bf 92       	push	r11
    30ac:	cf 92       	push	r12
    30ae:	df 92       	push	r13
    30b0:	ef 92       	push	r14
    30b2:	ff 92       	push	r15
    30b4:	0f 93       	push	r16
    30b6:	1f 93       	push	r17
    30b8:	cf 93       	push	r28
    30ba:	df 93       	push	r29
    30bc:	cd b7       	in	r28, 0x3d	; 61
    30be:	de b7       	in	r29, 0x3e	; 62
    30c0:	2b 97       	sbiw	r28, 0x0b	; 11
    30c2:	0f b6       	in	r0, 0x3f	; 63
    30c4:	f8 94       	cli
    30c6:	de bf       	out	0x3e, r29	; 62
    30c8:	0f be       	out	0x3f, r0	; 63
    30ca:	cd bf       	out	0x3d, r28	; 61
    30cc:	6c 01       	movw	r12, r24
    30ce:	7b 01       	movw	r14, r22
    30d0:	8a 01       	movw	r16, r20
    30d2:	fc 01       	movw	r30, r24
    30d4:	17 82       	std	Z+7, r1	; 0x07
    30d6:	16 82       	std	Z+6, r1	; 0x06
    30d8:	83 81       	ldd	r24, Z+3	; 0x03
    30da:	81 ff       	sbrs	r24, 1
    30dc:	bf c1       	rjmp	.+894    	; 0x345c <vfprintf+0x3c4>
    30de:	ce 01       	movw	r24, r28
    30e0:	01 96       	adiw	r24, 0x01	; 1
    30e2:	3c 01       	movw	r6, r24
    30e4:	f6 01       	movw	r30, r12
    30e6:	93 81       	ldd	r25, Z+3	; 0x03
    30e8:	f7 01       	movw	r30, r14
    30ea:	93 fd       	sbrc	r25, 3
    30ec:	85 91       	lpm	r24, Z+
    30ee:	93 ff       	sbrs	r25, 3
    30f0:	81 91       	ld	r24, Z+
    30f2:	7f 01       	movw	r14, r30
    30f4:	88 23       	and	r24, r24
    30f6:	09 f4       	brne	.+2      	; 0x30fa <vfprintf+0x62>
    30f8:	ad c1       	rjmp	.+858    	; 0x3454 <vfprintf+0x3bc>
    30fa:	85 32       	cpi	r24, 0x25	; 37
    30fc:	39 f4       	brne	.+14     	; 0x310c <vfprintf+0x74>
    30fe:	93 fd       	sbrc	r25, 3
    3100:	85 91       	lpm	r24, Z+
    3102:	93 ff       	sbrs	r25, 3
    3104:	81 91       	ld	r24, Z+
    3106:	7f 01       	movw	r14, r30
    3108:	85 32       	cpi	r24, 0x25	; 37
    310a:	21 f4       	brne	.+8      	; 0x3114 <vfprintf+0x7c>
    310c:	b6 01       	movw	r22, r12
    310e:	90 e0       	ldi	r25, 0x00	; 0
    3110:	d6 d1       	rcall	.+940    	; 0x34be <fputc>
    3112:	e8 cf       	rjmp	.-48     	; 0x30e4 <vfprintf+0x4c>
    3114:	91 2c       	mov	r9, r1
    3116:	21 2c       	mov	r2, r1
    3118:	31 2c       	mov	r3, r1
    311a:	ff e1       	ldi	r31, 0x1F	; 31
    311c:	f3 15       	cp	r31, r3
    311e:	d8 f0       	brcs	.+54     	; 0x3156 <vfprintf+0xbe>
    3120:	8b 32       	cpi	r24, 0x2B	; 43
    3122:	79 f0       	breq	.+30     	; 0x3142 <vfprintf+0xaa>
    3124:	38 f4       	brcc	.+14     	; 0x3134 <vfprintf+0x9c>
    3126:	80 32       	cpi	r24, 0x20	; 32
    3128:	79 f0       	breq	.+30     	; 0x3148 <vfprintf+0xb0>
    312a:	83 32       	cpi	r24, 0x23	; 35
    312c:	a1 f4       	brne	.+40     	; 0x3156 <vfprintf+0xbe>
    312e:	23 2d       	mov	r18, r3
    3130:	20 61       	ori	r18, 0x10	; 16
    3132:	1d c0       	rjmp	.+58     	; 0x316e <vfprintf+0xd6>
    3134:	8d 32       	cpi	r24, 0x2D	; 45
    3136:	61 f0       	breq	.+24     	; 0x3150 <vfprintf+0xb8>
    3138:	80 33       	cpi	r24, 0x30	; 48
    313a:	69 f4       	brne	.+26     	; 0x3156 <vfprintf+0xbe>
    313c:	23 2d       	mov	r18, r3
    313e:	21 60       	ori	r18, 0x01	; 1
    3140:	16 c0       	rjmp	.+44     	; 0x316e <vfprintf+0xd6>
    3142:	83 2d       	mov	r24, r3
    3144:	82 60       	ori	r24, 0x02	; 2
    3146:	38 2e       	mov	r3, r24
    3148:	e3 2d       	mov	r30, r3
    314a:	e4 60       	ori	r30, 0x04	; 4
    314c:	3e 2e       	mov	r3, r30
    314e:	2a c0       	rjmp	.+84     	; 0x31a4 <vfprintf+0x10c>
    3150:	f3 2d       	mov	r31, r3
    3152:	f8 60       	ori	r31, 0x08	; 8
    3154:	1d c0       	rjmp	.+58     	; 0x3190 <vfprintf+0xf8>
    3156:	37 fc       	sbrc	r3, 7
    3158:	2d c0       	rjmp	.+90     	; 0x31b4 <vfprintf+0x11c>
    315a:	20 ed       	ldi	r18, 0xD0	; 208
    315c:	28 0f       	add	r18, r24
    315e:	2a 30       	cpi	r18, 0x0A	; 10
    3160:	40 f0       	brcs	.+16     	; 0x3172 <vfprintf+0xda>
    3162:	8e 32       	cpi	r24, 0x2E	; 46
    3164:	b9 f4       	brne	.+46     	; 0x3194 <vfprintf+0xfc>
    3166:	36 fc       	sbrc	r3, 6
    3168:	75 c1       	rjmp	.+746    	; 0x3454 <vfprintf+0x3bc>
    316a:	23 2d       	mov	r18, r3
    316c:	20 64       	ori	r18, 0x40	; 64
    316e:	32 2e       	mov	r3, r18
    3170:	19 c0       	rjmp	.+50     	; 0x31a4 <vfprintf+0x10c>
    3172:	36 fe       	sbrs	r3, 6
    3174:	06 c0       	rjmp	.+12     	; 0x3182 <vfprintf+0xea>
    3176:	8a e0       	ldi	r24, 0x0A	; 10
    3178:	98 9e       	mul	r9, r24
    317a:	20 0d       	add	r18, r0
    317c:	11 24       	eor	r1, r1
    317e:	92 2e       	mov	r9, r18
    3180:	11 c0       	rjmp	.+34     	; 0x31a4 <vfprintf+0x10c>
    3182:	ea e0       	ldi	r30, 0x0A	; 10
    3184:	2e 9e       	mul	r2, r30
    3186:	20 0d       	add	r18, r0
    3188:	11 24       	eor	r1, r1
    318a:	22 2e       	mov	r2, r18
    318c:	f3 2d       	mov	r31, r3
    318e:	f0 62       	ori	r31, 0x20	; 32
    3190:	3f 2e       	mov	r3, r31
    3192:	08 c0       	rjmp	.+16     	; 0x31a4 <vfprintf+0x10c>
    3194:	8c 36       	cpi	r24, 0x6C	; 108
    3196:	21 f4       	brne	.+8      	; 0x31a0 <vfprintf+0x108>
    3198:	83 2d       	mov	r24, r3
    319a:	80 68       	ori	r24, 0x80	; 128
    319c:	38 2e       	mov	r3, r24
    319e:	02 c0       	rjmp	.+4      	; 0x31a4 <vfprintf+0x10c>
    31a0:	88 36       	cpi	r24, 0x68	; 104
    31a2:	41 f4       	brne	.+16     	; 0x31b4 <vfprintf+0x11c>
    31a4:	f7 01       	movw	r30, r14
    31a6:	93 fd       	sbrc	r25, 3
    31a8:	85 91       	lpm	r24, Z+
    31aa:	93 ff       	sbrs	r25, 3
    31ac:	81 91       	ld	r24, Z+
    31ae:	7f 01       	movw	r14, r30
    31b0:	81 11       	cpse	r24, r1
    31b2:	b3 cf       	rjmp	.-154    	; 0x311a <vfprintf+0x82>
    31b4:	98 2f       	mov	r25, r24
    31b6:	9f 7d       	andi	r25, 0xDF	; 223
    31b8:	95 54       	subi	r25, 0x45	; 69
    31ba:	93 30       	cpi	r25, 0x03	; 3
    31bc:	28 f4       	brcc	.+10     	; 0x31c8 <vfprintf+0x130>
    31be:	0c 5f       	subi	r16, 0xFC	; 252
    31c0:	1f 4f       	sbci	r17, 0xFF	; 255
    31c2:	9f e3       	ldi	r25, 0x3F	; 63
    31c4:	99 83       	std	Y+1, r25	; 0x01
    31c6:	0d c0       	rjmp	.+26     	; 0x31e2 <vfprintf+0x14a>
    31c8:	83 36       	cpi	r24, 0x63	; 99
    31ca:	31 f0       	breq	.+12     	; 0x31d8 <vfprintf+0x140>
    31cc:	83 37       	cpi	r24, 0x73	; 115
    31ce:	71 f0       	breq	.+28     	; 0x31ec <vfprintf+0x154>
    31d0:	83 35       	cpi	r24, 0x53	; 83
    31d2:	09 f0       	breq	.+2      	; 0x31d6 <vfprintf+0x13e>
    31d4:	55 c0       	rjmp	.+170    	; 0x3280 <vfprintf+0x1e8>
    31d6:	20 c0       	rjmp	.+64     	; 0x3218 <vfprintf+0x180>
    31d8:	f8 01       	movw	r30, r16
    31da:	80 81       	ld	r24, Z
    31dc:	89 83       	std	Y+1, r24	; 0x01
    31de:	0e 5f       	subi	r16, 0xFE	; 254
    31e0:	1f 4f       	sbci	r17, 0xFF	; 255
    31e2:	88 24       	eor	r8, r8
    31e4:	83 94       	inc	r8
    31e6:	91 2c       	mov	r9, r1
    31e8:	53 01       	movw	r10, r6
    31ea:	12 c0       	rjmp	.+36     	; 0x3210 <vfprintf+0x178>
    31ec:	28 01       	movw	r4, r16
    31ee:	f2 e0       	ldi	r31, 0x02	; 2
    31f0:	4f 0e       	add	r4, r31
    31f2:	51 1c       	adc	r5, r1
    31f4:	f8 01       	movw	r30, r16
    31f6:	a0 80       	ld	r10, Z
    31f8:	b1 80       	ldd	r11, Z+1	; 0x01
    31fa:	36 fe       	sbrs	r3, 6
    31fc:	03 c0       	rjmp	.+6      	; 0x3204 <vfprintf+0x16c>
    31fe:	69 2d       	mov	r22, r9
    3200:	70 e0       	ldi	r23, 0x00	; 0
    3202:	02 c0       	rjmp	.+4      	; 0x3208 <vfprintf+0x170>
    3204:	6f ef       	ldi	r22, 0xFF	; 255
    3206:	7f ef       	ldi	r23, 0xFF	; 255
    3208:	c5 01       	movw	r24, r10
    320a:	4e d1       	rcall	.+668    	; 0x34a8 <strnlen>
    320c:	4c 01       	movw	r8, r24
    320e:	82 01       	movw	r16, r4
    3210:	f3 2d       	mov	r31, r3
    3212:	ff 77       	andi	r31, 0x7F	; 127
    3214:	3f 2e       	mov	r3, r31
    3216:	15 c0       	rjmp	.+42     	; 0x3242 <vfprintf+0x1aa>
    3218:	28 01       	movw	r4, r16
    321a:	22 e0       	ldi	r18, 0x02	; 2
    321c:	42 0e       	add	r4, r18
    321e:	51 1c       	adc	r5, r1
    3220:	f8 01       	movw	r30, r16
    3222:	a0 80       	ld	r10, Z
    3224:	b1 80       	ldd	r11, Z+1	; 0x01
    3226:	36 fe       	sbrs	r3, 6
    3228:	03 c0       	rjmp	.+6      	; 0x3230 <vfprintf+0x198>
    322a:	69 2d       	mov	r22, r9
    322c:	70 e0       	ldi	r23, 0x00	; 0
    322e:	02 c0       	rjmp	.+4      	; 0x3234 <vfprintf+0x19c>
    3230:	6f ef       	ldi	r22, 0xFF	; 255
    3232:	7f ef       	ldi	r23, 0xFF	; 255
    3234:	c5 01       	movw	r24, r10
    3236:	2d d1       	rcall	.+602    	; 0x3492 <strnlen_P>
    3238:	4c 01       	movw	r8, r24
    323a:	f3 2d       	mov	r31, r3
    323c:	f0 68       	ori	r31, 0x80	; 128
    323e:	3f 2e       	mov	r3, r31
    3240:	82 01       	movw	r16, r4
    3242:	33 fc       	sbrc	r3, 3
    3244:	19 c0       	rjmp	.+50     	; 0x3278 <vfprintf+0x1e0>
    3246:	82 2d       	mov	r24, r2
    3248:	90 e0       	ldi	r25, 0x00	; 0
    324a:	88 16       	cp	r8, r24
    324c:	99 06       	cpc	r9, r25
    324e:	a0 f4       	brcc	.+40     	; 0x3278 <vfprintf+0x1e0>
    3250:	b6 01       	movw	r22, r12
    3252:	80 e2       	ldi	r24, 0x20	; 32
    3254:	90 e0       	ldi	r25, 0x00	; 0
    3256:	33 d1       	rcall	.+614    	; 0x34be <fputc>
    3258:	2a 94       	dec	r2
    325a:	f5 cf       	rjmp	.-22     	; 0x3246 <vfprintf+0x1ae>
    325c:	f5 01       	movw	r30, r10
    325e:	37 fc       	sbrc	r3, 7
    3260:	85 91       	lpm	r24, Z+
    3262:	37 fe       	sbrs	r3, 7
    3264:	81 91       	ld	r24, Z+
    3266:	5f 01       	movw	r10, r30
    3268:	b6 01       	movw	r22, r12
    326a:	90 e0       	ldi	r25, 0x00	; 0
    326c:	28 d1       	rcall	.+592    	; 0x34be <fputc>
    326e:	21 10       	cpse	r2, r1
    3270:	2a 94       	dec	r2
    3272:	21 e0       	ldi	r18, 0x01	; 1
    3274:	82 1a       	sub	r8, r18
    3276:	91 08       	sbc	r9, r1
    3278:	81 14       	cp	r8, r1
    327a:	91 04       	cpc	r9, r1
    327c:	79 f7       	brne	.-34     	; 0x325c <vfprintf+0x1c4>
    327e:	e1 c0       	rjmp	.+450    	; 0x3442 <vfprintf+0x3aa>
    3280:	84 36       	cpi	r24, 0x64	; 100
    3282:	11 f0       	breq	.+4      	; 0x3288 <vfprintf+0x1f0>
    3284:	89 36       	cpi	r24, 0x69	; 105
    3286:	39 f5       	brne	.+78     	; 0x32d6 <vfprintf+0x23e>
    3288:	f8 01       	movw	r30, r16
    328a:	37 fe       	sbrs	r3, 7
    328c:	07 c0       	rjmp	.+14     	; 0x329c <vfprintf+0x204>
    328e:	60 81       	ld	r22, Z
    3290:	71 81       	ldd	r23, Z+1	; 0x01
    3292:	82 81       	ldd	r24, Z+2	; 0x02
    3294:	93 81       	ldd	r25, Z+3	; 0x03
    3296:	0c 5f       	subi	r16, 0xFC	; 252
    3298:	1f 4f       	sbci	r17, 0xFF	; 255
    329a:	08 c0       	rjmp	.+16     	; 0x32ac <vfprintf+0x214>
    329c:	60 81       	ld	r22, Z
    329e:	71 81       	ldd	r23, Z+1	; 0x01
    32a0:	07 2e       	mov	r0, r23
    32a2:	00 0c       	add	r0, r0
    32a4:	88 0b       	sbc	r24, r24
    32a6:	99 0b       	sbc	r25, r25
    32a8:	0e 5f       	subi	r16, 0xFE	; 254
    32aa:	1f 4f       	sbci	r17, 0xFF	; 255
    32ac:	f3 2d       	mov	r31, r3
    32ae:	ff 76       	andi	r31, 0x6F	; 111
    32b0:	3f 2e       	mov	r3, r31
    32b2:	97 ff       	sbrs	r25, 7
    32b4:	09 c0       	rjmp	.+18     	; 0x32c8 <vfprintf+0x230>
    32b6:	90 95       	com	r25
    32b8:	80 95       	com	r24
    32ba:	70 95       	com	r23
    32bc:	61 95       	neg	r22
    32be:	7f 4f       	sbci	r23, 0xFF	; 255
    32c0:	8f 4f       	sbci	r24, 0xFF	; 255
    32c2:	9f 4f       	sbci	r25, 0xFF	; 255
    32c4:	f0 68       	ori	r31, 0x80	; 128
    32c6:	3f 2e       	mov	r3, r31
    32c8:	2a e0       	ldi	r18, 0x0A	; 10
    32ca:	30 e0       	ldi	r19, 0x00	; 0
    32cc:	a3 01       	movw	r20, r6
    32ce:	33 d1       	rcall	.+614    	; 0x3536 <__ultoa_invert>
    32d0:	88 2e       	mov	r8, r24
    32d2:	86 18       	sub	r8, r6
    32d4:	44 c0       	rjmp	.+136    	; 0x335e <vfprintf+0x2c6>
    32d6:	85 37       	cpi	r24, 0x75	; 117
    32d8:	31 f4       	brne	.+12     	; 0x32e6 <vfprintf+0x24e>
    32da:	23 2d       	mov	r18, r3
    32dc:	2f 7e       	andi	r18, 0xEF	; 239
    32de:	b2 2e       	mov	r11, r18
    32e0:	2a e0       	ldi	r18, 0x0A	; 10
    32e2:	30 e0       	ldi	r19, 0x00	; 0
    32e4:	25 c0       	rjmp	.+74     	; 0x3330 <vfprintf+0x298>
    32e6:	93 2d       	mov	r25, r3
    32e8:	99 7f       	andi	r25, 0xF9	; 249
    32ea:	b9 2e       	mov	r11, r25
    32ec:	8f 36       	cpi	r24, 0x6F	; 111
    32ee:	c1 f0       	breq	.+48     	; 0x3320 <vfprintf+0x288>
    32f0:	18 f4       	brcc	.+6      	; 0x32f8 <vfprintf+0x260>
    32f2:	88 35       	cpi	r24, 0x58	; 88
    32f4:	79 f0       	breq	.+30     	; 0x3314 <vfprintf+0x27c>
    32f6:	ae c0       	rjmp	.+348    	; 0x3454 <vfprintf+0x3bc>
    32f8:	80 37       	cpi	r24, 0x70	; 112
    32fa:	19 f0       	breq	.+6      	; 0x3302 <vfprintf+0x26a>
    32fc:	88 37       	cpi	r24, 0x78	; 120
    32fe:	21 f0       	breq	.+8      	; 0x3308 <vfprintf+0x270>
    3300:	a9 c0       	rjmp	.+338    	; 0x3454 <vfprintf+0x3bc>
    3302:	e9 2f       	mov	r30, r25
    3304:	e0 61       	ori	r30, 0x10	; 16
    3306:	be 2e       	mov	r11, r30
    3308:	b4 fe       	sbrs	r11, 4
    330a:	0d c0       	rjmp	.+26     	; 0x3326 <vfprintf+0x28e>
    330c:	fb 2d       	mov	r31, r11
    330e:	f4 60       	ori	r31, 0x04	; 4
    3310:	bf 2e       	mov	r11, r31
    3312:	09 c0       	rjmp	.+18     	; 0x3326 <vfprintf+0x28e>
    3314:	34 fe       	sbrs	r3, 4
    3316:	0a c0       	rjmp	.+20     	; 0x332c <vfprintf+0x294>
    3318:	29 2f       	mov	r18, r25
    331a:	26 60       	ori	r18, 0x06	; 6
    331c:	b2 2e       	mov	r11, r18
    331e:	06 c0       	rjmp	.+12     	; 0x332c <vfprintf+0x294>
    3320:	28 e0       	ldi	r18, 0x08	; 8
    3322:	30 e0       	ldi	r19, 0x00	; 0
    3324:	05 c0       	rjmp	.+10     	; 0x3330 <vfprintf+0x298>
    3326:	20 e1       	ldi	r18, 0x10	; 16
    3328:	30 e0       	ldi	r19, 0x00	; 0
    332a:	02 c0       	rjmp	.+4      	; 0x3330 <vfprintf+0x298>
    332c:	20 e1       	ldi	r18, 0x10	; 16
    332e:	32 e0       	ldi	r19, 0x02	; 2
    3330:	f8 01       	movw	r30, r16
    3332:	b7 fe       	sbrs	r11, 7
    3334:	07 c0       	rjmp	.+14     	; 0x3344 <vfprintf+0x2ac>
    3336:	60 81       	ld	r22, Z
    3338:	71 81       	ldd	r23, Z+1	; 0x01
    333a:	82 81       	ldd	r24, Z+2	; 0x02
    333c:	93 81       	ldd	r25, Z+3	; 0x03
    333e:	0c 5f       	subi	r16, 0xFC	; 252
    3340:	1f 4f       	sbci	r17, 0xFF	; 255
    3342:	06 c0       	rjmp	.+12     	; 0x3350 <vfprintf+0x2b8>
    3344:	60 81       	ld	r22, Z
    3346:	71 81       	ldd	r23, Z+1	; 0x01
    3348:	80 e0       	ldi	r24, 0x00	; 0
    334a:	90 e0       	ldi	r25, 0x00	; 0
    334c:	0e 5f       	subi	r16, 0xFE	; 254
    334e:	1f 4f       	sbci	r17, 0xFF	; 255
    3350:	a3 01       	movw	r20, r6
    3352:	f1 d0       	rcall	.+482    	; 0x3536 <__ultoa_invert>
    3354:	88 2e       	mov	r8, r24
    3356:	86 18       	sub	r8, r6
    3358:	fb 2d       	mov	r31, r11
    335a:	ff 77       	andi	r31, 0x7F	; 127
    335c:	3f 2e       	mov	r3, r31
    335e:	36 fe       	sbrs	r3, 6
    3360:	0d c0       	rjmp	.+26     	; 0x337c <vfprintf+0x2e4>
    3362:	23 2d       	mov	r18, r3
    3364:	2e 7f       	andi	r18, 0xFE	; 254
    3366:	a2 2e       	mov	r10, r18
    3368:	89 14       	cp	r8, r9
    336a:	58 f4       	brcc	.+22     	; 0x3382 <vfprintf+0x2ea>
    336c:	34 fe       	sbrs	r3, 4
    336e:	0b c0       	rjmp	.+22     	; 0x3386 <vfprintf+0x2ee>
    3370:	32 fc       	sbrc	r3, 2
    3372:	09 c0       	rjmp	.+18     	; 0x3386 <vfprintf+0x2ee>
    3374:	83 2d       	mov	r24, r3
    3376:	8e 7e       	andi	r24, 0xEE	; 238
    3378:	a8 2e       	mov	r10, r24
    337a:	05 c0       	rjmp	.+10     	; 0x3386 <vfprintf+0x2ee>
    337c:	b8 2c       	mov	r11, r8
    337e:	a3 2c       	mov	r10, r3
    3380:	03 c0       	rjmp	.+6      	; 0x3388 <vfprintf+0x2f0>
    3382:	b8 2c       	mov	r11, r8
    3384:	01 c0       	rjmp	.+2      	; 0x3388 <vfprintf+0x2f0>
    3386:	b9 2c       	mov	r11, r9
    3388:	a4 fe       	sbrs	r10, 4
    338a:	0f c0       	rjmp	.+30     	; 0x33aa <vfprintf+0x312>
    338c:	fe 01       	movw	r30, r28
    338e:	e8 0d       	add	r30, r8
    3390:	f1 1d       	adc	r31, r1
    3392:	80 81       	ld	r24, Z
    3394:	80 33       	cpi	r24, 0x30	; 48
    3396:	21 f4       	brne	.+8      	; 0x33a0 <vfprintf+0x308>
    3398:	9a 2d       	mov	r25, r10
    339a:	99 7e       	andi	r25, 0xE9	; 233
    339c:	a9 2e       	mov	r10, r25
    339e:	09 c0       	rjmp	.+18     	; 0x33b2 <vfprintf+0x31a>
    33a0:	a2 fe       	sbrs	r10, 2
    33a2:	06 c0       	rjmp	.+12     	; 0x33b0 <vfprintf+0x318>
    33a4:	b3 94       	inc	r11
    33a6:	b3 94       	inc	r11
    33a8:	04 c0       	rjmp	.+8      	; 0x33b2 <vfprintf+0x31a>
    33aa:	8a 2d       	mov	r24, r10
    33ac:	86 78       	andi	r24, 0x86	; 134
    33ae:	09 f0       	breq	.+2      	; 0x33b2 <vfprintf+0x31a>
    33b0:	b3 94       	inc	r11
    33b2:	a3 fc       	sbrc	r10, 3
    33b4:	10 c0       	rjmp	.+32     	; 0x33d6 <vfprintf+0x33e>
    33b6:	a0 fe       	sbrs	r10, 0
    33b8:	06 c0       	rjmp	.+12     	; 0x33c6 <vfprintf+0x32e>
    33ba:	b2 14       	cp	r11, r2
    33bc:	80 f4       	brcc	.+32     	; 0x33de <vfprintf+0x346>
    33be:	28 0c       	add	r2, r8
    33c0:	92 2c       	mov	r9, r2
    33c2:	9b 18       	sub	r9, r11
    33c4:	0d c0       	rjmp	.+26     	; 0x33e0 <vfprintf+0x348>
    33c6:	b2 14       	cp	r11, r2
    33c8:	58 f4       	brcc	.+22     	; 0x33e0 <vfprintf+0x348>
    33ca:	b6 01       	movw	r22, r12
    33cc:	80 e2       	ldi	r24, 0x20	; 32
    33ce:	90 e0       	ldi	r25, 0x00	; 0
    33d0:	76 d0       	rcall	.+236    	; 0x34be <fputc>
    33d2:	b3 94       	inc	r11
    33d4:	f8 cf       	rjmp	.-16     	; 0x33c6 <vfprintf+0x32e>
    33d6:	b2 14       	cp	r11, r2
    33d8:	18 f4       	brcc	.+6      	; 0x33e0 <vfprintf+0x348>
    33da:	2b 18       	sub	r2, r11
    33dc:	02 c0       	rjmp	.+4      	; 0x33e2 <vfprintf+0x34a>
    33de:	98 2c       	mov	r9, r8
    33e0:	21 2c       	mov	r2, r1
    33e2:	a4 fe       	sbrs	r10, 4
    33e4:	0f c0       	rjmp	.+30     	; 0x3404 <vfprintf+0x36c>
    33e6:	b6 01       	movw	r22, r12
    33e8:	80 e3       	ldi	r24, 0x30	; 48
    33ea:	90 e0       	ldi	r25, 0x00	; 0
    33ec:	68 d0       	rcall	.+208    	; 0x34be <fputc>
    33ee:	a2 fe       	sbrs	r10, 2
    33f0:	16 c0       	rjmp	.+44     	; 0x341e <vfprintf+0x386>
    33f2:	a1 fc       	sbrc	r10, 1
    33f4:	03 c0       	rjmp	.+6      	; 0x33fc <vfprintf+0x364>
    33f6:	88 e7       	ldi	r24, 0x78	; 120
    33f8:	90 e0       	ldi	r25, 0x00	; 0
    33fa:	02 c0       	rjmp	.+4      	; 0x3400 <vfprintf+0x368>
    33fc:	88 e5       	ldi	r24, 0x58	; 88
    33fe:	90 e0       	ldi	r25, 0x00	; 0
    3400:	b6 01       	movw	r22, r12
    3402:	0c c0       	rjmp	.+24     	; 0x341c <vfprintf+0x384>
    3404:	8a 2d       	mov	r24, r10
    3406:	86 78       	andi	r24, 0x86	; 134
    3408:	51 f0       	breq	.+20     	; 0x341e <vfprintf+0x386>
    340a:	a1 fe       	sbrs	r10, 1
    340c:	02 c0       	rjmp	.+4      	; 0x3412 <vfprintf+0x37a>
    340e:	8b e2       	ldi	r24, 0x2B	; 43
    3410:	01 c0       	rjmp	.+2      	; 0x3414 <vfprintf+0x37c>
    3412:	80 e2       	ldi	r24, 0x20	; 32
    3414:	a7 fc       	sbrc	r10, 7
    3416:	8d e2       	ldi	r24, 0x2D	; 45
    3418:	b6 01       	movw	r22, r12
    341a:	90 e0       	ldi	r25, 0x00	; 0
    341c:	50 d0       	rcall	.+160    	; 0x34be <fputc>
    341e:	89 14       	cp	r8, r9
    3420:	30 f4       	brcc	.+12     	; 0x342e <vfprintf+0x396>
    3422:	b6 01       	movw	r22, r12
    3424:	80 e3       	ldi	r24, 0x30	; 48
    3426:	90 e0       	ldi	r25, 0x00	; 0
    3428:	4a d0       	rcall	.+148    	; 0x34be <fputc>
    342a:	9a 94       	dec	r9
    342c:	f8 cf       	rjmp	.-16     	; 0x341e <vfprintf+0x386>
    342e:	8a 94       	dec	r8
    3430:	f3 01       	movw	r30, r6
    3432:	e8 0d       	add	r30, r8
    3434:	f1 1d       	adc	r31, r1
    3436:	80 81       	ld	r24, Z
    3438:	b6 01       	movw	r22, r12
    343a:	90 e0       	ldi	r25, 0x00	; 0
    343c:	40 d0       	rcall	.+128    	; 0x34be <fputc>
    343e:	81 10       	cpse	r8, r1
    3440:	f6 cf       	rjmp	.-20     	; 0x342e <vfprintf+0x396>
    3442:	22 20       	and	r2, r2
    3444:	09 f4       	brne	.+2      	; 0x3448 <vfprintf+0x3b0>
    3446:	4e ce       	rjmp	.-868    	; 0x30e4 <vfprintf+0x4c>
    3448:	b6 01       	movw	r22, r12
    344a:	80 e2       	ldi	r24, 0x20	; 32
    344c:	90 e0       	ldi	r25, 0x00	; 0
    344e:	37 d0       	rcall	.+110    	; 0x34be <fputc>
    3450:	2a 94       	dec	r2
    3452:	f7 cf       	rjmp	.-18     	; 0x3442 <vfprintf+0x3aa>
    3454:	f6 01       	movw	r30, r12
    3456:	86 81       	ldd	r24, Z+6	; 0x06
    3458:	97 81       	ldd	r25, Z+7	; 0x07
    345a:	02 c0       	rjmp	.+4      	; 0x3460 <vfprintf+0x3c8>
    345c:	8f ef       	ldi	r24, 0xFF	; 255
    345e:	9f ef       	ldi	r25, 0xFF	; 255
    3460:	2b 96       	adiw	r28, 0x0b	; 11
    3462:	0f b6       	in	r0, 0x3f	; 63
    3464:	f8 94       	cli
    3466:	de bf       	out	0x3e, r29	; 62
    3468:	0f be       	out	0x3f, r0	; 63
    346a:	cd bf       	out	0x3d, r28	; 61
    346c:	df 91       	pop	r29
    346e:	cf 91       	pop	r28
    3470:	1f 91       	pop	r17
    3472:	0f 91       	pop	r16
    3474:	ff 90       	pop	r15
    3476:	ef 90       	pop	r14
    3478:	df 90       	pop	r13
    347a:	cf 90       	pop	r12
    347c:	bf 90       	pop	r11
    347e:	af 90       	pop	r10
    3480:	9f 90       	pop	r9
    3482:	8f 90       	pop	r8
    3484:	7f 90       	pop	r7
    3486:	6f 90       	pop	r6
    3488:	5f 90       	pop	r5
    348a:	4f 90       	pop	r4
    348c:	3f 90       	pop	r3
    348e:	2f 90       	pop	r2
    3490:	08 95       	ret

00003492 <strnlen_P>:
    3492:	fc 01       	movw	r30, r24
    3494:	05 90       	lpm	r0, Z+
    3496:	61 50       	subi	r22, 0x01	; 1
    3498:	70 40       	sbci	r23, 0x00	; 0
    349a:	01 10       	cpse	r0, r1
    349c:	d8 f7       	brcc	.-10     	; 0x3494 <strnlen_P+0x2>
    349e:	80 95       	com	r24
    34a0:	90 95       	com	r25
    34a2:	8e 0f       	add	r24, r30
    34a4:	9f 1f       	adc	r25, r31
    34a6:	08 95       	ret

000034a8 <strnlen>:
    34a8:	fc 01       	movw	r30, r24
    34aa:	61 50       	subi	r22, 0x01	; 1
    34ac:	70 40       	sbci	r23, 0x00	; 0
    34ae:	01 90       	ld	r0, Z+
    34b0:	01 10       	cpse	r0, r1
    34b2:	d8 f7       	brcc	.-10     	; 0x34aa <strnlen+0x2>
    34b4:	80 95       	com	r24
    34b6:	90 95       	com	r25
    34b8:	8e 0f       	add	r24, r30
    34ba:	9f 1f       	adc	r25, r31
    34bc:	08 95       	ret

000034be <fputc>:
    34be:	0f 93       	push	r16
    34c0:	1f 93       	push	r17
    34c2:	cf 93       	push	r28
    34c4:	df 93       	push	r29
    34c6:	fb 01       	movw	r30, r22
    34c8:	23 81       	ldd	r18, Z+3	; 0x03
    34ca:	21 fd       	sbrc	r18, 1
    34cc:	03 c0       	rjmp	.+6      	; 0x34d4 <fputc+0x16>
    34ce:	8f ef       	ldi	r24, 0xFF	; 255
    34d0:	9f ef       	ldi	r25, 0xFF	; 255
    34d2:	2c c0       	rjmp	.+88     	; 0x352c <fputc+0x6e>
    34d4:	22 ff       	sbrs	r18, 2
    34d6:	16 c0       	rjmp	.+44     	; 0x3504 <fputc+0x46>
    34d8:	46 81       	ldd	r20, Z+6	; 0x06
    34da:	57 81       	ldd	r21, Z+7	; 0x07
    34dc:	24 81       	ldd	r18, Z+4	; 0x04
    34de:	35 81       	ldd	r19, Z+5	; 0x05
    34e0:	42 17       	cp	r20, r18
    34e2:	53 07       	cpc	r21, r19
    34e4:	44 f4       	brge	.+16     	; 0x34f6 <fputc+0x38>
    34e6:	a0 81       	ld	r26, Z
    34e8:	b1 81       	ldd	r27, Z+1	; 0x01
    34ea:	9d 01       	movw	r18, r26
    34ec:	2f 5f       	subi	r18, 0xFF	; 255
    34ee:	3f 4f       	sbci	r19, 0xFF	; 255
    34f0:	31 83       	std	Z+1, r19	; 0x01
    34f2:	20 83       	st	Z, r18
    34f4:	8c 93       	st	X, r24
    34f6:	26 81       	ldd	r18, Z+6	; 0x06
    34f8:	37 81       	ldd	r19, Z+7	; 0x07
    34fa:	2f 5f       	subi	r18, 0xFF	; 255
    34fc:	3f 4f       	sbci	r19, 0xFF	; 255
    34fe:	37 83       	std	Z+7, r19	; 0x07
    3500:	26 83       	std	Z+6, r18	; 0x06
    3502:	14 c0       	rjmp	.+40     	; 0x352c <fputc+0x6e>
    3504:	8b 01       	movw	r16, r22
    3506:	ec 01       	movw	r28, r24
    3508:	fb 01       	movw	r30, r22
    350a:	00 84       	ldd	r0, Z+8	; 0x08
    350c:	f1 85       	ldd	r31, Z+9	; 0x09
    350e:	e0 2d       	mov	r30, r0
    3510:	09 95       	icall
    3512:	89 2b       	or	r24, r25
    3514:	e1 f6       	brne	.-72     	; 0x34ce <fputc+0x10>
    3516:	d8 01       	movw	r26, r16
    3518:	16 96       	adiw	r26, 0x06	; 6
    351a:	8d 91       	ld	r24, X+
    351c:	9c 91       	ld	r25, X
    351e:	17 97       	sbiw	r26, 0x07	; 7
    3520:	01 96       	adiw	r24, 0x01	; 1
    3522:	17 96       	adiw	r26, 0x07	; 7
    3524:	9c 93       	st	X, r25
    3526:	8e 93       	st	-X, r24
    3528:	16 97       	sbiw	r26, 0x06	; 6
    352a:	ce 01       	movw	r24, r28
    352c:	df 91       	pop	r29
    352e:	cf 91       	pop	r28
    3530:	1f 91       	pop	r17
    3532:	0f 91       	pop	r16
    3534:	08 95       	ret

00003536 <__ultoa_invert>:
    3536:	fa 01       	movw	r30, r20
    3538:	aa 27       	eor	r26, r26
    353a:	28 30       	cpi	r18, 0x08	; 8
    353c:	51 f1       	breq	.+84     	; 0x3592 <__ultoa_invert+0x5c>
    353e:	20 31       	cpi	r18, 0x10	; 16
    3540:	81 f1       	breq	.+96     	; 0x35a2 <__ultoa_invert+0x6c>
    3542:	e8 94       	clt
    3544:	6f 93       	push	r22
    3546:	6e 7f       	andi	r22, 0xFE	; 254
    3548:	6e 5f       	subi	r22, 0xFE	; 254
    354a:	7f 4f       	sbci	r23, 0xFF	; 255
    354c:	8f 4f       	sbci	r24, 0xFF	; 255
    354e:	9f 4f       	sbci	r25, 0xFF	; 255
    3550:	af 4f       	sbci	r26, 0xFF	; 255
    3552:	b1 e0       	ldi	r27, 0x01	; 1
    3554:	3e d0       	rcall	.+124    	; 0x35d2 <__ultoa_invert+0x9c>
    3556:	b4 e0       	ldi	r27, 0x04	; 4
    3558:	3c d0       	rcall	.+120    	; 0x35d2 <__ultoa_invert+0x9c>
    355a:	67 0f       	add	r22, r23
    355c:	78 1f       	adc	r23, r24
    355e:	89 1f       	adc	r24, r25
    3560:	9a 1f       	adc	r25, r26
    3562:	a1 1d       	adc	r26, r1
    3564:	68 0f       	add	r22, r24
    3566:	79 1f       	adc	r23, r25
    3568:	8a 1f       	adc	r24, r26
    356a:	91 1d       	adc	r25, r1
    356c:	a1 1d       	adc	r26, r1
    356e:	6a 0f       	add	r22, r26
    3570:	71 1d       	adc	r23, r1
    3572:	81 1d       	adc	r24, r1
    3574:	91 1d       	adc	r25, r1
    3576:	a1 1d       	adc	r26, r1
    3578:	20 d0       	rcall	.+64     	; 0x35ba <__ultoa_invert+0x84>
    357a:	09 f4       	brne	.+2      	; 0x357e <__ultoa_invert+0x48>
    357c:	68 94       	set
    357e:	3f 91       	pop	r19
    3580:	2a e0       	ldi	r18, 0x0A	; 10
    3582:	26 9f       	mul	r18, r22
    3584:	11 24       	eor	r1, r1
    3586:	30 19       	sub	r19, r0
    3588:	30 5d       	subi	r19, 0xD0	; 208
    358a:	31 93       	st	Z+, r19
    358c:	de f6       	brtc	.-74     	; 0x3544 <__ultoa_invert+0xe>
    358e:	cf 01       	movw	r24, r30
    3590:	08 95       	ret
    3592:	46 2f       	mov	r20, r22
    3594:	47 70       	andi	r20, 0x07	; 7
    3596:	40 5d       	subi	r20, 0xD0	; 208
    3598:	41 93       	st	Z+, r20
    359a:	b3 e0       	ldi	r27, 0x03	; 3
    359c:	0f d0       	rcall	.+30     	; 0x35bc <__ultoa_invert+0x86>
    359e:	c9 f7       	brne	.-14     	; 0x3592 <__ultoa_invert+0x5c>
    35a0:	f6 cf       	rjmp	.-20     	; 0x358e <__ultoa_invert+0x58>
    35a2:	46 2f       	mov	r20, r22
    35a4:	4f 70       	andi	r20, 0x0F	; 15
    35a6:	40 5d       	subi	r20, 0xD0	; 208
    35a8:	4a 33       	cpi	r20, 0x3A	; 58
    35aa:	18 f0       	brcs	.+6      	; 0x35b2 <__ultoa_invert+0x7c>
    35ac:	49 5d       	subi	r20, 0xD9	; 217
    35ae:	31 fd       	sbrc	r19, 1
    35b0:	40 52       	subi	r20, 0x20	; 32
    35b2:	41 93       	st	Z+, r20
    35b4:	02 d0       	rcall	.+4      	; 0x35ba <__ultoa_invert+0x84>
    35b6:	a9 f7       	brne	.-22     	; 0x35a2 <__ultoa_invert+0x6c>
    35b8:	ea cf       	rjmp	.-44     	; 0x358e <__ultoa_invert+0x58>
    35ba:	b4 e0       	ldi	r27, 0x04	; 4
    35bc:	a6 95       	lsr	r26
    35be:	97 95       	ror	r25
    35c0:	87 95       	ror	r24
    35c2:	77 95       	ror	r23
    35c4:	67 95       	ror	r22
    35c6:	ba 95       	dec	r27
    35c8:	c9 f7       	brne	.-14     	; 0x35bc <__ultoa_invert+0x86>
    35ca:	00 97       	sbiw	r24, 0x00	; 0
    35cc:	61 05       	cpc	r22, r1
    35ce:	71 05       	cpc	r23, r1
    35d0:	08 95       	ret
    35d2:	9b 01       	movw	r18, r22
    35d4:	ac 01       	movw	r20, r24
    35d6:	0a 2e       	mov	r0, r26
    35d8:	06 94       	lsr	r0
    35da:	57 95       	ror	r21
    35dc:	47 95       	ror	r20
    35de:	37 95       	ror	r19
    35e0:	27 95       	ror	r18
    35e2:	ba 95       	dec	r27
    35e4:	c9 f7       	brne	.-14     	; 0x35d8 <__ultoa_invert+0xa2>
    35e6:	62 0f       	add	r22, r18
    35e8:	73 1f       	adc	r23, r19
    35ea:	84 1f       	adc	r24, r20
    35ec:	95 1f       	adc	r25, r21
    35ee:	a0 1d       	adc	r26, r0
    35f0:	08 95       	ret

000035f2 <_exit>:
    35f2:	f8 94       	cli

000035f4 <__stop_program>:
    35f4:	ff cf       	rjmp	.-2      	; 0x35f4 <__stop_program>
